{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Curso Java Formaci\u00f3n JAVA Bloque Java B\u00e1sico \u00cdndice Java 1.1. Historia de Java 1.2. La M\u00e1quina Virtual Java 1.3. El lenguaje Java Entorno de desarrollo 2.1. Instalaci\u00f3n del JDK (Java Development Kit) 2.2. Instalaci\u00f3n del entorno de desarrollo Eclipse Bloques b\u00e1sicos en Java 3.1. Comprender la estructura de clases de Java 3.1.1. Propiedades y m\u00e9todos 3.1.2. Comentarios 3.1.3. Javadoc 3.1.4. Clases vs. Archivos 3.2. El m\u00e9todo main() 3.3. Paquetes e importaciones 3.3.1. Wildcards 3.3.2. Imports redundantes 3.3.3. Conflictos de nombrado 3.3.4. Crear un nuevo paquete 3.3.5. Compilar c\u00f3digo con packages : 3.3.6. Ruta de las clases y JARs 3.4. Crear objetos 3.4.1. Constructores 3.4.2. Leer y modificar las propiedades de los objetos 3.4.3. Bloques inicializadores de instancias 3.4.4. Orden de inicializaci\u00f3n 3.5. Diferencia entre referencias a objetos y primitivas de datos 3.5.1. Primitivas de datos 3.5.2. Tipos referencia 3.5.3. Diferencias clave 3.6. Declarando e inicializando variables 3.6.1. Declarar m\u00faltiples variables 3.6.2. Identificadores 3.7. Comprensi\u00f3n de la inicializaci\u00f3n por defecto de las variables 3.7.1. Variables locales 3.7.2. Variables de clase e instancia 3.8. Entendiendo el \u00e1mbito de las variables 3.9. Ordenando elementos en una clase 3.10. Destruyendo Objetos 3.10.1. Garbage Collection 3.10.2. finalize() 3.11. Beneficios de Java 3.12. Resumen Operadores y sentencias 4.1. Entender los operadores de Java 4.2. Trabajando con operadores binarios aritm\u00e9ticos 4.2.1. Operadores aritm\u00e9ticos 4.2.2. Promoci\u00f3n num\u00e9rica 4.3. Trabajando con operadores unarios 4.3.1. Complemento l\u00f3gico y operadores de negaci\u00f3n 4.3.2. Operadores de incremento y decremento. 4.4. Usando los operadores binarios adicionales 4.4.1. Operadores de asignaci\u00f3n 4.4.2. Casting de valores primitivos 4.4.3. Operadores de asignaci\u00f3n compuestos 4.4.4. Operadores relacionales 4.4.5. Operadores l\u00f3gicos 4.4.6. Operadores de igualdad 4.5. Comprender las sentencias de Java 4.5.1. if-then 4.5.2. if-then-else 4.5.3. Operador Ternario 4.5.4. switch 4.5.5. while 4.5.6. do-while 4.5.7. La sentencia for 4.5.8. La sentencia for-each 4.6. Comprendiendo el control de flujo avanzado 4.6.1. Bucles anidados 4.6.2. A\u00f1adiendo etiquetas opcionales 4.6.3. La declaraci\u00f3n break 4.6.4. La sentencia continue 4.6.1. Resumen API de Java 5.1. Creando y Manipulando Strings 5.1.1. Concatenaci\u00f3n 5.1.2. Inmutabilidad 5.1.3. La String Pool 5.1.4. M\u00e9todos importantes de String 5.1.5. Encadenado de M\u00e9todos 5.2. Usando la Clase StringBuilder 5.2.1. Mutabilidad y Encadenado 5.2.2. Creando un StringBuilder 5.2.3. M\u00e9todos importantes de StringBuilder 5.3. Entender Igualdad 5.4. Entender Arrays de Java 5.4.1. Creando un array de primitivas de datos 5.4.2. Crear un array con variables referencia 5.4.3. Hacer uso de un array 5.4.4. Sorting 5.4.5. B\u00fasquedas en arrays 5.4.6. Varargs 5.4.7. Arrays Multidimensionales 5.5. Entender un ArrayList 5.5.1. Crear un ArrayList 5.5.2. Usar un ArrayList 5.5.3. M\u00e9todos \u00fatiles de ArrayList 5.5.4. Clases envolventes (Wrapper classes) 5.5.5. Autoboxing 5.5.6. Conversi\u00f3n entre array y List 5.5.7. Sorting 5.6. Trabajando con Fechas y Horas 5.6.1. Creando fechas y horas 5.6.2. Manipulando fechas y horas 5.6.3. Trabajar con Periodos 5.6.4. Formatear Fechas y Tiempos 5.6.5. Parseando fechas y horas 5.7. Resumen M\u00e9todos y encapsulamiento 6.1. Dise\u00f1ando M\u00e9todos 6.1.1. Modificadores de acceso 6.1.2. Especificadores opcionales 6.1.3. Tipo de retorno 6.1.4. Nombre del m\u00e9todo 6.1.5. Lista de par\u00e1metros 6.1.6. Lista de excepciones opcionales 6.1.7. Cuerpo del m\u00e9todo 6.2. Trabajando con Varargs 6.3. Aplicando Modificadores de Acceso 6.3.1. Acceso private 6.3.2. Acceso default (Package Private) 6.3.3. Acceso protected 6.3.4. Acceso public 6.3.5. Dise\u00f1ando m\u00e9todos y variables est\u00e1ticas 6.3.6. Instancia vs Est\u00e1tico 6.3.7. Variables est\u00e1ticas 6.3.8. Inicializaci\u00f3n est\u00e1tica 6.3.9. Imports est\u00e1ticos 6.4. Pasando Datos a Trav\u00e9s de M\u00e9todos 6.5. Sobrecargando M\u00e9todos 6.5.1. Sobrecargas y Varargs 6.5.2. Autoboxing 6.5.3. Tipos de referencias 6.5.4. Primitivas de datos 6.5.5. Junt\u00e1ndolo todo 6.6. Creando Constructores 6.6.1. Constructor por defecto 6.6.2. Sobrecargando constructores 6.6.3. Campos final 6.6.4. Orden de inicializaci\u00f3n 6.7. Encapsulando Datos 6.7.1. Creando clases inmutables 6.7.2. Tipos de retorno en la clases inmutables 6.8. Escribiendo Lambdas Simples 6.8.1. Ejemplo Lambda 6.8.2. Sintaxis Lambda 6.8.3. Predicados 6.9. Resumen Dise\u00f1o de clases 7.1. Introducci\u00f3n a la herencia de clases 7.1.1. Extendiendo una clase 7.1.2. Aplicaci\u00f3n de los modificadores de acceso para clases 7.1.3. Creando objetos Java 7.1.4. Definiendo Constructores 7.1.5. Llamando a miembros de clase heredada 7.1.6. Heredando m\u00e9todos 7.1.7. Heredar variables 7.2. Creando clases abstractas 7.2.1. Definiendo una clase abstracta 7.2.2. Creando una clase concreta (Concret class) 7.2.3. Extendiendo una clase abstracta 7.3. Implementando interfaces 7.3.1. Definiendo una Interfaz 7.3.2. Heredando una interfaz 7.3.3. Variables en las interfaces 7.3.4. M\u00e9todos por defecto de las interfaces 7.3.5. M\u00e9todos est\u00e1ticos en interfaces 7.4. Entendiendo el polimorfismo 7.4.1. Objecto vs. Referencia 7.4.2. Hacer casting a objetos 7.4.3. M\u00e9todos virtuales 7.4.4. Par\u00e1metros polimorfos 7.4.5. Polimorfismo y reescritura de m\u00e9todos 7.5. Resumen Excepciones 8.1. Entendiendo las excepciones 8.1.1. La funci\u00f3n de las excepciones 8.1.2. Entendiendo los tipos de excepci\u00f3n 8.1.3. Lanzando una Exception 8.2. Usando la sentencia try 8.2.1. A\u00f1adiendo un bloque finally 8.2.2. Capturando varios tipos de excepciones 8.2.3. Lanzando una segunda Exception 8.3. Reconocimiento de los tipos comunes de excepciones 8.3.1. Runtime Exceptions 8.3.2. Excepciones controladas (Checked Exceptions) 8.3.3. Errors 8.4. Llamando a m\u00e9todos que provocan excepciones 8.4.1. Subclases: 8.4.2. Imprimir una excepci\u00f3n: 8.5. Resumen","title":"\u00cdndice de contenido"},{"location":"#curso-java","text":"","title":"Curso Java"},{"location":"#formacion-java","text":"","title":"Formaci\u00f3n JAVA"},{"location":"#bloque-java-basico","text":"","title":"Bloque Java B\u00e1sico"},{"location":"#indice","text":"Java 1.1. Historia de Java 1.2. La M\u00e1quina Virtual Java 1.3. El lenguaje Java Entorno de desarrollo 2.1. Instalaci\u00f3n del JDK (Java Development Kit) 2.2. Instalaci\u00f3n del entorno de desarrollo Eclipse Bloques b\u00e1sicos en Java 3.1. Comprender la estructura de clases de Java 3.1.1. Propiedades y m\u00e9todos 3.1.2. Comentarios 3.1.3. Javadoc 3.1.4. Clases vs. Archivos 3.2. El m\u00e9todo main() 3.3. Paquetes e importaciones 3.3.1. Wildcards 3.3.2. Imports redundantes 3.3.3. Conflictos de nombrado 3.3.4. Crear un nuevo paquete 3.3.5. Compilar c\u00f3digo con packages : 3.3.6. Ruta de las clases y JARs 3.4. Crear objetos 3.4.1. Constructores 3.4.2. Leer y modificar las propiedades de los objetos 3.4.3. Bloques inicializadores de instancias 3.4.4. Orden de inicializaci\u00f3n 3.5. Diferencia entre referencias a objetos y primitivas de datos 3.5.1. Primitivas de datos 3.5.2. Tipos referencia 3.5.3. Diferencias clave 3.6. Declarando e inicializando variables 3.6.1. Declarar m\u00faltiples variables 3.6.2. Identificadores 3.7. Comprensi\u00f3n de la inicializaci\u00f3n por defecto de las variables 3.7.1. Variables locales 3.7.2. Variables de clase e instancia 3.8. Entendiendo el \u00e1mbito de las variables 3.9. Ordenando elementos en una clase 3.10. Destruyendo Objetos 3.10.1. Garbage Collection 3.10.2. finalize() 3.11. Beneficios de Java 3.12. Resumen Operadores y sentencias 4.1. Entender los operadores de Java 4.2. Trabajando con operadores binarios aritm\u00e9ticos 4.2.1. Operadores aritm\u00e9ticos 4.2.2. Promoci\u00f3n num\u00e9rica 4.3. Trabajando con operadores unarios 4.3.1. Complemento l\u00f3gico y operadores de negaci\u00f3n 4.3.2. Operadores de incremento y decremento. 4.4. Usando los operadores binarios adicionales 4.4.1. Operadores de asignaci\u00f3n 4.4.2. Casting de valores primitivos 4.4.3. Operadores de asignaci\u00f3n compuestos 4.4.4. Operadores relacionales 4.4.5. Operadores l\u00f3gicos 4.4.6. Operadores de igualdad 4.5. Comprender las sentencias de Java 4.5.1. if-then 4.5.2. if-then-else 4.5.3. Operador Ternario 4.5.4. switch 4.5.5. while 4.5.6. do-while 4.5.7. La sentencia for 4.5.8. La sentencia for-each 4.6. Comprendiendo el control de flujo avanzado 4.6.1. Bucles anidados 4.6.2. A\u00f1adiendo etiquetas opcionales 4.6.3. La declaraci\u00f3n break 4.6.4. La sentencia continue 4.6.1. Resumen API de Java 5.1. Creando y Manipulando Strings 5.1.1. Concatenaci\u00f3n 5.1.2. Inmutabilidad 5.1.3. La String Pool 5.1.4. M\u00e9todos importantes de String 5.1.5. Encadenado de M\u00e9todos 5.2. Usando la Clase StringBuilder 5.2.1. Mutabilidad y Encadenado 5.2.2. Creando un StringBuilder 5.2.3. M\u00e9todos importantes de StringBuilder 5.3. Entender Igualdad 5.4. Entender Arrays de Java 5.4.1. Creando un array de primitivas de datos 5.4.2. Crear un array con variables referencia 5.4.3. Hacer uso de un array 5.4.4. Sorting 5.4.5. B\u00fasquedas en arrays 5.4.6. Varargs 5.4.7. Arrays Multidimensionales 5.5. Entender un ArrayList 5.5.1. Crear un ArrayList 5.5.2. Usar un ArrayList 5.5.3. M\u00e9todos \u00fatiles de ArrayList 5.5.4. Clases envolventes (Wrapper classes) 5.5.5. Autoboxing 5.5.6. Conversi\u00f3n entre array y List 5.5.7. Sorting 5.6. Trabajando con Fechas y Horas 5.6.1. Creando fechas y horas 5.6.2. Manipulando fechas y horas 5.6.3. Trabajar con Periodos 5.6.4. Formatear Fechas y Tiempos 5.6.5. Parseando fechas y horas 5.7. Resumen M\u00e9todos y encapsulamiento 6.1. Dise\u00f1ando M\u00e9todos 6.1.1. Modificadores de acceso 6.1.2. Especificadores opcionales 6.1.3. Tipo de retorno 6.1.4. Nombre del m\u00e9todo 6.1.5. Lista de par\u00e1metros 6.1.6. Lista de excepciones opcionales 6.1.7. Cuerpo del m\u00e9todo 6.2. Trabajando con Varargs 6.3. Aplicando Modificadores de Acceso 6.3.1. Acceso private 6.3.2. Acceso default (Package Private) 6.3.3. Acceso protected 6.3.4. Acceso public 6.3.5. Dise\u00f1ando m\u00e9todos y variables est\u00e1ticas 6.3.6. Instancia vs Est\u00e1tico 6.3.7. Variables est\u00e1ticas 6.3.8. Inicializaci\u00f3n est\u00e1tica 6.3.9. Imports est\u00e1ticos 6.4. Pasando Datos a Trav\u00e9s de M\u00e9todos 6.5. Sobrecargando M\u00e9todos 6.5.1. Sobrecargas y Varargs 6.5.2. Autoboxing 6.5.3. Tipos de referencias 6.5.4. Primitivas de datos 6.5.5. Junt\u00e1ndolo todo 6.6. Creando Constructores 6.6.1. Constructor por defecto 6.6.2. Sobrecargando constructores 6.6.3. Campos final 6.6.4. Orden de inicializaci\u00f3n 6.7. Encapsulando Datos 6.7.1. Creando clases inmutables 6.7.2. Tipos de retorno en la clases inmutables 6.8. Escribiendo Lambdas Simples 6.8.1. Ejemplo Lambda 6.8.2. Sintaxis Lambda 6.8.3. Predicados 6.9. Resumen Dise\u00f1o de clases 7.1. Introducci\u00f3n a la herencia de clases 7.1.1. Extendiendo una clase 7.1.2. Aplicaci\u00f3n de los modificadores de acceso para clases 7.1.3. Creando objetos Java 7.1.4. Definiendo Constructores 7.1.5. Llamando a miembros de clase heredada 7.1.6. Heredando m\u00e9todos 7.1.7. Heredar variables 7.2. Creando clases abstractas 7.2.1. Definiendo una clase abstracta 7.2.2. Creando una clase concreta (Concret class) 7.2.3. Extendiendo una clase abstracta 7.3. Implementando interfaces 7.3.1. Definiendo una Interfaz 7.3.2. Heredando una interfaz 7.3.3. Variables en las interfaces 7.3.4. M\u00e9todos por defecto de las interfaces 7.3.5. M\u00e9todos est\u00e1ticos en interfaces 7.4. Entendiendo el polimorfismo 7.4.1. Objecto vs. Referencia 7.4.2. Hacer casting a objetos 7.4.3. M\u00e9todos virtuales 7.4.4. Par\u00e1metros polimorfos 7.4.5. Polimorfismo y reescritura de m\u00e9todos 7.5. Resumen Excepciones 8.1. Entendiendo las excepciones 8.1.1. La funci\u00f3n de las excepciones 8.1.2. Entendiendo los tipos de excepci\u00f3n 8.1.3. Lanzando una Exception 8.2. Usando la sentencia try 8.2.1. A\u00f1adiendo un bloque finally 8.2.2. Capturando varios tipos de excepciones 8.2.3. Lanzando una segunda Exception 8.3. Reconocimiento de los tipos comunes de excepciones 8.3.1. Runtime Exceptions 8.3.2. Excepciones controladas (Checked Exceptions) 8.3.3. Errors 8.4. Llamando a m\u00e9todos que provocan excepciones 8.4.1. Subclases: 8.4.2. Imprimir una excepci\u00f3n: 8.5. Resumen","title":"\u00cdndice"},{"location":"api/","text":"","title":"API de Java"},{"location":"bloques_basicos/","text":"3. Bloques b\u00e1sicos en Java 3.1. Comprender la estructura de clases de Java Las clases son los componentes b\u00e1sicos en un programa Java. Cuando se define una clase , se describen todas las partes y caracter\u00edsticas que la componen. Para utilizar la mayor\u00eda de las clases, se tienen que crear objetos. Un objeto es una instancia de la clase en tiempo de ejecuci\u00f3n. Los objetos de las distintas clases representan el estado del programa. En las siguientes secciones se ver\u00e1n los componentes de una clase Java, as\u00ed como la relaci\u00f3n entre clases y archivos. 3.1.1. Propiedades y m\u00e9todos Las clases Java tienen dos elementos principales, m\u00e9todos , a menudo llamados funciones o procedimientos, y propiedades , tambi\u00e9n conocidas como atributos. Las propiedades mantienen el estado del programa, y los m\u00e9todos operan en ese estado. Si el cambio es relevante en el estado del programa, se almacenar\u00e1 en una propiedad. Es el programador quien crea y organiza estos elementos de tal manera que el c\u00f3digo sea \u00fatil y f\u00e1cil de entender para otros programadores. La clase Java m\u00e1s simple que puede escribirse es como la que sigue: (Los n\u00fameros de l\u00ednea solo est\u00e1n ah\u00ed para hacer la lectura del c\u00f3digo m\u00e1s f\u00e1cil, no intervienen en el programa). 1: public class Fruit { 2: } En Java existen palabras reservadas, tambi\u00e9n llamadas palabras clave o keywords. Estas palabras poseen un significado especial para Java, como, por ejemplo, la palabra reservada public (l\u00ednea 1), que permite a la clase Fruit ser utilizada por otras clases. La palabra reservada class indica que se est\u00e1 definiendo una clase. Fruit es el nombre de la clase. A continuaci\u00f3n, se a\u00f1adir\u00e1 a la clase Fruit su primera propiedad: 1: public class Fruit { 2: String name; 3: } En la l\u00ednea 2, se define la propiedad llamada name. Tambi\u00e9n se define el tipo de dato de la propiedad como una cadena de texto ( String ). Un String es un tipo de dato que contiene un texto, como por ejemplo \u201cEsto es un String \u201d. String tambi\u00e9n es una clase Java, predefinida en el propio lenguaje. Como se mencion\u00f3 anteriormente, una clase tambi\u00e9n puede contener m\u00e9todos, los cuales se declaran como se ve en el siguiente c\u00f3digo: 1: public class Fruit { 2: String name; 3: public String getName() { 4: return name; 5: } 6: public void setName(String newName) { 7: name = newName; 8: } 9: } En las l\u00edneas 3-5 se ha declarado el primer m\u00e9todo. Un m\u00e9todo es una operaci\u00f3n que puede ser llamada. En la declaraci\u00f3n del m\u00e9todo se hace tambi\u00e9n uso de la palabra reservada public para indicar que el m\u00e9todo puede ser llamado desde cualquier otra clase. La siguiente palabra, String en este caso, hace referencia al tipo de dato que devuelve el m\u00e9todo. En este caso, el tipo de dato devuelto es un String. En las l\u00edneas 6-8 se ha introducido un segundo m\u00e9todo, el cual no devuelve nada (palabra reservada void ). Este m\u00e9todo requiere que se le proporcione informaci\u00f3n cada vez que se le llama; esta informaci\u00f3n se llama par\u00e1metro. El m\u00e9todo setName tiene un par\u00e1metro llamado newName , y es de tipo String. La persona que llama al m\u00e9todo le debe pasar, por lo tanto, un par\u00e1metro de tipo String , y, tras realizar la operaci\u00f3n de asignar el valor del par\u00e1metro newName a la propiedad name , puesto que es void , el m\u00e9todo setName no devolver\u00e1 nada. 3.1.2. Comentarios Los comentarios son muy habituales en el c\u00f3digo de un programa Java. Son l\u00edneas de texto que no son ejecutadas, y que pueden ser colocadas en cualquier lugar. Los comentarios tienen como finalidad hacer la lectura del c\u00f3digo m\u00e1s sencilla. Hay tres tipos de comentarios en Java. 1 - El comentario de una sola l\u00ednea, comienza con dos barras diagonales. // comment until end of line 2 - El comentario de varias l\u00edneas o comentario de l\u00edneas m\u00faltiples, comienza con el s\u00edmbolo \"/ *\" hasta el s\u00edmbolo * /. Se suele escribir * al comienzo de cada l\u00ednea de un comentario de l\u00edneas m\u00faltiples para que sea m\u00e1s f\u00e1cil de leer. /* Multiple (^) * line comment (^) */ 3 - El comentario de Javadoc, muy similar a un comentario de l\u00edneas m\u00faltiples. Los comentarios de Javadoc tienen una estructura espec\u00edfica que la herramienta Javadoc sabe c\u00f3mo interpretar para poder crear la documentaci\u00f3n del c\u00f3digo. La diferencia con los comentarios de l\u00edneas m\u00faltiples es que el comienzo debe ser \"/**\" /** Javadoc multiple-line comment */ 3.1.3. Javadoc Javadoc es una utilidad de Oracle que sirve para generar documentaci\u00f3n de APIs en formato HTML a partir del c\u00f3digo. Al documentar una clase, se debe incluir lo siguiente: Descripci\u00f3n general de la clase, n\u00famero de versi\u00f3n, nombre de autores. Documentaci\u00f3n de m\u00e9todos: incluye descripci\u00f3n general, nombre y tipos de par\u00e1metros, descripci\u00f3n de par\u00e1metros, tipo de retorno, descripci\u00f3n del valor que devuelve. Para que javadoc pueda generar la documentaci\u00f3n autom\u00e1ticamente, la informaci\u00f3n debe incluirse entre s\u00edmbolos de comentario de forma que empiece con una barra simple y doble asterisco (/* ), y termine con un asterisco y barra simple ( /). Dependiendo de la ubicaci\u00f3n, el comentario puede representar una cosa distinta, si est\u00e1 incluido delante de una clase, es un comentario de clase pero, si est\u00e1 incluido delante de un m\u00e9todo, es un comentario de ese m\u00e9todo. Para crear la documentaci\u00f3n de javadoc, se hace uso de palabras reservadas o \"tags\" que van precedidas por el car\u00e1cter \"@\". En la siguiente tabla se puede encontrar las palabras reservadas que suelen utilizarse m\u00e1s a menudo. TAG DESCRIPCI\u00d3N COMPRENDE @author Nombre del desarrollador. Nombre autor o autores @deprecated Indica que el m\u00e9todo o clase es obsoleto (propio de versiones anteriores) y que no se recomienda su uso. Descripci\u00f3n @param Definici\u00f3n de un par\u00e1metro de un m\u00e9todo, es requerido para todos los par\u00e1metros del m\u00e9todo. Nombre de par\u00e1metro y descripci\u00f3n @return Informa de lo que devuelve el m\u00e9todo, no se aplica en constructores o m\u00e9todos \"void\" . Descripci\u00f3n del valor de retorno @see Asocia con otro m\u00e9todo o clase. Referencia cruzada referencia (#m\u00e9todo(); clase#m\u00e9todo(); paquete.clase; paquete.clase#m\u00e9todo()). @version Versi\u00f3n del m\u00e9todo o clase. Versi\u00f3n A continuaci\u00f3n, se ver\u00e1 un ejemplo de documentaci\u00f3n javadoc para una clase y un m\u00e9todo. **/**** *** Clase que implementa un ejemplo de una suma a partir de dos n\u00fameros dados * y** **devuelve el resultado por pantalla.** ***** *** @author Sergio** *** @version 2.** *** @since 20 18** ***/** class EjemploSuma { public static void main(String args[]){ int num1 = 10; int num2 = 5; int result = getSuma(num1,num2); System.out.println(\"La suma es igual a \"+result); } **/**** *** Devuelve la suma de dos n\u00fameros enteros (int)** ***** *** @param a primer sumando** *** @param b segundo sumando** *** @return resultado de la suma** ***/** public static int getSuma(int a, int b) { return a+b; } } 3.1.4. Clases vs. Archivos Normalmente, cada clase de Java se define en su propio archivo * .java. Por lo general las clases son public , lo que significa que cualquier c\u00f3digo puede utilizarlas. Las clases; no obstante, no tienen por qu\u00e9 ser p\u00fablicas. Por ejemplo, definir una clase como sigue (sin la palabra reservada public ), tambi\u00e9n es posible. 1: class Fruit { 2: String name; 3: } Tambi\u00e9n es posible que dos clases Java est\u00e9n en el mismo archivo. En este caso, como mucho una de las clases del archivo puede ser p\u00fablica. Por ejemplo: 1: public class Fruit { 2: private String name; 3: } 4: class FruitSqueezer { 5: } En caso de tener una clase p\u00fablica en el archivo, el nombre de la clase debe coincidir con el nombre del archivo; es decir, public class FruitSqueezer provocar\u00eda un error de compilaci\u00f3n en un archivo llamado Fruit.java . 3.2. El m\u00e9todo main() Un programa Java comienza su ejecuci\u00f3n en su m\u00e9todo main(). El m\u00e9todo main() es lo primero que se ejecuta cuando se inicia el programa, y es llamado autom\u00e1ticamente por la M\u00e1quina Virtual Java (JVM). La JVM es la encargada de comunicarse con el sistema subyacente para asignar recursos como la memoria, la CPU, el acceso a archivos, etc. El m\u00e9todo main() nos sirve como enlace para conectar las distintas partes del c\u00f3digo a partir del inicio de la ejecuci\u00f3n del programa. Un ejemplo del tipo de clase m\u00e1s simple que puede contener el m\u00e9todo main() ser\u00eda como la siguiente: 1: public class Fruit { 2: public static void main(String[] args) { 3: 4: } 5:} Este c\u00f3digo no hace nada \u00fatil. No tiene ninguna instrucci\u00f3n m\u00e1s all\u00e1 que declarar el punto de inicio de la ejecuci\u00f3n del programa. Lo que se pretende con este c\u00f3digo de ejemplo es mostrar que el m\u00e9todo main() se puede declarar en cualquier parte del c\u00f3digo Java. De hecho, la \u00fanica raz\u00f3n de que este m\u00e9todo est\u00e9 dentro de una clase se debe a que el lenguaje as\u00ed lo requiere. Para compilar ( javac ) y ejecutar ( java ) el siguiente c\u00f3digo, este deber\u00eda escribirse dentro del archivo Fruit.java, y posteriormente se deber\u00edan escribir las siguientes instrucciones en la consola: $ javac Fruit.java $ java Fruit En caso de no obtener ning\u00fan mensaje de error, el programa se ejecut\u00f3 con \u00e9xito. En caso de obtener un mensaje de error, se deber\u00eda verificar que el Java Development Kit (JDK) est\u00e1 correctamente instalado y que no existe ning\u00fan error sint\u00e1ctico en la escritura del c\u00f3digo. Para compilar c\u00f3digo Java, el archivo debe tener la extensi\u00f3n .java. El nombre del archivo debe coincidir con el nombre de la clase definida en el archivo. El resultado es otro archivo de bytecode con el mismo nombre, pero con una extensi\u00f3n .class. El bytecode no es c\u00f3digo legible por las personas, pero s\u00ed por la JVM. Las reglas sobre c\u00f3mo debe ser el contenido de un archivo de c\u00f3digo Java son m\u00e1s extensas de lo que se ha visto hasta ahora; no obstante, por el momento y con la finalidad de hacerlo m\u00e1s simple, solo se tendr\u00e1n en cuenta las siguientes: 1 - Cada archivo puede contener solo una clase ( ya se ha visto que no tiene por qu\u00e9 ser as\u00ed, pero de esta forma el c\u00f3digo ser\u00e1 m\u00e1s sencillo ). 2 - El nombre del archivo debe coincidir con el nombre de la clase que contiene, y la extensi\u00f3n de este siempre ser\u00e1 .java. Se supone que se reemplaza la l\u00ednea 3 en Fruit.java con System.out.println (\"Hola\") . Cuando se compila y se ejecuta nuevamente el c\u00f3digo, el programa imprimir\u00e1 en la consola la palabra \u201cHola\u201d . A continuaci\u00f3n se va a revisar en profundidad el m\u00e9todo main() , ya que aparecen en \u00e9l una serie de palabras clave del lenguaje Java, algunas ya vistas anteriormente. La palabra reservada public es lo que se llama un modificador de acceso. Declara el nivel de exposici\u00f3n de este m\u00e9todo a la hora de ser llamado en otras partes del programa. En este caso, public hace referencia a que el m\u00e9todo puede ser llamado en cualquier parte del programa. La palabra reservada static enlaza un m\u00e9todo a su clase para que pueda ser llamado solo por el nombre de la clase, como, por ejemplo, Fruit.main(). No es necesario crear un objeto para llamar al m\u00e9todo main(). Si el m\u00e9todo main() no est\u00e1 presente en la clase .java que se ejecuta en la consola, el proceso generar\u00e1 un error y terminar\u00e1. Incluso si el m\u00e9todo main() est\u00e1 presente y no es est\u00e1tico (palabra reservada static ), Java lanzar\u00e1 una excepci\u00f3n. La palabra reservada void representa el tipo de dato que devuelve el m\u00e9todo. Un m\u00e9todo que no devuelve datos (es decir, que es void ) devuelve el control de la ejecuci\u00f3n del programa al punto donde qued\u00f3 antes de ser ejecutado de manera \u201csilenciosa\u201d. En general, es una buena pr\u00e1ctica usar void para m\u00e9todos que cambian el estado de un objeto. En ese caso, el m\u00e9todo main() cambia el estado del programa de iniciado a finalizado. Finalmente se llega a la lista de par\u00e1metros del m\u00e9todo main() , representada como un array de objetos de tipo java.lang.String. El compilador acepta cualquiera de las siguientes formas a la hora de declarar lo par\u00e1metros: String[] args , String args[] o String...args. La variable args contiene los argumentos que se leyeron de la consola cuando se inici\u00f3 la JVM. Los caracteres [] son corchetes, utilizados para representar que args es un array. Un array es una lista de tama\u00f1o fijo que contiene elementos de un mismo tipo de dato. Los caracteres ... se denominan varargs (lista de argumentos variable). En el siguiente ejemplo se ve c\u00f3mo usar el par\u00e1metro args. Primero se modifica el programa anterior para imprimir los primeros dos argumentos que sean pasados al programa: public class Fruit { public static void main(String[] args) { System.out.println(args[0]); System.out.println(args[1]); } } args[0] accede al primer elemento del array. Los \u00edndices de los array en Java siempre comienzan por 0. Para ejecutar el c\u00f3digo anterior, se podr\u00eda escribir en la consola: $ javac Fruit.java $ java Fruit Banana Apple Y la consola imprimir\u00eda: Banana Apple El programa identifica correctamente las dos primeras palabras como argumentos separados por espacios. En caso de querer espacios dentro de un argumento, se usan comillas tal que as\u00ed: $ javac Fruit.java $ java Fruit \"Big Banana\" Apple Y la consola imprimir\u00eda: Big Banana Apple Todos los argumentos de la l\u00ednea de comandos se tratan como objetos de tipo String , incluso si representan otro tipo de datos: $ javac Fruit.java $ java Fruit Fruit 1 A pesar de que Fruit es una clase y 1 es un n\u00famero, el programa los interpretar\u00e1 a ambos como la cadena de texto \u201cFruit\u201d y la cadena de texto \u201c1\u201d, y por lo tanto, la consola imprimir\u00e1 lo siguiente: Fruit 1 Finalmente, \u00bfQu\u00e9 sucede si no se escriben suficientes argumentos? $ javac Fruit.java $ java Fruit Fruit La lectura de args[0] es correcta y \u201cFruit\u201d se imprime por pantalla, pero al no tener otro argumento, Java imprime una excepci\u00f3n mostrando que no existe ning\u00fan argumento en args[1]. La consola imprimir\u00e1 por lo tanto: FruitException in thread \"main\" java.lang.ArrayIndexOutOfBoundsException: 1 at mainmethod. **Fruit** .main (Fruit.java:7) Es necesario tener un JDK (Java Development Kit) para compilar c\u00f3digo Java; no obstante, el JDK no es necesario para ejecutar el c\u00f3digo, basta con un JRE (Java Runtime Environment). Los archivos de clase Java que se ejecutan en la JVM (Java Virtual Machine) se ejecutan en cualquier m\u00e1quina con Java independientemente de la m\u00e1quina original donde fueron compilados o el sistema operativo de esta. 3.3. Paquetes e importaciones Java tiene miles de clases por defecto y muchas otras creadas por otros desarrolladores, por lo que es necesario una forma de organizarlas. En Java existen paquetes ( packages ), los cuales sirven para organizar las clases de manera l\u00f3gica. Es necesario especificar en qu\u00e9 paquete se encuentra cada clase para que Java pueda utilizar la clase correcta. Se supone que el siguiente c\u00f3digo est\u00e1 por compilar: public class ImportExample { public static void main(String[] args) { Random r = new Random(); // \u00a1No compila! System.out.println(r.nextInt(10)); } } El compilador de Java mostrar\u00e1 un error como el siguiente: Random cannot be resolved to a type Este error podr\u00eda significar un error tipogr\u00e1fico en el nombre de la clase, o puede que se haya omitido un import necesario (la importaci\u00f3n de la clase Random). Las sentencias de importaci\u00f3n ( import ) indican a Java en qu\u00e9 paquetes buscar las clases. Intentarlo de nuevo con la importaci\u00f3n de la clase Random hace que el programa compile: import java.util.Random; // Indica a la clase d\u00f3nde encontrar la clase Random //(Paquete java.util) public class ImportExample { public static void main(String[] args) { Random r = new Random(); System.out.println(r.nextInt(10)); //Imprime por pantalla un n\u00famero // del 0 al 9 } } Ahora el c\u00f3digo se ejecuta e imprime un n\u00famero aleatorio entre 0 y 9. Al igual que ocurre con los arrays , la cuenta empieza en 0. Las clases de Java se agrupan en paquetes ( packages ). La sentencia import le indica al compilador en qu\u00e9 paquete buscar para encontrar una clase. A modo de analog\u00eda, si se imagina una carta cuyo destinatario es la direcci\u00f3n C/San Andr\u00e9s n\u00ba20 1\u00baC. El cartero ir\u00e1 en primer lugar al edificio n\u00famero 20 de la calle San Andr\u00e9s, y luego buscar\u00e1 el piso 1\u00baC. La direcci\u00f3n (calle y n\u00famero de edificio) ser\u00edan los paquetes Java, y 1\u00baC ser\u00eda el nombre de la clase Java, la cual se ha podido encontrar porque se sab\u00eda dentro de qu\u00e9 paquetes estaba. Hay muchos pisos 1\u00baC, pero solo hay un 1\u00baC en el edificio n\u00ba20 de la calle San Andr\u00e9s. Los nombres de los paquetes son jer\u00e1rquicos, al igual que ocurre con el correo. El servicio de correo mirar\u00e1 en primer lugar el pa\u00eds, luego la regi\u00f3n, la ciudad, la calle, el edificio y por \u00faltimo el piso para poder entregar una carta. Con los paquetes Java ocurre algo muy similar. Si el paquete comienza por java o javax significa que es un paquete por defecto del JDK; si empieza por cualquier otra cosa, har\u00e1 referencia al dominio del propietario del paquete. Por ejemplo, el paquete com.amazon.laClaseQueSea indica que el c\u00f3digo viene de amazon.com. Tras el nombre del dominio los nombres del resto de la jerarqu\u00eda de paquetes y clases pueden ser los que el programador guste, aunque es una buena pr\u00e1ctica que estos sean lo m\u00e1s descriptivos posible. En los ejemplos que se muestran a continuaci\u00f3n es posible encontrar paquetes que no provengan de ning\u00fan dominio concreto, como, por ejemplo a.b.c (la clase c est\u00e1 dentro del paquete a.b), esto no es un problema, ya que se trata \u00fanicamente de ejemplos. 3.3.1. Wildcards Las clases que se encuentran en el mismo paquete se pueden importar todas juntas, y para ello, se utiliza el siguiente car\u00e1cter comod\u00edn o wildcard. Actualmente se considera una mala pr\u00e1ctica, ya que se importan clases innecesarias que pueden no necesitarse. import java.util.*; //El asterisco indica que se importar\u00e1n todas las clases dentro //del paquete java.util Ejemplo: import java.util.*; public class ImportExample { public static void main(String[] args) { Random r = new Random(); System.out.println(r.nextInt(10)); } } En este caso, \u00fanicamente se utiliza la clase java.util.Random en el programa; no obstante, se han importado todas las clases del paquete java.util (* es una wildcard que indica todas las clases). \u00danicamente se importar\u00e1n las clases, no los paquetes hijos que contenga. El n\u00famero de import que tenga un programa no ralentiza el programa. El compilador lee cada clase en el momento en que la necesita. 3.3.2. Imports redundantes Como se ha podido ver en el c\u00f3digo de ejemplos anteriores, se han utilizado clases, como la clase System o la clase String en los programas sin importar nada, \u00bfC\u00f3mo es que el c\u00f3digo funcionaba si no se han importado estas clases? Esto se debe a que existe un paquete en Java llamado java.lang que siempre se importa de manera autom\u00e1tica. Aun as\u00ed, Java permite tambi\u00e9n importarlo manualmente. Esto, no obstante, no se debe hacer, ya que importar algo que se importa por defecto o que ya est\u00e1 importado crea c\u00f3digo redundante. Ejemplo: 1: import java.lang.System; 2: import java.lang.*; 3: import java.util.Random; 4: import java.util.*; 5: public class ImportExample { 6: public static void main(String[] args) { 7: Random r = new Random(); 8: System.out.println(r.nextInt(10)); 9: } 10:} \u00bfCu\u00e1ntos de los import son redundantes? La respuesta es tres. Las l\u00edneas 1 y 2 son redundantes porque, como se ha comentado anteriormente, el paquete java.lang es importado de forma autom\u00e1tica y por lo tanto no necesita de un import. La l\u00ednea 4 es tambi\u00e9n redundante. La clase Random es importada al c\u00f3digo mediante la sentencia de la l\u00ednea 3 ( import java.util.Random; ), por lo que no es necesario importar, adem\u00e1s, el resto del paquete java.util de la l\u00ednea 4. Otro caso de redundancia ser\u00eda importar una clase que se encuentra en el mismo paquete que la clase que se est\u00e1 ejecutando, ya que, de forma autom\u00e1tica, Java tiene en cuenta a todas las clases del mismo paquete sin necesidad de importarlas unas en otras. Otro ejemplo: public class InputImports { public void read(Files files) { Paths.get(\"name\"); } } Se supone que las clases Files y Paths est\u00e1n en el mismo paquete java.nio.file, y que la clase del ejemplo, InputInmports, est\u00e1 en un paquete diferente. \u00bfQu\u00e9 se deber\u00eda importar para que el programa compile? Hay dos posibles formas de hacerlo: import java.nio.file.*; //Importa ambos paquetes debido al uso de la _wildcard_ * o import.jav a.nio.file.Files; //Importa la clase File import.java.nio.file.Paths; //Importa la clase Paths A continuaci\u00f3n, se muestran unos ejemplos que NO funcionar\u00edan: import java.nio.*; // NO FUNCIONA. Recordar que la wildcard * //solo importa clases, no otros paquetes import java.nio.*.*; // NO FUNCIONA. Solo puede haber una wildcard //por import y esta debe estar al final import java.nio.file.Paths.*; // NO FUNCIONA. No se pueden importar //m\u00e9todos sin la palabra clave static 3.3.3. Conflictos de nombrado Una de las razones para utilizar paquetes en Java es que el nombre de las clases no tiene por qu\u00e9 ser \u00fanico. Esto quiere decir que algunas veces se querr\u00e1 importar una clase que tenga el mismo nombre que otras que se encuentran en otras partes del programa. Un ejemplo de esto es la clase Date. Java posee implementadas las clases java.util.Date y java.sql.Date. Son dos clases diferentes con el mismo nombre; no obstante, cada una se encuentra en un paquete diferente. Ejemplo: import java.util.*; import java.sql.*; // No compila public class Conflicts { Date date; //M\u00e1s c\u00f3digo } El c\u00f3digo no compila ya que la clase Date existe en ambos paquetes, por lo que Java dar\u00e1 el siguiente error de compilaci\u00f3n: \u201c The type Date is ambiguous \u201d. Tampoco compilar\u00e1 esto: import java.util.Date; import java.sql.Date; Java lanzar\u00e1 el error de compilaci\u00f3n \"The import java.sql.Date collides with another import statement\u201c. En caso de que se quiera usar las clases de ambos paquetes: clases de java.util. y clases de java.sql. , y la clase Date que ser\u00e1 la que est\u00e1 en java.util. , se deber\u00e1 importar lo siguiente: import java.util.Date; import java.sql.*; Ahora, al importar de manera expl\u00edcita la clase Date de java.util. , esta tiene precedencia por encima de todas las clases importadas con la wildcard *. \u00bfQu\u00e9 ocurre si realmente se quiere utilizar en el c\u00f3digo dos clases con el mismo nombre? En ocasiones podr\u00eda ocurrir que se quisiera utilizar la clase Date de ambos paquetes. Cuando esto pasa, una opci\u00f3n ser\u00eda importar \u00fanicamente una de las clases y, cuando se quiera utilizar la otra, llamarla haciendo uso de su nombre plenamente cualificado (es decir, nombre de paquete, punto, nombre de la clase). Por ejemplo: import java.util.Date; public class Conflicts { Date date; //Usa la clase java.util.Date java.sql.Date sqlDate; //Usa la clase java.sql.Date } 3.3.4. Crear un nuevo paquete Hasta ahora, parte del c\u00f3digo que se ha escrito en el cap\u00edtulo se ha encontrado en el paquete por defecto default package. Este es un paquete especial que carece de nombre y que es mejor no utilizar. En la vida real, ser\u00e1 necesario nombrar los paquetes donde se encuentran las clases para evitar conflictos de nombrado y para permitir la reutilizaci\u00f3n de c\u00f3digo. Ahora, se quiere crear un nuevo paquete. La estructura de directorios en un ordenador normal est\u00e1 relacionado con la estructura de paquetes en Java. Se debe tener en cuenta, por ejemplo, la existencia de las siguientes clases: C:\\temp\\packagea\\ClassA.java package packagea; public class ClassA { } C: \\ temp \\ packageb \\ ClassB.java package packageb; import packagea.ClassA; public class ClassB { public static void main(String[] args) { ClassA a; System.out.println(\"Got it\"); } } Cuando se ejecuta un programa Java, Java sabe \u201cd\u00f3nde buscar\u201d los paquetes necesarios. En este caso, ejecutando el programa en el directorio C:\\temp todo funcionar\u00eda correctamente ya que ambos paquetes: packagea y packageb est\u00e1n en en C:\\temp. 3.3.5. Compilar c\u00f3digo con packages : Es posible, y de hecho mucho m\u00e1s c\u00f3modo, utilizar un IDE ( Integrated Development Environment ) para programar c\u00f3digo Java, como Eclipse o Netbeans; no obstante, es posible ejecutar un programa Java desde la l\u00ednea de comandos y es importante saber c\u00f3mo hacerlo. Se comienza por crear ambas clases y situarse en el directorio C:\\temp: Windows Crear los archivos: C: \\ temp \\ packagea \\ ClassA.java C: \\ temp \\ packageb \\ ClassB.java Ir a C: \\ temp cd C: \\ temp Mac OS/Linux Crear los archivos: /tmp/packagea/ClassA.java /tmp/packageb/ClassB.java Escribir el comando cd /tmp A continuaci\u00f3n es necesario compilar ambos archivos, por lo que hay que escribir lo siguiente en la l\u00ednea de comandos: javac packagea/ClassA.java packageb/ClassB.java En caso de que el comando no funcione, se mostrar\u00e1 por pantalla un mensaje de error. En estos casos es recomendable revisar los archivos con cuidado para detectar alg\u00fan posible error de sintaxis. En caso de que el comando funcione correctamente, se crear\u00e1n dos nuevos archivos: packagea/ClassA.class y packageb/ClassB.class . Por \u00faltimo, quedar\u00eda ejecutar el programa. Para ello habr\u00eda que poner lo siguiente en la l\u00ednea de comandos: java packageb.ClassB Si todo funciona correctamente, la frase \u201c Got it \u201d se mostrar\u00e1 en la consola. Es importante percatarse de que a la hora de ejecutar un programa se escribe \u00fanicamente ClassB , no ClassB.class. En Java no se escribe la extensi\u00f3n cuando se ejecuta un programa. 3.3.6. Ruta de las clases y JARs Tambi\u00e9n es posible especificar la ubicaci\u00f3n de otros archivos, expl\u00edcitamente, utilizando rutas. Esta t\u00e9cnica es muy \u00fatil cuando los archivos de las clases est\u00e1n situados en otra parte que no sea el directorio actual o en archivos JAR. Un archivo JAR es como un archivo ZIP que \u00fanicamente contiene clases Java. A continuaci\u00f3n se ver\u00e1n unos ejemplos: En Windows java - cp \".;C: \\ temp \\ someOtherLocation;c: \\ temp \\ myJar.jar\" myPackage.MyClass En MAC OS/Linux java - cp \".:/tmp/someOtherLocation:/tmp/myJar.jar\" myPackage.MyClass El punto inicial indica que se quiere incluir el directorio actual en la ruta de la clase. El resto del comando incluir\u00e1 tambi\u00e9n las clases (o paquetes) en someOtherLocation y en myJar.jar . Windows utiliza el car\u00e1cter punto y coma para separar las partes de la ruta, y MAC OS y Linux utiliza el car\u00e1cter dos puntos. Tambi\u00e9n es posible utilizar la wildcard (*) para hacer referencia a todos los JARs de un directorio. Como por ejemplo: java -cp \"C:\\temp\\directoryWithJars\\*\" myPackage.MyClass Este comando a\u00f1adir\u00e1 todos los JARs que se encuentren en el directorio directoryWithJars a la ruta de la clase. No obstante, no incluir\u00e1 los JARs que se encuentren en los subdirectorios de directoryWithJars. 3.4. Crear objetos Los objetos son una parte fundamental de un programa Java. Un objeto es una instancia de una clase. En las siguientes secciones, se profundizar\u00e1 acerca de los constructores, las propiedades y c\u00f3mo \u00e9stas han de ser inicializadas correctamente. 3.4.1. Constructores Para crear una instancia de una clase, siempre se utilizar\u00e1 la palabra reservada new. Por ejemplo: Random r = new Random(); En primer lugar se declara la variable declarando el tipo de dato que tendr\u00e1 (en este caso Random ) y su nombre (r). Esto permitir\u00e1 a Java reservar en memoria una referencia al objeto. Es al escribir new Random() cuando realmente el objeto es creado. Random() parece un m\u00e9todo, ya que est\u00e1 seguido de par\u00e9ntesis. Este tipo de m\u00e9todos son llamados constructores, y son los encargados de crear nuevos objetos. A continuaci\u00f3n, se ver\u00e1 un ejemplo de c\u00f3mo se define un m\u00e9todo constructor: public class Chick { public Chick() { System.out.println(\"in constructor\"); } } Cabe destacar un par de detalles del siguiente c\u00f3digo: en primer lugar, el nombre del constructor es el mismo que el nombre de la clase, y en segundo lugar, no hay return . El m\u00e9todo public void Chick() { } NO ser\u00eda un constructor. Es necesario prestar especial atenci\u00f3n a estos detalles. En caso de ver un m\u00e9todo que comience por may\u00fascula pero tenga tipo de return (aunque este sea void ), nunca ser\u00e1 un constructor. Se tratar\u00e1 de un m\u00e9todo normal que no ser\u00e1 ejecutado cuando se escriba new Chick() . El prop\u00f3sito de un constructor es inicializar las propiedades del objeto (aunque se pueda escribir dentro de \u00e9l lo que se desee). Otra forma de inicializar propiedades es hacerlo directamente en la l\u00ednea de c\u00f3digo donde estas son declaradas. En el siguiente ejemplo se pueden observar ambos casos: public class Chicken { int numEggs = 0;// Inicializada directamente String name; public Chicken() { name = \"Duke\";// Inicializada en elconstructor } } Muchas clases no precisan de un constructor expl\u00edcito, por lo que el compilador las provee de un constructor por defecto que no hace nada (es decir, su \u00fanica finalidad es permitir crear objetos, pero no tiene c\u00f3digo alguno en su interior). 3.4.2. Leer y modificar las propiedades de los objetos Es posible leer y modificar las propiedades de un objeto a partir de s\u00ed mismo, por ejemplo: public class Swan { int numberEggs;// variable de instancia o propiedad de la clase Swan public static void main(String[] args) { Swan mother = new Swan(); mother.numberEggs = 1; // modifica la propiedad System.out.println(mother.numberEggs); // lee la propiedad } } En este caso, la propiedad numberEggs es obtenida directamente cuando es imprimida por consola. En el m\u00e9todo main , la variable numberEggs es modificada escribiendo en ella el valor 1. M\u00e1s adelante se ver\u00e1 la forma de prevenir que cualquiera pueda modificar las propiedades de un objeto directamente, para que, por ejemplo, no se pueda poner un n\u00famero de huevos negativo. Tambi\u00e9n es posible leer y escribir propiedades directamente al declararlas: 1: public class Name { 2: String first = \"Theodore\"; 3: String last = \"Moose\"; 4: String full = first + last; 5: } Las l\u00edneas 2 y 3 modifican las propiedades first y last , respectivamente, mientras que en la l\u00ednea 4 las propiedades first y last son le\u00eddas y, despu\u00e9s, se modifica la propiedad full con el valor de la concatenaci\u00f3n de ambas. 3.4.3. Bloques inicializadores de instancias A lo largo de los cap\u00edtulos anteriores se han visto diferentes m\u00e9todos, todos ellos conteniendo los caracteres {}. El c\u00f3digo entre llaves \u201c{}\u201d es llamado bloque de c\u00f3digo. La mayor\u00eda de las veces hay bloques de c\u00f3digo dentro de m\u00e9todos, que se ejecutan cuando el m\u00e9todo es llamado. Otras veces, los bloques de c\u00f3digo pueden aparecer fuera de un m\u00e9todo. Estos bloques son llamados inicializadores de instancia. \u00bfCu\u00e1ntos bloques hay en el siguiente c\u00f3digo? \u00bfCu\u00e1ntos de estos bloques son bloques inicializadores de instancias? 3: public static void main(String[] args) { 4: { System.out.println(\"Feathers\"); } 5: } 6: { System.out.println(\"Snowy\"); } Hay tres bloques y un inicializador de instancia. Contar el n\u00famero de bloques es sencillo: \u00fanicamente hay que contar los pares de llaves que hay en el c\u00f3digo. Si no hay el mismo n\u00famero de \u201c{\u201c que de \u201c}\u201d el c\u00f3digo no compilar\u00e1. Para poder identificar un bloque inicializador de instancia es necesario tener en cuenta que estos nunca podr\u00e1n aparecer dentro de un m\u00e9todo, por lo que el inicializador de instancia del c\u00f3digo anterior es el bloque que aparece en la l\u00ednea 6. 3.4.4. Orden de inicializaci\u00f3n Cuando se escribe c\u00f3digo que inicializa propiedades en diferentes partes del programa, es necesario tener en cuenta el orden de inicializaci\u00f3n de las mismas. Por el momento, se tendr\u00e1 en cuenta las siguientes reglas a la hora de inicializar propiedades: Tanto las propiedades como los bloques de iniciaci\u00f3n de instancias son ejecutados en el orden en el que aparezcan en el c\u00f3digo. El constructor se ejecuta despu\u00e9s de que las propiedades y los bloques de inicializaci\u00f3n de instancias se hayan ejecutado. A continuaci\u00f3n, se ver\u00e1 el siguiente ejemplo: 1: public class Chick { 2: private String name = \"Fluffy\"; 3: { System.out.println(\"setting field\"); } 4: public Chick() { 5: name = \"Tiny\"; 6: System.out.println(\"setting constructor\"); 7: } 8: public static void main(String[] args) { 9: Chick chick = new Chick(); 10: S ystem.out.println(chick.name); } } Que imprimir\u00e1 por pantalla lo siguiente: setting field setting constructor Tiny En primer lugar, el programa comienza su ejecuci\u00f3n en el m\u00e9todo main() (como ocurre en cualquier programa Java). En la l\u00ednea 9, se llama al constructor de la clase Chick, y Java crea un nuevo objeto de la misma. Primero la propiedad name es inicializada con el valor \u201cFluffy\u201d en la l\u00ednea 2. Despu\u00e9s se ejecuta System.out.println(\"setting field\"); en la l\u00ednea 3. Una vez las propiedades y los bloques inicializadores de instancias se han ejecutado, Java vuelve al constructor. La l\u00ednea 5 cambia el valor de name a \u201cTiny\u201d y la l\u00ednea 6 vuelve a imprimir por pantalla mediante la sentencia System.out.println(\"setting constructor\"); En este punto, el constructor ha terminado de ejecutarse, y se retorna al m\u00e9todo main , concretamente, a la l\u00ednea 10. El orden del c\u00f3digo es importante. No se puede hacer referencia a una variable antes de que esta haya sido declarada. { System.out.println(name); } // NO COMPILA private String name = \"Fluffy\"; Otro ejemplo, \u00bfqu\u00e9 imprimir\u00e1 por pantalla el siguiente c\u00f3digo? public class Egg { public Egg() { number = 5; } public static void main(String[] args) { Egg egg = new Egg(); System.out.println(egg.number); } private int number = 3; { number = 4;} } La respuesta correcta ser\u00e1 \u201c5\u201d. Las propiedades y los bloques de c\u00f3digo inicializadores de instancia se ejecutar\u00e1n en primer lugar, cambiando number a 3 y luego a 4. Posteriormente, el constructor modifica number a 5, y esto es lo que se imprime por pantalla. 3.5. Diferencia entre referencias a objetos y primitivas de datos Las aplicaciones Java contienen dos grupos de tipos de dato: variables de referencia y primitivas de datos. En este apartado se expondr\u00e1n las diferencias entre ambos grupos. 3.5.1. Primitivas de datos Java posee ocho tipos de dato incorporados en el propio lenguaje por defecto que se conocen como primitivas de datos. Estos ocho tipos de dato representan los cimientos de cualquier objeto Java, ya que todos los objetos son composiciones m\u00e1s o menos complejas de las primitivas de datos. La siguiente tabla muestra todas las primitivas de datos junto con su tama\u00f1o en bytes y el rango de valores que pueden adoptar. Palabra reservada(keyword) Tipo Ejemplo boolean true o false True byte Valor entero de 8 bits 123 short Valor entero de 16 bits 123 int Valor entero de 32 bits 123 long Valor entero de 64 bits 123 float Valor en coma flotante de 32 bits 123.45f double Valor en coma flotante de 64 bits 123.456 char Valor Unicode de 16 bits \u2018a\u2019 A continuaci\u00f3n se ver\u00e1, detalladamente, la informaci\u00f3n de la tabla anterior: float y double son utilizados para representar valores decimales. Los datos float necesitan poner la letra f seguido del n\u00famero para que Java los identifique como float. byte, short, int y long se utilizan para representar n\u00fameros enteros. Cada tipo num\u00e9rico utiliza dos veces m\u00e1s bits que el tipo num\u00e9rico m\u00e1s peque\u00f1o anterior a \u00e9l; por ejemplo, short utiliza el doble de bits que byte. Es necesario tener presente que un byte puede contener valores de -128 a 127, \u00bfPor qu\u00e9? Un byte son 8 bits. Un bit puede tener dos posibles valores. 2^8 es 256. Ya que el 0 tambi\u00e9n ha de ser incluido en el rango de n\u00fameros a abarcar, Java lo considera en la parte positiva, por lo que 256/2=128 (de -128 a 127). El n\u00famero de bits utilizado por Java cuando necesita reservar memoria para una primitiva de datos ser\u00e1 el n\u00famero de bits que ocupe cada tipo de dato. Por ejemplo, Java reservar\u00e1 32 bits de memoria cuando se escriba lo siguiente: int num; Continuando con las primitivas de datos num\u00e9ricas, cabe destacar que cuando un n\u00famero est\u00e1 presente en el c\u00f3digo, es llamado \u201cliteral\u201d. Por defecto, Java asume que el valor definido es del tipo int. En el ejemplo siguiente, el valor que se muestra es demasiado grande para ser de tipo int. int max = 3123456789; //NO COMPILA Java mostrar\u00e1 que ese n\u00famero est\u00e1 fuera de rango, lo cual es cierto teniendo en cuenta que pretende interpretarlo como un n\u00famero de tipo int. No obstante, no se pretende que sea el n\u00famero de tipo int. La soluci\u00f3n es a\u00f1adir la letra L al n\u00famero. long max = 3123456789L; //Ahora es cuando Java comprende que el n\u00famero es un long Otra manera de escribir n\u00fameros es cambar la base. Cuando se aprende a contar, se estudian los d\u00edgitos del 0 al 9 (n\u00fameros en base 10 o sistema decimal, ya que hay 10 n\u00fameros). Java permite escribir n\u00fameros de otras maneras: Octal (d\u00edgitos del 0-7). Para expresar un n\u00famero en octal, este ha de ir precedido por un 0. Por ejemplo: 017 Hexadecimal (d\u00edgitos del 0-9, letras de la A-F). Para expresar un n\u00famero en hexadecimal, este ha de ir precedido por el prefijo 0x o 0X. Por ejemplo: 0xFF. Binario (d\u00edgitos 0-1). Para expresar un n\u00famero en binario, este ha de ir precedido por el prefijo 0b o 0B. Por ejemplo: 0b10. Lo \u00faltimo a tener en cuenta sobre literales num\u00e9ricos es una caracter\u00edstica a\u00f1adida en Java 7, y es que es posible a\u00f1adir barras bajas a los n\u00fameros para facilitar su lectura: int million1 = 1000000; int million2 = 1_000_000; Las barras bajas se podr\u00e1n a\u00f1adir en cualquier parte del literal num\u00e9rico excepto: Al principio del literal. Al final del literal. Antes de un punto decimal. Despu\u00e9s de un punto decimal. Por ejemplo: double notAtStart = _1000.00; //NO COMPILA double notAtEnd = 1000.00_; //NO COMPILA double notByDecimal = 1000_.00; //NO COMPILA double goodOne = 1_00_0.0_0; //COMPILA 3.5.2. Tipos referencia Un tipo referencia es un objeto (un objeto es una instancia de una clase). Al contrario que ocurre con las primitivas de datos, que guardan sus valores directamente en la memoria reservada por la variable, los tipos referencia no guardan los valores de los objetos en la direcci\u00f3n de memoria reservada cuando las variables son declaradas. En lugar de eso, la referencia \u201capunta\u201d al objeto asignado a la variable guardando la direcci\u00f3n de memoria donde este se encuentra, concepto tambi\u00e9n conocido como puntero. Al contrario que en otros lenguajes, Java no permite conocer cu\u00e1l es la direcci\u00f3n f\u00edsica en memoria donde est\u00e1n guardados sus objetos. La forma de declarar e inicializar tipos referencia es la siguiente, se consideran declaradas dos referencias, una de tipo java.util.Date , y otra de tipo String : java.util.Date hoy; String saludo; La variable hoy es una referencia de tipo Date, y \u00fanicamente puede \u201capuntar\u201d a un objeto de tipo Date. La variable saludo es una variable que \u00fanicamente puede \u201capuntar\u201d a un objeto de tipo String. Es posible asignar un valor a una referencia de las siguientes formas: A una referencia se le puede asignar un objeto de su mismo tipo de dato. A una referencia se le puede asignar un nuevo objeto utilizando para ello la palabra reservada new . Por ejemplo, el siguiente c\u00f3digo muestra dos asignaciones a nuevos objetos: hoy = new java.util.Date(); saludo = \u201c\u00a1Buenos d\u00edas!\u201d; La referencia hoy apunta a un Nuevo objeto de tipo Date en memoria, por lo que a partir de ahora hoy podr\u00e1 ser utilizada para acceder a los m\u00e9todos y atributos de la clase Date. De igual manera, la referencia saludo apunta a un nuevo objeto de tipo String, el cual tiene el valor \u201c\u00a1Buenos d\u00edas!\u201d. Los objetos String y Date \u00fanicamente pueden ser accedidos a trav\u00e9s de sus referencias. La siguiente figura muestra un ejemplo de c\u00f3mo las variables referencia se representan en memoria: 3.5.3. Diferencias clave Existen algunas diferencias muy importantes a tener en cuenta entre primitivas de datos y variables referencia. En primer lugar, las variables referencia pueden tener el valor null , lo que quiere decir que no tienen ning\u00fan objeto asignado. Las primitivas de datos mostrar\u00e1n un error de compilaci\u00f3n si se les intenta asignar el valor null. En el siguiente ejemplo, valor no puede ser null , ya que es de tipo int. int valor = null; //NO COMPILA String s = null; En segundo lugar, los tipos referencia pueden ser utilizados para llamar m\u00e9todos siempre y cuando no sean null. Las primitivas de datos no tienen m\u00e9todos. En el siguiente ejemplo, es posible llamar al m\u00e9todo length() desde la variable texto porque texto es una variable de referencia. Se puede saber que length es un m\u00e9todo ya que utiliza (). En la siguiente l\u00ednea, cuando se intenta llamar al m\u00e9todo length() sobre longitud , que es de tipo int (primitiva de datos), aparecer\u00e1 un error de compilaci\u00f3n, ya que las primitivas de tipo int no tienen una longitud definida. String texto = \u201chola\u201d; int longitud = texto.length(); int mal = longitud.length(); //NO COMPILA Por \u00faltimo cabe destacar que las primitivas de datos est\u00e1n escritas en el lenguaje comenzando con letra min\u00fasucla, mientras que las clases, siempre comienzan con letra may\u00fascula. 3.6. Declarando e inicializando variables Hasta ahora se han visto ya numerosas variables. Una variable es, en realidad, un espacio de memoria donde se guardan datos. Cuando se declara una variable, es necesario especificar tanto su nombre como su tipo de dato. Por ejemplo, el siguiente c\u00f3digo declara dos variables. Una es llamada zooName y es de tipo String. La otra es llamada numberAnimals y es de tipo int. String zooName; int numberAnimals; Ahora que se han declarados las variables, es posible asignarles valores; es decir, es posible inicializar las variables. Para inicializar una variable, es necesario escribir el nombre de la variable seguido del car\u00e1cter =, seguido del valor a inicializar: zooName = \"El mejor Zoo\"; numberAnimals = 100; Tambi\u00e9n es posible declarar e inicializar las variables en la misma l\u00ednea: String zooName = \" El mejor Zoo \"; int numberAnimals = 100; 3.6.1. Declarar m\u00faltiples variables Tambi\u00e9n es posible declarar e inicializar varias variables en la misma l\u00ednea. Por ejemplo, \u00bfCu\u00e1ntas variables se han declarado e inicializado en las siguientes dos l\u00edneas? String s1, s2; String s3 = \"yes\", s4 = \"no\"; La respuesta es cuatro variables de tipo String : s1, s2, s3 y s4. Es posible declarar tantas variables como se desee seguidas siempre y cuando estas pertenezcan al mismo tipo de dato. Tambi\u00e9n es posible inicializar estas variables en la misma l\u00ednea (todas, varias, o lo que se desee). En el ejemplo anterior, las variables s3 y s4 est\u00e1n inicializadas, pero las variables s1 y s2 est\u00e1n \u00fanicamente declaradas. Un ejemplo algo m\u00e1s complejo: int i1, i2, i3 = 0; En este caso se han declarado tres variables: i1 , i2 e i3 , pero \u00fanicamente i3 ha sido inicializada con el valor 0. Es necesario tener en cuenta que, por cada \u201c , \u201d, hay una variable diferente cuya inicializaci\u00f3n es independiente a las dem\u00e1s. El c\u00f3digo siguiente, por ejemplo, no compilar\u00eda, ya que no es posible declarar en la misma sentencia variables de tipos de dato diferente: int num, String value; // NO COMPILA Por \u00faltimo, se ver\u00e1 el siguiente ejemplo, \u00bfCu\u00e1les de las siguientes l\u00edneas ser\u00edan v\u00e1lidas y cu\u00e1les no compilar\u00edan? 1: boolean b1, b2; 2: String s1 = \"1\", s2; 3: double d1, double d2; 4: int i1; int i2; 5: int i3; i4; La l\u00ednea 1 es correcta. Declara dos variables de tipo boolean sin inicializar. La l\u00ednea 2 tambi\u00e9n es correcta, ya que declara dos variables de tipo String e inicializa la primera de ellas con el valor \u201c1\u201d. La tercera l\u00ednea no es correcta. Java no permite declarar dos variables de diferente tipo en la misma sentencia, y, a pesar de que en este caso ambas variables ser\u00edan de tipo double , si se quieren declarar dos variables de mismo tipo en la misma l\u00ednea, estas deben compartir la misma declaraci\u00f3n del tipo de dato, y no repetirlo. La l\u00ednea 4 tambi\u00e9n es correcta, y es que, aunque pueda parecer un caso igual al anterior, no es as\u00ed, ya que la l\u00ednea cuatro muestra dos sentencias en la misma l\u00ednea (separadas por \u201c;\u201d). La l\u00ednea 5 no es correcta, ya que, de nuevo, presenta dos sentencias, y la segunda de ella no tiene el tipo de dato necesario para declarar la variable i4 . Esto ser\u00eda como escribir: int i3; i4; //NO COMPILA 3.6.2. Identificadores Probablemente no sorprenda que Java tenga reglas precisas sobre nombres de identificadores. Afortunadamente, las mismas reglas para los identificadores se aplican a cualquier cosa que puedas nombrar, incluyendo variables, m\u00e9todos, clases y campos. S\u00f3lo hay tres reglas a recordar para los identificadores legales: El nombre debe comenzar con una letra o el s\u00edmbolo $ o _. Los caracteres posteriores tambi\u00e9n pueden ser n\u00fameros. No se puede usar el mismo nombre que una palabra reservada de Java. Una palabra reservada es una palabra clave que Java ha reservado para que no se le permita utilizarla. Recordar que Java distingue entre may\u00fasculas y min\u00fasculas, por lo que se puede utilizar versiones de las palabras clave que s\u00f3lo difieren en may\u00fasculas y min\u00fasculas, aunque es aconsejable no hacerlo. No hay que preocuparse, no se necesitar\u00e1 memorizar la lista completa de palabras reservadas. La siguiente lista es una lista de todas las palabras reservadas en Java. const y goto no se utilizan realmente en Java. Est\u00e1n reservados para que las personas que vienen de otros idiomas no los usen por accidente y en teor\u00eda, en caso de que Java quiera usarlos alg\u00fan d\u00eda. Lista de palabras resevadas de Java abstract assert boolean break byte case catch char class const continue default do double else enum extends enum extends false float for goto* if implements import instanceof int interface long native new null package private protected public return short static strictfp super switch synchronized this throw throws transient true try void volatile while Los siguientes ejemplos son legales: okidentifier $OK2Identifier _alsoOK1d3ntifi3r __SStillOkbutKnotsonice$ Estos ejemplos no son legales: 3DPointClass // Los identificadores no pueden comenzar por un n\u00famero hollywood@vine // @ no es una letra, d\u00edgito, $ o _ *$coffee // * no es una letra, d\u00edgito, $ o _ public // public es una palabra reservada Aunque se puede hacer locuras con nombres de identificaci\u00f3n, no se deber\u00eda. Java tiene convenciones para que el c\u00f3digo sea legible y consistente. Esta consistencia incluye CamelCase. En CamelCase, cada palabra comienza con una letra may\u00fascula. Esto facilita la lectura de nombres de variables de m\u00e1s de una palabra. \u00bfQu\u00e9 ser\u00eda m\u00e1s legible: thisismyclass name o ThisIsMyClass name? Cuando aparezca un identificador no est\u00e1ndar, hay que asegurarse de verificar si es legal. Identificadores en el mundo real La mayor\u00eda de los desarrolladores siguen estas convenciones para identificar nombres: Los nombres de m\u00e9todos y variables comienzan con una letra min\u00fascula seguida de CamelCase. Los nombres de las clases comienzan con una letra may\u00fascula seguida de CamelCase. No se deben usar identificadores con $. El compilador usa este s\u00edmbolo para algunos archivos. Adem\u00e1s, las letras v\u00e1lidas en Java no son s\u00f3lo caracteres del alfabeto ingl\u00e9s. Java soporta el conjunto de caracteres Unicode, por lo que hay m\u00e1s de 45.000 caracteres que pueden iniciar un identificador Java legal. Unos pocos centenares m\u00e1s son n\u00fameros no \u00e1rabes que pueden aparecer despu\u00e9s del primer car\u00e1cter en un identificador v\u00e1lido. 3.7. Comprensi\u00f3n de la inicializaci\u00f3n por defecto de las variables Antes de poder utilizar una variable, necesita un valor. Algunos tipos de variables obtienen este valor autom\u00e1ticamente y otras requieren que el programador lo especifique. En las siguientes secciones, se ver\u00e1n las diferencias entre los valores predeterminados para las variables locales, de instancia y de clase. 3.7.1. Variables locales Una variable local es una variable definida dentro de un m\u00e9todo. Las variables locales deben ser inicializadas antes de su uso. No tienen un valor por defecto y contienen datos basura hasta que se inicializan. El compilador no le permitir\u00e1 leer un valor sin inicializar. Por ejemplo, el siguiente c\u00f3digo genera un error de compilaci\u00f3n: 4: public int notValid() { 5: int y = 10; 6: int x; 7: int reply = x + y; // DOES NOT COMPILE 8: return reply; 9: } y se inicializa a 10. Sin embargo, debido a que x no se inicializa antes de ser utilizado en la expresi\u00f3n de la l\u00ednea 7, el compilador genera el error de seguimiento: Test.java:5: variable x might not have been initialized int reply = x + y; ^ Hasta que a x no se le asigne un valor, no puede aparecer dentro de una expresi\u00f3n, y el compilador le recordar\u00e1 esta regla. El compilador sabe que su c\u00f3digo tiene el control de lo que sucede dentro del m\u00e9todo y puede esperar que inicialice los valores. El compilador es lo suficientemente inteligente como para reconocer variables que han sido inicializadas despu\u00e9s de su declaraci\u00f3n, pero antes de ser usadas. Aqu\u00ed hay un ejemplo: public int valid() { int y = 10; int x; // x is declared here x = 3; // and initialized here int reply = x + y; return reply; } El compilador tambi\u00e9n es lo suficientemente inteligente como para reconocer inicializaciones m\u00e1s complejas. En este ejemplo, hay dos ramas de c\u00f3digo y answer se inicializa en ambas. onlyOneBranch s\u00f3lo se inicializa si check es verdadero. El compilador sabe que existe la posibilidad de que check sea falso y de que por lo tanto onlyOneBranch no se inicialice nunca, por lo que en el c\u00f3digo hay un error de compilaci\u00f3n. Se aprender\u00e1 m\u00e1s sobre la declaraci\u00f3n if en el pr\u00f3ximo cap\u00edtulo. public void findAnswer(boolean check) { int answer; int onlyOneBranch; if(check) { onlyOneBranch = 1; answer = 1; } else { answer = 2; } System.out.println(answer); 3.7.2. Variables de clase e instancia Las variables que no son variables locales se conocen como variables de instancia o variables de clase. Las variables de instancia tambi\u00e9n se denominan fields. Las variables de clase se comparten entre varios objetos. Se puede decir que una variable es una variable de clase porque tiene la palabra clave static delante de ella. Se encontrar\u00e1 m\u00e1s informaci\u00f3n al respecto en el cap\u00edtulo 4. Por ahora, s\u00f3lo se debe saber que una variable es una variable de clase si tiene la palabra clave static en su declaraci\u00f3n. Las variables de instancia y clase no requieren ser inicializadas. Tipo de variable Valor por defecto de inicializaci\u00f3n boolean false byte, short, int, long 0 (en la longitud de bits del tipo) float, double 0.0 (en la longitud de bits del tipo) char \u2018\\u0000\u2019 (NUL) Todas las referencias a objetos Null 3.8. Entendiendo el \u00e1mbito de las variables Se ha aprendido que las variables locales se declaran dentro de un m\u00e9todo. \u00bfCu\u00e1ntas variables locales se ven en este ejemplo? public void eat(int piecesOfCheese) { int bitesOfCheese = 1; } Hay dos variables locales en este m\u00e9todo. bitesOfCheese se declara dentro del m\u00e9todo. piecesOfCheese se llama par\u00e1metro de m\u00e9todo. Tambi\u00e9n es local al m\u00e9todo. Se dice que ambas variables tienen un alcance local al m\u00e9todo. Esto significa que no se pueden utilizar fuera del m\u00e9todo. Las variables locales nunca pueden tener un alcance mayor que el m\u00e9todo definido. Sin embargo, pueden tener un alcance menor. Ejemplo: 3: public void eatIfHungry(boolean hungry) { 4: if (hungry) { 5: int bitesOfCheese = 1; 6: } // bitesOfCheese goes out of scope here 7: System.out.println(bitesOfCheese);// NO COMPILA 8: } System.out.println(onlyOneBranch); // DOES NOT COMPILE } hungry tiene un alcance de todo el m\u00e9todo. bitesOfCheese tiene un alcance m\u00e1s peque\u00f1o. S\u00f3lo est\u00e1 disponible para su uso en la sentencia if porque se declara dentro de ella. Cuando se vea un juego de llaves ({ }) en el c\u00f3digo, significa que se ha introducido un nuevo bloque de c\u00f3digo. Cada bloque de c\u00f3digo tiene su propio alcance. Cuando hay bloques m\u00faltiples, se emparejan de dentro hacia fuera. En este caso, el bloque de sentencia if comienza en la l\u00ednea 4 y termina en la l\u00ednea 6. El bloque del m\u00e9todo comienza en la l\u00ednea 3 y termina en la l\u00ednea 8. Dado que bitesOfCheese se declara en tal bloque, el \u00e1mbito de aplicaci\u00f3n se limita a dicho bloque. Cuando el compilador llega a la l\u00ednea 7, muestra que no sabe nada sobre bitesOfCheese y da un error: bitesOfCheese cannot be resolved to a variable Recordar que los bloques pueden contener otros bloques. Estos bloques m\u00e1s peque\u00f1os contenidos pueden referenciar variables definidas en los bloques de mayor tama\u00f1o, pero no viceversa. Por ejemplo: 16: public void eatIfHungry(boolean hungry) { 17: if (hungry) { 18: int bitesOfCheese = 1; 19: { 20: boolean teenyBit = true; 21: System.out.println(bitesOfCheese); 22: } 23: } 24: System.out.println(teenyBit); // NO COMPILA 25: } La variable definida en la l\u00ednea 18 est\u00e1 en alcance hasta que el bloque termina en la l\u00ednea 23. Usarlo en el bloque m\u00e1s peque\u00f1o de las l\u00edneas 19 a 22 es seguro. La variable definida en la l\u00ednea 20 queda fuera del alcance en la l\u00ednea 22. No est\u00e1 permitido su uso en la l\u00ednea 24. No hay que preocuparse si a\u00fan no se est\u00e1 familiarizado con las declaraciones o los bucles. No importa lo que haga el c\u00f3digo, ya que se est\u00e1 hablando del alcance. A continuaci\u00f3n, se intentar\u00e1 determinar, en qu\u00e9 l\u00ednea, cada una de las variables locales entra y sale del alcance: 11: public void eatMore(boolean hungry, int amountOfFood) { 12: int roomInBelly = 5; 13: if (hungry) { 14: boolean timeToEat = true; 15: while (amountOfFood > 0) { 16: int amountEaten = 2; 17: roomInBelly = roomInBelly - amountEaten; 18: amountOfFood = amountOfFood - amountEaten; 19: } 20: } 21: System.out.println(amountOfFood); 22: } El primer paso para determinar el alcance es identificar los bloques de c\u00f3digo. En este caso, hay tres bloques. Se puede decir esto porque hay tres juegos de llaves. Partiendo del conjunto m\u00e1s interno, se puede ver d\u00f3nde comienza y termina el bloque del bucle while. Se repetir\u00e1 esto mientras se sale, para el bloque de sentencia if y el bloque de m\u00e9todo. La Tabla 1.3 muestra los n\u00fameros de l\u00ednea que cada bloque comienza y termina. Bloque Primera l\u00ednea del bloque Ultima l\u00ednea del bloque while 15 19 if 13 20 method 11 22 Se necesitar\u00e1 practicar mucho esto. La identificaci\u00f3n de bloques debe ser algo natural. La buena noticia es que hay muchos ejemplos de c\u00f3digos para practicar. Ahora que se sabe d\u00f3nde est\u00e1n los bloques, se puede ver el alcance de cada variable. hungry y amountOfFood son par\u00e1metros de m\u00e9todo, por lo que est\u00e1n disponibles para todo el m\u00e9todo. Esto significa que su \u00e1mbito de aplicaci\u00f3n son las l\u00edneas 11 a 22. roomInBelly entra en el \u00e1mbito de aplicaci\u00f3n de la l\u00ednea 12 porque ah\u00ed es donde se declara. Se mantiene en el alcance para el resto del m\u00e9todo y por lo tanto se sale del alcance en la l\u00ednea 22. timeToEat entra en el alcance en la l\u00ednea 14 donde se declara. Se sale del alcance en la l\u00ednea 20 donde termina el bloque if. amountEaten entra en el \u00e1mbito de aplicaci\u00f3n de la l\u00ednea 16 donde se declara. Se sale del alcance en la l\u00ednea 19 donde termina el bloque de tiempo. Todo eso era para variables locales. Afortunadamente, las reglas para las variables de instancia son m\u00e1s f\u00e1ciles: est\u00e1n disponibles tan pronto como se definen y duran toda la vida \u00fatil del objeto en s\u00ed. La regla para las variables de clase (static) es a\u00fan m\u00e1s f\u00e1cil: entran en alcance cuando se declaran como los otros tipos de variables. Sin embargo, permanecen en el alcance durante toda la vida del programa. A continuaci\u00f3n, se har\u00e1 un ejemplo m\u00e1s para asegurarse de que se tiene control sobre esto. Una vez m\u00e1s, se debe averiguar el tipo de las cuatro variables y cu\u00e1ndo entran y salen del alcance. 1: public class Mouse { 2: static int MAX_LENGTH = 5; 3: int length; 4: public void grow(int inches) { 5: if (length < MAX_LENGTH) { 6: int newSize = length + inches; 7: length = newSize; 8: } 9: } 10:} En esta clase, se tiene una variable de clase (MAX_LENGTH), una variable de instancia (length) y dos variables locales (inches y newSize.) MAX_LENGTH es una variable de clase porque tiene la palabra clave static en su declaraci\u00f3n. MAX_LENGTH entra en el \u00e1mbito de aplicaci\u00f3n de la l\u00ednea 2 donde se declara. Permanece en el alcance hasta que finaliza el programa. Length entra en el \u00e1mbito de la aplicaci\u00f3n en la l\u00ednea 3, donde se declara. Permanece en el alcance mientras el objeto Mouse exista. inches entra en alcance donde se declara en la l\u00ednea 4. Se sale del alcance al final del m\u00e9todo en la l\u00ednea 9. newSize entra en el alcance donde se declara en la l\u00ednea 6. Dado que est\u00e1 definido dentro del bloque de sentencia if, se sale del alcance cuando ese bloque termina en la l\u00ednea 8. \u00bfSe ha resuelto todo? Ahora, se revisar\u00e1n las reglas sobre el alcance: Variables locales: en el \u00e1mbito de aplicaci\u00f3n desde la declaraci\u00f3n hasta el final del bloque Variables de instancia: en el \u00e1mbito de aplicaci\u00f3n de la declaraci\u00f3n hasta que se recoge la basura del objeto. Variables de clase: en el \u00e1mbito de aplicaci\u00f3n de la declaraci\u00f3n hasta que finalice el programa. 3.9. Ordenando elementos en una clase Ahora que se ha visto las partes m\u00e1s comunes de una clase, se echar\u00e1 un vistazo al orden correcto para escribirlas en un archivo. Los comentarios pueden ir en cualquier parte del c\u00f3digo. M\u00e1s all\u00e1 de eso, es necesario memorizar las reglas en la tabla siguiente: Elemento Ejemplo \u00bfNecesario? \u00bfD\u00f3nde va? Declaraci\u00f3n de paquete package abc; No Primera l\u00ednea del archivo Sentencias de importaci\u00f3n import java.util*; No Inmediatamente despu\u00e9s del paquete Declaraci\u00f3n de clase public class C Si Inmediatamente despu\u00e9s de la importaci\u00f3n Declaraci\u00f3n de campos int value; No Cualquier lugar dentro de la clase Declaraci\u00f3n de m\u00e9todos void method() No Cualquier lugar dentro de la clase Se ver\u00e1n algunos ejemplos para ayudar a recordar esto. El primer ejemplo contiene uno de cada elemento: package structure; // package must be first non-comment import java.util.*; // import must come after package public class Meerkat { // then comes the class double weight; // fields and methods can go in either order public double getWeight() { return weight; } double height; // another field \u2013 they don't need to be together } Hasta ahora todo bien. Este es un patr\u00f3n com\u00fan que se debe conocer. V\u00e9ase otro ejemplo: /* header */ package structure; // class Meerkat public class Meerkat { } Sigue siendo bueno. Se puede poner comentarios en cualquier lugar, y las importaciones son opcionales. En el siguiente ejemplo, hay un problema: import java.util.*; package structure; // DOES NOT COMPILE String name; // DOES NOT COMPILE public class Meerkat { } Hay dos problemas aqu\u00ed. Una es que el paquete y las declaraciones de importaci\u00f3n se anulan. Aunque ambos son opcionales, el paquete debe llegar antes de la importaci\u00f3n si est\u00e1 presente. La otra cuesti\u00f3n es que un campo intenta la declaraci\u00f3n fuera de una clase. Esto no est\u00e1 permitido. Los campos y m\u00e9todos deben estar dentro de una clase. \u00bfSe tiene todo? Un consejo, se debe recordar el acr\u00f3nimo PIC (picture): package, import y class. Los campos y m\u00e9todos son m\u00e1s f\u00e1ciles de recordar porque simplemente tienen que estar dentro de una clase. Se pueden definir varias clases en el mismo archivo, pero s\u00f3lo una de ellas puede ser p\u00fablica. La clase p\u00fablica coincide con el nombre del archivo. Por ejemplo, estas dos clases deben estar en un archivo llamado Meerkat. java: 1: public class Meerkat { } 2: class Paw { } En un archivo tambi\u00e9n se permite que ninguna de las clases sea p\u00fablica. Mientras no haya m\u00e1s de una clase p\u00fablica en un archivo, est\u00e1 bien. 3.10. Destruyendo Objetos Ahora que se ha trabajado con objetos, es hora de deshacerse de ellos. Por suerte, Java se encarga autom\u00e1ticamente de esto, proporcionando una herramienta llamada Garbage Collector (\u201crecolector de basura\u201d), el cual busca autom\u00e1ticamente objetos que ya no est\u00e1n en uso. Todos los objetos Java se almacenan en la memoria del programa, siendo el heap un gran grupo de memoria no utilizada asignada a una aplicaci\u00f3n Java. El heap puede ser bastante grande dependiendo del entorno, pero siempre tiene un l\u00edmite de tama\u00f1o. Si el programa sigue instanciando objetos y dej\u00e1ndolos en el heap , llegar\u00e1 un momento en el que se quedar\u00e1 sin memoria. En las siguientes secciones se ver\u00e1 la Garbage Collection o \"recolecci\u00f3n de basura\" y el m\u00e9todo finalize(). 3.10.1. Garbage Collection El concepto Garbage Collection en Java hace referencia al proceso de liberar autom\u00e1ticamente la memoria en el heap borrando objetos que ya no son accesibles en un programa; es decir, objetos que han quedado desreferenciados. Existen muchos algoritmos diferentes para la Garbage Collection, pero no es necesario conocer ninguno de ellos. S\u00ed que es necesario; no obstante, familiarizarse con el m\u00e9todo System.gc(), la cual ejecuta el Garbage Collector, recogiendo aquellos objetos ya no referenciados en el c\u00f3digo. El m\u00e9todo System.gc() no siempre puede ejecutar el Garbage Collector, sino que realmente, a pesar de que s\u00ed se le ordena a Java que lleve a cabo esta acci\u00f3n, esta podr\u00eda ser ignorada. La parte m\u00e1s interesante de la Garbage Collection es cuando la memoria perteneciente a un objeto ya desreferenciado es recuperada. Java es capaz de detectar cu\u00e1ndo un objeto ya no es utilizado en ninguna parte del c\u00f3digo. Esto puede darse en dos situaciones: El objeto ya no tiene referencias que lo apunten. Todas las referencias al objeto est\u00e1n fuera de \u00e1mbito. S Objetos vs Referencias No debe confundirse una referencia con el objeto al que se refiere; son dos entidades diferentes. La referencia es una variable que tiene un nombre y se puede utilizar para acceder al contenido de un objeto. Se puede asignar una referencia a otra referencia, pasarla a un m\u00e9todo o devolverla desde un m\u00e9todo. Todas las referencias son del mismo tama\u00f1o, independientemente de su tipo. Un objeto se deposita en el heap y no tiene nombre. Por lo tanto, no hay manera de acceder a un objeto excepto a trav\u00e9s de una referencia. Los objetos vienen en todas las formas y tama\u00f1os diferentes y consumen cantidades variables de memoria. Un objeto no se puede asignar a otro objeto, ni tampoco se puede pasar un objeto a un m\u00e9todo o devolverlo desde un m\u00e9todo. Es el objeto quien recibe el Garbage Collection, no su referencia. Comprender la diferencia entre una referencia y un objeto ayuda mucho a entender la Garbage Collection, el operador new y muchas otras facetas del lenguaje Java. Observando el siguiente c\u00f3digo se puede ver cu\u00e1ndo un objeto es elegible para ser recolectado por el Garbage Collector: 1: public class Scope { 2: public static void main(String[] args) { 3: String one, two; 4: one = new String(\"a\"); 5: two = new String(\"b\"); 6: one = two; 7: String three = one; 8: one = null; 9: } } A la hora de llevar a cabo una traza del c\u00f3digo es posible cometer errores, por lo que habr\u00e1 que prestar especial atenci\u00f3n. En la l\u00ednea 3 se crean dos variables: one y two. S\u00f3lo las variables, que son referencias que no apuntan todav\u00eda a nada. No hay necesidad de dibujar cajas o flechas que ayuden a comprender el c\u00f3digo, ya que no hay objetos en el heap todav\u00eda. En la l\u00ednea 4 se crea el primer objeto. Se dibujar\u00e1 una caja con la cadena \"a\" dentro y luego una flecha de la palabra one a esa caja. La l\u00ednea 5 es similar. Se dibujar\u00e1 otra caja con la cadena \"b\" en ella esta vez y una flecha desde la palabra two. En este punto, el esquema deber\u00eda verse como la figura siguiente. En la l\u00ednea 6, la variable one cambia a \"b\". Se borrar\u00e1 la flecha de one y se dibujar\u00e1 una nueva flecha de one a \"b\". En la l\u00ednea 7, se tiene una nueva variable, as\u00ed que se escribir\u00e1 la palabra three y se dibujar\u00e1 una flecha de three a \"b\". Existen tres variables que se\u00f1alan a \"b\" en este momento, y ninguna que se\u00f1ale a \"a\". Finalmente habr\u00eda que eliminar la flecha entre one y \"b\", ya que la l\u00ednea 8 establece esta variable como nula. Este seguimiento pretend\u00eda encontrar cu\u00e1ndo los objetos eran elegibles para ser recolectados por el Garbage Collector. En la l\u00ednea 6 se elimin\u00f3 la \u00fanica referencia que apuntaba a \"a\", haciendo que ese objeto fuera apto para el Garbage Collector. \"B\" tiene referencias apuntando hacia \u00e9l hasta que sale del \u00e1mbito del c\u00f3digo. Esto significa que \"b\" no es escogido por el GC hasta el final del m\u00e9todo en la l\u00ednea 9. 3.10.2. finalize() Java permite a los objetos implementar un m\u00e9todo llamado finalize(). Este m\u00e9todo se llama si el Garbage Collector intenta recoger el objeto. Si el Grabage Collector no se ejecuta, el m\u00e9todo no es llamado nunca. Si el Garbage Collector no puede recoger el objeto e intenta ejecutarse de nuevo m\u00e1s tarde, el m\u00e9todo no se vuelve a llamar por segunda vez. En la pr\u00e1ctica, esto significa que es muy poco probable que se utilice en proyectos reales. S\u00f3lo hay que tener en cuenta que puede que no se llame y que definitivamente no ser\u00e1 llamado dos veces. Dicho esto, esta llamada no produce ninguna salida cuando la ejecutamos: public class Finalizer { protected void finalize() { System.out.println(\"Calling finalize\"); } public static void main(String[] args) { Finalizer f = new Finalizer(); } } La raz\u00f3n es que el programa termina antes de que exista la necesidad de ejecutar el Garbage Collector. A pesar de que f es elegible para la Garbage Collection, Java no ejecuta el Garbage Collector constantemente. Ahora un ejemplo m\u00e1s interesante: public class Finalizer { private static List objects = new ArrayList(); protected void finalize() { objects.add(this); // Don't do this } } Es preciso recordar que finalize() s\u00f3lo se ejecuta cuando el objeto es elegible para el Garbage Collector. El problema aqu\u00ed es que al final del m\u00e9todo, el objeto ya no es elegible para el Garbage Collector porque una variable est\u00e1tica hace referencia a \u00e9l, y las variables est\u00e1ticas pertenecen al \u00e1mbito de la aplicaci\u00f3n hasta que el programa termina. Java es lo suficientemente inteligente como para darse cuenta de esto y aborta el intento de eliminar el objeto. Ahora sup\u00f3ngase que m\u00e1s tarde, en el programa, los objetos toman el valor de cero. Finalmente, se puede eliminar el objeto de la memoria. Java recuerda que ya se ha ejecutado finalize (en este objeto), y no lo har\u00e1 de nuevo. 3.11. Beneficios de Java Java tiene algunos beneficios clave que se necesitar\u00e1 conocer: Orientado a Objetos: Java es un lenguaje orientado a objetos, lo que significa que todo el c\u00f3digo se define en clases y la mayor\u00eda de esas clases pueden ser instanciadas en objetos. Muchos idiomas antes de Java eran procedurales, lo que significaba que hab\u00eda rutinas o m\u00e9todos, pero no hab\u00eda clases. Otro enfoque com\u00fan es la programaci\u00f3n funcional. Java permite la programaci\u00f3n funcional dentro de una clase, pero el objeto orientado sigue siendo la organizaci\u00f3n principal del c\u00f3digo. Encapsulamiento : Java soporta modificadores de acceso para proteger los datos de accesos y modificaciones no deseados. Se considera que la encapsulaci\u00f3n es un aspecto de los lenguajes orientados a objetos. Plataforma Independiente : Java es un lenguaje interpretado porque se compila en bytecode. Una ventaja clave es que el c\u00f3digo Java se compila una vez en lugar de tener que ser recompilado para diferentes sistemas operativos. Esto se conoce como \"write once, run everywhere\u201d. Robusto: Una de las principales ventajas de Java sobre C++ es que previene las fugas de memoria. Java maneja la memoria por su cuenta y ejecuta el Garbage Collector autom\u00e1ticamente. La mala gesti\u00f3n de la memoria en C++ es una gran fuente de errores en los programas. Simple: Java pretend\u00eda ser m\u00e1s simple que C++. Adem\u00e1s de eliminar los punteros, elimin\u00f3 la sobrecarga del operador. En C++, se podr\u00eda escribir a + b y hacer que signifique casi cualquier cosa. Seguro: El c\u00f3digo Java se ejecuta dentro del JVM. Esto crea una sandbox que dificulta que el c\u00f3digo Java lleve a cabo acciones maliciosas en el ordenador en el que se est\u00e1 ejecutando. 3.12. Resumen En este cap\u00edtulo, se ha visto que: Estructura de las clases Java Las clases Java consisten en miembros llamados campos y m\u00e9todos. Un objeto es una instancia de una clase Java. Hay tres estilos de comentario: un comentario de una sola l\u00ednea (//), un comentario de varias l\u00edneas (/ /), y un comentario Javadoc (/* /). M\u00e9todo main Java inicia la ejecuci\u00f3n del programa con un m\u00e9todo main(). La cabecera m\u00e1s com\u00fan para este m\u00e9todo se ejecuta desde la l\u00ednea de comandos: public static void main (String[] args). Los argumentos se pasan despu\u00e9s del nombre de la clase, como en java NameOfClass firstArgument. - Los argumentos son indexados comenzando con 0. Paquetes e importaciones El c\u00f3digo Java est\u00e1 organizado en carpetas llamadas paquetes. Para hacer referencia a clases en otros paquetes, se utilizar\u00e1 una declaraci\u00f3n de importaci\u00f3n. El car\u00e1cter * al final de una sentencia de importaci\u00f3n significa que desea importar todas las clases en ese paquete. No incluye paquetes que est\u00e9n dentro de ese paquete. - - - java. lang es un paquete especial que no necesita ser importado. Crear objetos Java Los constructores crean objetos Java. Un constructor es un m\u00e9todo que corresponde al nombre de la clase y omite el tipo de devoluci\u00f3n. Cuando un objeto es instanciado, los bloques de c\u00f3digo se inicializan primero. Una vez inicializados, se puede hacer uso de los constructores. Referencias a objetos y primitivas de datos Los tipos primitivos son los bloques b\u00e1sicos de construcci\u00f3n de los tipos Java. Se montan en tipos de referencia. Las clases de referencia pueden tener m\u00e9todos y asignarse a nulo. Adem\u00e1s de los n\u00fameros \"normales\", se permite que los literales num\u00e9ricos comiencen con 0 (octal), 0x (hex), 0X (hex), 0b (binario), o 0B (binario). Los literales num\u00e9ricos tambi\u00e9n pueden contener guiones bajos siempre y cuando est\u00e9n directamente entre otros dos n\u00fameros. Declarar e inicializar variables Declarar una variable implica indicar el tipo de datos y darle un nombre a la variable. Las variables que representan campos en una clase se inicializan autom\u00e1ticamente a su correspondiente valor cero o nulo durante la instanciaci\u00f3n del objeto. Las variables locales deben ser inicializadas espec\u00edficamente. Los identificadores pueden contener letras, n\u00fameros, $ o _. Los identificadores no pueden comenzar con n\u00fameros. El \u00e1mbito de aplicaci\u00f3n se refiere a la parte del c\u00f3digo en la que se puede acceder a una variable. Hay tres tipos de variables en Java, dependiendo de su alcance: variables de instancia, variables de clase y variables locales. Las variables de instancia son los campos no est\u00e1ticos de su clase. Las variables de clase son los campos est\u00e1ticos dentro de una clase. Las variables locales se declaran dentro de un m\u00e9todo. Ordenando elementos de una clase Para algunos elementos de la clase, el orden importa dentro del c\u00f3digo. La declaraci\u00f3n del paquete viene primero si est\u00e1 presente. Luego vienen las declaraciones de importaci\u00f3n si est\u00e1n presentes. Luego viene la declaraci\u00f3n de clase. Los campos y m\u00e9todos pueden estar en cualquier orden dentro de la clase. Destruyendo objetos El Garbage Collector es el responsable de retirar objetos de la memoria cuando no se pueden volver a utilizar. Un objeto se convierte en elegible para el Garbage Collector cuando no hay m\u00e1s referencias a \u00e9l o sus referencias han salido del alcance. - El m\u00e9todo finalize() se ejecutar\u00e1 una vez para cada objeto cuando es ejecutado el Garbage Collector.","title":"Bloques b\u00e1sicos en Java"},{"location":"bloques_basicos/#3-bloques-basicos-en-java","text":"","title":"3. Bloques b\u00e1sicos en Java"},{"location":"bloques_basicos/#31-comprender-la-estructura-de-clases-de-java","text":"Las clases son los componentes b\u00e1sicos en un programa Java. Cuando se define una clase , se describen todas las partes y caracter\u00edsticas que la componen. Para utilizar la mayor\u00eda de las clases, se tienen que crear objetos. Un objeto es una instancia de la clase en tiempo de ejecuci\u00f3n. Los objetos de las distintas clases representan el estado del programa. En las siguientes secciones se ver\u00e1n los componentes de una clase Java, as\u00ed como la relaci\u00f3n entre clases y archivos.","title":"3.1. Comprender la estructura de clases de Java"},{"location":"bloques_basicos/#311-propiedades-y-metodos","text":"Las clases Java tienen dos elementos principales, m\u00e9todos , a menudo llamados funciones o procedimientos, y propiedades , tambi\u00e9n conocidas como atributos. Las propiedades mantienen el estado del programa, y los m\u00e9todos operan en ese estado. Si el cambio es relevante en el estado del programa, se almacenar\u00e1 en una propiedad. Es el programador quien crea y organiza estos elementos de tal manera que el c\u00f3digo sea \u00fatil y f\u00e1cil de entender para otros programadores. La clase Java m\u00e1s simple que puede escribirse es como la que sigue: (Los n\u00fameros de l\u00ednea solo est\u00e1n ah\u00ed para hacer la lectura del c\u00f3digo m\u00e1s f\u00e1cil, no intervienen en el programa). 1: public class Fruit { 2: } En Java existen palabras reservadas, tambi\u00e9n llamadas palabras clave o keywords. Estas palabras poseen un significado especial para Java, como, por ejemplo, la palabra reservada public (l\u00ednea 1), que permite a la clase Fruit ser utilizada por otras clases. La palabra reservada class indica que se est\u00e1 definiendo una clase. Fruit es el nombre de la clase. A continuaci\u00f3n, se a\u00f1adir\u00e1 a la clase Fruit su primera propiedad: 1: public class Fruit { 2: String name; 3: } En la l\u00ednea 2, se define la propiedad llamada name. Tambi\u00e9n se define el tipo de dato de la propiedad como una cadena de texto ( String ). Un String es un tipo de dato que contiene un texto, como por ejemplo \u201cEsto es un String \u201d. String tambi\u00e9n es una clase Java, predefinida en el propio lenguaje. Como se mencion\u00f3 anteriormente, una clase tambi\u00e9n puede contener m\u00e9todos, los cuales se declaran como se ve en el siguiente c\u00f3digo: 1: public class Fruit { 2: String name; 3: public String getName() { 4: return name; 5: } 6: public void setName(String newName) { 7: name = newName; 8: } 9: } En las l\u00edneas 3-5 se ha declarado el primer m\u00e9todo. Un m\u00e9todo es una operaci\u00f3n que puede ser llamada. En la declaraci\u00f3n del m\u00e9todo se hace tambi\u00e9n uso de la palabra reservada public para indicar que el m\u00e9todo puede ser llamado desde cualquier otra clase. La siguiente palabra, String en este caso, hace referencia al tipo de dato que devuelve el m\u00e9todo. En este caso, el tipo de dato devuelto es un String. En las l\u00edneas 6-8 se ha introducido un segundo m\u00e9todo, el cual no devuelve nada (palabra reservada void ). Este m\u00e9todo requiere que se le proporcione informaci\u00f3n cada vez que se le llama; esta informaci\u00f3n se llama par\u00e1metro. El m\u00e9todo setName tiene un par\u00e1metro llamado newName , y es de tipo String. La persona que llama al m\u00e9todo le debe pasar, por lo tanto, un par\u00e1metro de tipo String , y, tras realizar la operaci\u00f3n de asignar el valor del par\u00e1metro newName a la propiedad name , puesto que es void , el m\u00e9todo setName no devolver\u00e1 nada.","title":"3.1.1. Propiedades y m\u00e9todos"},{"location":"bloques_basicos/#312-comentarios","text":"Los comentarios son muy habituales en el c\u00f3digo de un programa Java. Son l\u00edneas de texto que no son ejecutadas, y que pueden ser colocadas en cualquier lugar. Los comentarios tienen como finalidad hacer la lectura del c\u00f3digo m\u00e1s sencilla. Hay tres tipos de comentarios en Java. 1 - El comentario de una sola l\u00ednea, comienza con dos barras diagonales. // comment until end of line 2 - El comentario de varias l\u00edneas o comentario de l\u00edneas m\u00faltiples, comienza con el s\u00edmbolo \"/ *\" hasta el s\u00edmbolo * /. Se suele escribir * al comienzo de cada l\u00ednea de un comentario de l\u00edneas m\u00faltiples para que sea m\u00e1s f\u00e1cil de leer. /* Multiple (^) * line comment (^) */ 3 - El comentario de Javadoc, muy similar a un comentario de l\u00edneas m\u00faltiples. Los comentarios de Javadoc tienen una estructura espec\u00edfica que la herramienta Javadoc sabe c\u00f3mo interpretar para poder crear la documentaci\u00f3n del c\u00f3digo. La diferencia con los comentarios de l\u00edneas m\u00faltiples es que el comienzo debe ser \"/**\" /** Javadoc multiple-line comment */","title":"3.1.2. Comentarios"},{"location":"bloques_basicos/#313-javadoc","text":"Javadoc es una utilidad de Oracle que sirve para generar documentaci\u00f3n de APIs en formato HTML a partir del c\u00f3digo. Al documentar una clase, se debe incluir lo siguiente: Descripci\u00f3n general de la clase, n\u00famero de versi\u00f3n, nombre de autores. Documentaci\u00f3n de m\u00e9todos: incluye descripci\u00f3n general, nombre y tipos de par\u00e1metros, descripci\u00f3n de par\u00e1metros, tipo de retorno, descripci\u00f3n del valor que devuelve. Para que javadoc pueda generar la documentaci\u00f3n autom\u00e1ticamente, la informaci\u00f3n debe incluirse entre s\u00edmbolos de comentario de forma que empiece con una barra simple y doble asterisco (/* ), y termine con un asterisco y barra simple ( /). Dependiendo de la ubicaci\u00f3n, el comentario puede representar una cosa distinta, si est\u00e1 incluido delante de una clase, es un comentario de clase pero, si est\u00e1 incluido delante de un m\u00e9todo, es un comentario de ese m\u00e9todo. Para crear la documentaci\u00f3n de javadoc, se hace uso de palabras reservadas o \"tags\" que van precedidas por el car\u00e1cter \"@\". En la siguiente tabla se puede encontrar las palabras reservadas que suelen utilizarse m\u00e1s a menudo. TAG DESCRIPCI\u00d3N COMPRENDE @author Nombre del desarrollador. Nombre autor o autores @deprecated Indica que el m\u00e9todo o clase es obsoleto (propio de versiones anteriores) y que no se recomienda su uso. Descripci\u00f3n @param Definici\u00f3n de un par\u00e1metro de un m\u00e9todo, es requerido para todos los par\u00e1metros del m\u00e9todo. Nombre de par\u00e1metro y descripci\u00f3n @return Informa de lo que devuelve el m\u00e9todo, no se aplica en constructores o m\u00e9todos \"void\" . Descripci\u00f3n del valor de retorno @see Asocia con otro m\u00e9todo o clase. Referencia cruzada referencia (#m\u00e9todo(); clase#m\u00e9todo(); paquete.clase; paquete.clase#m\u00e9todo()). @version Versi\u00f3n del m\u00e9todo o clase. Versi\u00f3n A continuaci\u00f3n, se ver\u00e1 un ejemplo de documentaci\u00f3n javadoc para una clase y un m\u00e9todo. **/**** *** Clase que implementa un ejemplo de una suma a partir de dos n\u00fameros dados * y** **devuelve el resultado por pantalla.** ***** *** @author Sergio** *** @version 2.** *** @since 20 18** ***/** class EjemploSuma { public static void main(String args[]){ int num1 = 10; int num2 = 5; int result = getSuma(num1,num2); System.out.println(\"La suma es igual a \"+result); } **/**** *** Devuelve la suma de dos n\u00fameros enteros (int)** ***** *** @param a primer sumando** *** @param b segundo sumando** *** @return resultado de la suma** ***/** public static int getSuma(int a, int b) { return a+b; } }","title":"3.1.3. Javadoc"},{"location":"bloques_basicos/#314-clases-vs-archivos","text":"Normalmente, cada clase de Java se define en su propio archivo * .java. Por lo general las clases son public , lo que significa que cualquier c\u00f3digo puede utilizarlas. Las clases; no obstante, no tienen por qu\u00e9 ser p\u00fablicas. Por ejemplo, definir una clase como sigue (sin la palabra reservada public ), tambi\u00e9n es posible. 1: class Fruit { 2: String name; 3: } Tambi\u00e9n es posible que dos clases Java est\u00e9n en el mismo archivo. En este caso, como mucho una de las clases del archivo puede ser p\u00fablica. Por ejemplo: 1: public class Fruit { 2: private String name; 3: } 4: class FruitSqueezer { 5: } En caso de tener una clase p\u00fablica en el archivo, el nombre de la clase debe coincidir con el nombre del archivo; es decir, public class FruitSqueezer provocar\u00eda un error de compilaci\u00f3n en un archivo llamado Fruit.java .","title":"3.1.4. Clases vs. Archivos"},{"location":"bloques_basicos/#32-el-metodo-main","text":"Un programa Java comienza su ejecuci\u00f3n en su m\u00e9todo main(). El m\u00e9todo main() es lo primero que se ejecuta cuando se inicia el programa, y es llamado autom\u00e1ticamente por la M\u00e1quina Virtual Java (JVM). La JVM es la encargada de comunicarse con el sistema subyacente para asignar recursos como la memoria, la CPU, el acceso a archivos, etc. El m\u00e9todo main() nos sirve como enlace para conectar las distintas partes del c\u00f3digo a partir del inicio de la ejecuci\u00f3n del programa. Un ejemplo del tipo de clase m\u00e1s simple que puede contener el m\u00e9todo main() ser\u00eda como la siguiente: 1: public class Fruit { 2: public static void main(String[] args) { 3: 4: } 5:} Este c\u00f3digo no hace nada \u00fatil. No tiene ninguna instrucci\u00f3n m\u00e1s all\u00e1 que declarar el punto de inicio de la ejecuci\u00f3n del programa. Lo que se pretende con este c\u00f3digo de ejemplo es mostrar que el m\u00e9todo main() se puede declarar en cualquier parte del c\u00f3digo Java. De hecho, la \u00fanica raz\u00f3n de que este m\u00e9todo est\u00e9 dentro de una clase se debe a que el lenguaje as\u00ed lo requiere. Para compilar ( javac ) y ejecutar ( java ) el siguiente c\u00f3digo, este deber\u00eda escribirse dentro del archivo Fruit.java, y posteriormente se deber\u00edan escribir las siguientes instrucciones en la consola: $ javac Fruit.java $ java Fruit En caso de no obtener ning\u00fan mensaje de error, el programa se ejecut\u00f3 con \u00e9xito. En caso de obtener un mensaje de error, se deber\u00eda verificar que el Java Development Kit (JDK) est\u00e1 correctamente instalado y que no existe ning\u00fan error sint\u00e1ctico en la escritura del c\u00f3digo. Para compilar c\u00f3digo Java, el archivo debe tener la extensi\u00f3n .java. El nombre del archivo debe coincidir con el nombre de la clase definida en el archivo. El resultado es otro archivo de bytecode con el mismo nombre, pero con una extensi\u00f3n .class. El bytecode no es c\u00f3digo legible por las personas, pero s\u00ed por la JVM. Las reglas sobre c\u00f3mo debe ser el contenido de un archivo de c\u00f3digo Java son m\u00e1s extensas de lo que se ha visto hasta ahora; no obstante, por el momento y con la finalidad de hacerlo m\u00e1s simple, solo se tendr\u00e1n en cuenta las siguientes: 1 - Cada archivo puede contener solo una clase ( ya se ha visto que no tiene por qu\u00e9 ser as\u00ed, pero de esta forma el c\u00f3digo ser\u00e1 m\u00e1s sencillo ). 2 - El nombre del archivo debe coincidir con el nombre de la clase que contiene, y la extensi\u00f3n de este siempre ser\u00e1 .java. Se supone que se reemplaza la l\u00ednea 3 en Fruit.java con System.out.println (\"Hola\") . Cuando se compila y se ejecuta nuevamente el c\u00f3digo, el programa imprimir\u00e1 en la consola la palabra \u201cHola\u201d . A continuaci\u00f3n se va a revisar en profundidad el m\u00e9todo main() , ya que aparecen en \u00e9l una serie de palabras clave del lenguaje Java, algunas ya vistas anteriormente. La palabra reservada public es lo que se llama un modificador de acceso. Declara el nivel de exposici\u00f3n de este m\u00e9todo a la hora de ser llamado en otras partes del programa. En este caso, public hace referencia a que el m\u00e9todo puede ser llamado en cualquier parte del programa. La palabra reservada static enlaza un m\u00e9todo a su clase para que pueda ser llamado solo por el nombre de la clase, como, por ejemplo, Fruit.main(). No es necesario crear un objeto para llamar al m\u00e9todo main(). Si el m\u00e9todo main() no est\u00e1 presente en la clase .java que se ejecuta en la consola, el proceso generar\u00e1 un error y terminar\u00e1. Incluso si el m\u00e9todo main() est\u00e1 presente y no es est\u00e1tico (palabra reservada static ), Java lanzar\u00e1 una excepci\u00f3n. La palabra reservada void representa el tipo de dato que devuelve el m\u00e9todo. Un m\u00e9todo que no devuelve datos (es decir, que es void ) devuelve el control de la ejecuci\u00f3n del programa al punto donde qued\u00f3 antes de ser ejecutado de manera \u201csilenciosa\u201d. En general, es una buena pr\u00e1ctica usar void para m\u00e9todos que cambian el estado de un objeto. En ese caso, el m\u00e9todo main() cambia el estado del programa de iniciado a finalizado. Finalmente se llega a la lista de par\u00e1metros del m\u00e9todo main() , representada como un array de objetos de tipo java.lang.String. El compilador acepta cualquiera de las siguientes formas a la hora de declarar lo par\u00e1metros: String[] args , String args[] o String...args. La variable args contiene los argumentos que se leyeron de la consola cuando se inici\u00f3 la JVM. Los caracteres [] son corchetes, utilizados para representar que args es un array. Un array es una lista de tama\u00f1o fijo que contiene elementos de un mismo tipo de dato. Los caracteres ... se denominan varargs (lista de argumentos variable). En el siguiente ejemplo se ve c\u00f3mo usar el par\u00e1metro args. Primero se modifica el programa anterior para imprimir los primeros dos argumentos que sean pasados al programa: public class Fruit { public static void main(String[] args) { System.out.println(args[0]); System.out.println(args[1]); } } args[0] accede al primer elemento del array. Los \u00edndices de los array en Java siempre comienzan por 0. Para ejecutar el c\u00f3digo anterior, se podr\u00eda escribir en la consola: $ javac Fruit.java $ java Fruit Banana Apple Y la consola imprimir\u00eda: Banana Apple El programa identifica correctamente las dos primeras palabras como argumentos separados por espacios. En caso de querer espacios dentro de un argumento, se usan comillas tal que as\u00ed: $ javac Fruit.java $ java Fruit \"Big Banana\" Apple Y la consola imprimir\u00eda: Big Banana Apple Todos los argumentos de la l\u00ednea de comandos se tratan como objetos de tipo String , incluso si representan otro tipo de datos: $ javac Fruit.java $ java Fruit Fruit 1 A pesar de que Fruit es una clase y 1 es un n\u00famero, el programa los interpretar\u00e1 a ambos como la cadena de texto \u201cFruit\u201d y la cadena de texto \u201c1\u201d, y por lo tanto, la consola imprimir\u00e1 lo siguiente: Fruit 1 Finalmente, \u00bfQu\u00e9 sucede si no se escriben suficientes argumentos? $ javac Fruit.java $ java Fruit Fruit La lectura de args[0] es correcta y \u201cFruit\u201d se imprime por pantalla, pero al no tener otro argumento, Java imprime una excepci\u00f3n mostrando que no existe ning\u00fan argumento en args[1]. La consola imprimir\u00e1 por lo tanto: FruitException in thread \"main\" java.lang.ArrayIndexOutOfBoundsException: 1 at mainmethod. **Fruit** .main (Fruit.java:7) Es necesario tener un JDK (Java Development Kit) para compilar c\u00f3digo Java; no obstante, el JDK no es necesario para ejecutar el c\u00f3digo, basta con un JRE (Java Runtime Environment). Los archivos de clase Java que se ejecutan en la JVM (Java Virtual Machine) se ejecutan en cualquier m\u00e1quina con Java independientemente de la m\u00e1quina original donde fueron compilados o el sistema operativo de esta.","title":"3.2. El m\u00e9todo main()"},{"location":"bloques_basicos/#33-paquetes-e-importaciones","text":"Java tiene miles de clases por defecto y muchas otras creadas por otros desarrolladores, por lo que es necesario una forma de organizarlas. En Java existen paquetes ( packages ), los cuales sirven para organizar las clases de manera l\u00f3gica. Es necesario especificar en qu\u00e9 paquete se encuentra cada clase para que Java pueda utilizar la clase correcta. Se supone que el siguiente c\u00f3digo est\u00e1 por compilar: public class ImportExample { public static void main(String[] args) { Random r = new Random(); // \u00a1No compila! System.out.println(r.nextInt(10)); } } El compilador de Java mostrar\u00e1 un error como el siguiente: Random cannot be resolved to a type Este error podr\u00eda significar un error tipogr\u00e1fico en el nombre de la clase, o puede que se haya omitido un import necesario (la importaci\u00f3n de la clase Random). Las sentencias de importaci\u00f3n ( import ) indican a Java en qu\u00e9 paquetes buscar las clases. Intentarlo de nuevo con la importaci\u00f3n de la clase Random hace que el programa compile: import java.util.Random; // Indica a la clase d\u00f3nde encontrar la clase Random //(Paquete java.util) public class ImportExample { public static void main(String[] args) { Random r = new Random(); System.out.println(r.nextInt(10)); //Imprime por pantalla un n\u00famero // del 0 al 9 } } Ahora el c\u00f3digo se ejecuta e imprime un n\u00famero aleatorio entre 0 y 9. Al igual que ocurre con los arrays , la cuenta empieza en 0. Las clases de Java se agrupan en paquetes ( packages ). La sentencia import le indica al compilador en qu\u00e9 paquete buscar para encontrar una clase. A modo de analog\u00eda, si se imagina una carta cuyo destinatario es la direcci\u00f3n C/San Andr\u00e9s n\u00ba20 1\u00baC. El cartero ir\u00e1 en primer lugar al edificio n\u00famero 20 de la calle San Andr\u00e9s, y luego buscar\u00e1 el piso 1\u00baC. La direcci\u00f3n (calle y n\u00famero de edificio) ser\u00edan los paquetes Java, y 1\u00baC ser\u00eda el nombre de la clase Java, la cual se ha podido encontrar porque se sab\u00eda dentro de qu\u00e9 paquetes estaba. Hay muchos pisos 1\u00baC, pero solo hay un 1\u00baC en el edificio n\u00ba20 de la calle San Andr\u00e9s. Los nombres de los paquetes son jer\u00e1rquicos, al igual que ocurre con el correo. El servicio de correo mirar\u00e1 en primer lugar el pa\u00eds, luego la regi\u00f3n, la ciudad, la calle, el edificio y por \u00faltimo el piso para poder entregar una carta. Con los paquetes Java ocurre algo muy similar. Si el paquete comienza por java o javax significa que es un paquete por defecto del JDK; si empieza por cualquier otra cosa, har\u00e1 referencia al dominio del propietario del paquete. Por ejemplo, el paquete com.amazon.laClaseQueSea indica que el c\u00f3digo viene de amazon.com. Tras el nombre del dominio los nombres del resto de la jerarqu\u00eda de paquetes y clases pueden ser los que el programador guste, aunque es una buena pr\u00e1ctica que estos sean lo m\u00e1s descriptivos posible. En los ejemplos que se muestran a continuaci\u00f3n es posible encontrar paquetes que no provengan de ning\u00fan dominio concreto, como, por ejemplo a.b.c (la clase c est\u00e1 dentro del paquete a.b), esto no es un problema, ya que se trata \u00fanicamente de ejemplos.","title":"3.3. Paquetes e importaciones"},{"location":"bloques_basicos/#331-wildcards","text":"Las clases que se encuentran en el mismo paquete se pueden importar todas juntas, y para ello, se utiliza el siguiente car\u00e1cter comod\u00edn o wildcard. Actualmente se considera una mala pr\u00e1ctica, ya que se importan clases innecesarias que pueden no necesitarse. import java.util.*; //El asterisco indica que se importar\u00e1n todas las clases dentro //del paquete java.util Ejemplo: import java.util.*; public class ImportExample { public static void main(String[] args) { Random r = new Random(); System.out.println(r.nextInt(10)); } } En este caso, \u00fanicamente se utiliza la clase java.util.Random en el programa; no obstante, se han importado todas las clases del paquete java.util (* es una wildcard que indica todas las clases). \u00danicamente se importar\u00e1n las clases, no los paquetes hijos que contenga. El n\u00famero de import que tenga un programa no ralentiza el programa. El compilador lee cada clase en el momento en que la necesita.","title":"3.3.1. Wildcards"},{"location":"bloques_basicos/#332-imports-redundantes","text":"Como se ha podido ver en el c\u00f3digo de ejemplos anteriores, se han utilizado clases, como la clase System o la clase String en los programas sin importar nada, \u00bfC\u00f3mo es que el c\u00f3digo funcionaba si no se han importado estas clases? Esto se debe a que existe un paquete en Java llamado java.lang que siempre se importa de manera autom\u00e1tica. Aun as\u00ed, Java permite tambi\u00e9n importarlo manualmente. Esto, no obstante, no se debe hacer, ya que importar algo que se importa por defecto o que ya est\u00e1 importado crea c\u00f3digo redundante. Ejemplo: 1: import java.lang.System; 2: import java.lang.*; 3: import java.util.Random; 4: import java.util.*; 5: public class ImportExample { 6: public static void main(String[] args) { 7: Random r = new Random(); 8: System.out.println(r.nextInt(10)); 9: } 10:} \u00bfCu\u00e1ntos de los import son redundantes? La respuesta es tres. Las l\u00edneas 1 y 2 son redundantes porque, como se ha comentado anteriormente, el paquete java.lang es importado de forma autom\u00e1tica y por lo tanto no necesita de un import. La l\u00ednea 4 es tambi\u00e9n redundante. La clase Random es importada al c\u00f3digo mediante la sentencia de la l\u00ednea 3 ( import java.util.Random; ), por lo que no es necesario importar, adem\u00e1s, el resto del paquete java.util de la l\u00ednea 4. Otro caso de redundancia ser\u00eda importar una clase que se encuentra en el mismo paquete que la clase que se est\u00e1 ejecutando, ya que, de forma autom\u00e1tica, Java tiene en cuenta a todas las clases del mismo paquete sin necesidad de importarlas unas en otras. Otro ejemplo: public class InputImports { public void read(Files files) { Paths.get(\"name\"); } } Se supone que las clases Files y Paths est\u00e1n en el mismo paquete java.nio.file, y que la clase del ejemplo, InputInmports, est\u00e1 en un paquete diferente. \u00bfQu\u00e9 se deber\u00eda importar para que el programa compile? Hay dos posibles formas de hacerlo: import java.nio.file.*; //Importa ambos paquetes debido al uso de la _wildcard_ * o import.jav a.nio.file.Files; //Importa la clase File import.java.nio.file.Paths; //Importa la clase Paths A continuaci\u00f3n, se muestran unos ejemplos que NO funcionar\u00edan: import java.nio.*; // NO FUNCIONA. Recordar que la wildcard * //solo importa clases, no otros paquetes import java.nio.*.*; // NO FUNCIONA. Solo puede haber una wildcard //por import y esta debe estar al final import java.nio.file.Paths.*; // NO FUNCIONA. No se pueden importar //m\u00e9todos sin la palabra clave static","title":"3.3.2. Imports redundantes"},{"location":"bloques_basicos/#333-conflictos-de-nombrado","text":"Una de las razones para utilizar paquetes en Java es que el nombre de las clases no tiene por qu\u00e9 ser \u00fanico. Esto quiere decir que algunas veces se querr\u00e1 importar una clase que tenga el mismo nombre que otras que se encuentran en otras partes del programa. Un ejemplo de esto es la clase Date. Java posee implementadas las clases java.util.Date y java.sql.Date. Son dos clases diferentes con el mismo nombre; no obstante, cada una se encuentra en un paquete diferente. Ejemplo: import java.util.*; import java.sql.*; // No compila public class Conflicts { Date date; //M\u00e1s c\u00f3digo } El c\u00f3digo no compila ya que la clase Date existe en ambos paquetes, por lo que Java dar\u00e1 el siguiente error de compilaci\u00f3n: \u201c The type Date is ambiguous \u201d. Tampoco compilar\u00e1 esto: import java.util.Date; import java.sql.Date; Java lanzar\u00e1 el error de compilaci\u00f3n \"The import java.sql.Date collides with another import statement\u201c. En caso de que se quiera usar las clases de ambos paquetes: clases de java.util. y clases de java.sql. , y la clase Date que ser\u00e1 la que est\u00e1 en java.util. , se deber\u00e1 importar lo siguiente: import java.util.Date; import java.sql.*; Ahora, al importar de manera expl\u00edcita la clase Date de java.util. , esta tiene precedencia por encima de todas las clases importadas con la wildcard *. \u00bfQu\u00e9 ocurre si realmente se quiere utilizar en el c\u00f3digo dos clases con el mismo nombre? En ocasiones podr\u00eda ocurrir que se quisiera utilizar la clase Date de ambos paquetes. Cuando esto pasa, una opci\u00f3n ser\u00eda importar \u00fanicamente una de las clases y, cuando se quiera utilizar la otra, llamarla haciendo uso de su nombre plenamente cualificado (es decir, nombre de paquete, punto, nombre de la clase). Por ejemplo: import java.util.Date; public class Conflicts { Date date; //Usa la clase java.util.Date java.sql.Date sqlDate; //Usa la clase java.sql.Date }","title":"3.3.3. Conflictos de nombrado"},{"location":"bloques_basicos/#334-crear-un-nuevo-paquete","text":"Hasta ahora, parte del c\u00f3digo que se ha escrito en el cap\u00edtulo se ha encontrado en el paquete por defecto default package. Este es un paquete especial que carece de nombre y que es mejor no utilizar. En la vida real, ser\u00e1 necesario nombrar los paquetes donde se encuentran las clases para evitar conflictos de nombrado y para permitir la reutilizaci\u00f3n de c\u00f3digo. Ahora, se quiere crear un nuevo paquete. La estructura de directorios en un ordenador normal est\u00e1 relacionado con la estructura de paquetes en Java. Se debe tener en cuenta, por ejemplo, la existencia de las siguientes clases: C:\\temp\\packagea\\ClassA.java package packagea; public class ClassA { } C: \\ temp \\ packageb \\ ClassB.java package packageb; import packagea.ClassA; public class ClassB { public static void main(String[] args) { ClassA a; System.out.println(\"Got it\"); } } Cuando se ejecuta un programa Java, Java sabe \u201cd\u00f3nde buscar\u201d los paquetes necesarios. En este caso, ejecutando el programa en el directorio C:\\temp todo funcionar\u00eda correctamente ya que ambos paquetes: packagea y packageb est\u00e1n en en C:\\temp.","title":"3.3.4. Crear un nuevo paquete"},{"location":"bloques_basicos/#335-compilar-codigo-con-packages","text":"Es posible, y de hecho mucho m\u00e1s c\u00f3modo, utilizar un IDE ( Integrated Development Environment ) para programar c\u00f3digo Java, como Eclipse o Netbeans; no obstante, es posible ejecutar un programa Java desde la l\u00ednea de comandos y es importante saber c\u00f3mo hacerlo. Se comienza por crear ambas clases y situarse en el directorio C:\\temp:","title":"3.3.5. Compilar c\u00f3digo con packages :"},{"location":"bloques_basicos/#windows","text":"Crear los archivos: C: \\ temp \\ packagea \\ ClassA.java C: \\ temp \\ packageb \\ ClassB.java Ir a C: \\ temp cd C: \\ temp","title":"Windows"},{"location":"bloques_basicos/#mac-oslinux","text":"Crear los archivos: /tmp/packagea/ClassA.java /tmp/packageb/ClassB.java Escribir el comando cd /tmp A continuaci\u00f3n es necesario compilar ambos archivos, por lo que hay que escribir lo siguiente en la l\u00ednea de comandos: javac packagea/ClassA.java packageb/ClassB.java En caso de que el comando no funcione, se mostrar\u00e1 por pantalla un mensaje de error. En estos casos es recomendable revisar los archivos con cuidado para detectar alg\u00fan posible error de sintaxis. En caso de que el comando funcione correctamente, se crear\u00e1n dos nuevos archivos: packagea/ClassA.class y packageb/ClassB.class . Por \u00faltimo, quedar\u00eda ejecutar el programa. Para ello habr\u00eda que poner lo siguiente en la l\u00ednea de comandos: java packageb.ClassB Si todo funciona correctamente, la frase \u201c Got it \u201d se mostrar\u00e1 en la consola. Es importante percatarse de que a la hora de ejecutar un programa se escribe \u00fanicamente ClassB , no ClassB.class. En Java no se escribe la extensi\u00f3n cuando se ejecuta un programa.","title":"Mac OS/Linux"},{"location":"bloques_basicos/#336-ruta-de-las-clases-y-jars","text":"Tambi\u00e9n es posible especificar la ubicaci\u00f3n de otros archivos, expl\u00edcitamente, utilizando rutas. Esta t\u00e9cnica es muy \u00fatil cuando los archivos de las clases est\u00e1n situados en otra parte que no sea el directorio actual o en archivos JAR. Un archivo JAR es como un archivo ZIP que \u00fanicamente contiene clases Java. A continuaci\u00f3n se ver\u00e1n unos ejemplos: En Windows java - cp \".;C: \\ temp \\ someOtherLocation;c: \\ temp \\ myJar.jar\" myPackage.MyClass En MAC OS/Linux java - cp \".:/tmp/someOtherLocation:/tmp/myJar.jar\" myPackage.MyClass El punto inicial indica que se quiere incluir el directorio actual en la ruta de la clase. El resto del comando incluir\u00e1 tambi\u00e9n las clases (o paquetes) en someOtherLocation y en myJar.jar . Windows utiliza el car\u00e1cter punto y coma para separar las partes de la ruta, y MAC OS y Linux utiliza el car\u00e1cter dos puntos. Tambi\u00e9n es posible utilizar la wildcard (*) para hacer referencia a todos los JARs de un directorio. Como por ejemplo: java -cp \"C:\\temp\\directoryWithJars\\*\" myPackage.MyClass Este comando a\u00f1adir\u00e1 todos los JARs que se encuentren en el directorio directoryWithJars a la ruta de la clase. No obstante, no incluir\u00e1 los JARs que se encuentren en los subdirectorios de directoryWithJars.","title":"3.3.6. Ruta de las clases y JARs"},{"location":"bloques_basicos/#34-crear-objetos","text":"Los objetos son una parte fundamental de un programa Java. Un objeto es una instancia de una clase. En las siguientes secciones, se profundizar\u00e1 acerca de los constructores, las propiedades y c\u00f3mo \u00e9stas han de ser inicializadas correctamente.","title":"3.4. Crear objetos"},{"location":"bloques_basicos/#341-constructores","text":"Para crear una instancia de una clase, siempre se utilizar\u00e1 la palabra reservada new. Por ejemplo: Random r = new Random(); En primer lugar se declara la variable declarando el tipo de dato que tendr\u00e1 (en este caso Random ) y su nombre (r). Esto permitir\u00e1 a Java reservar en memoria una referencia al objeto. Es al escribir new Random() cuando realmente el objeto es creado. Random() parece un m\u00e9todo, ya que est\u00e1 seguido de par\u00e9ntesis. Este tipo de m\u00e9todos son llamados constructores, y son los encargados de crear nuevos objetos. A continuaci\u00f3n, se ver\u00e1 un ejemplo de c\u00f3mo se define un m\u00e9todo constructor: public class Chick { public Chick() { System.out.println(\"in constructor\"); } } Cabe destacar un par de detalles del siguiente c\u00f3digo: en primer lugar, el nombre del constructor es el mismo que el nombre de la clase, y en segundo lugar, no hay return . El m\u00e9todo public void Chick() { } NO ser\u00eda un constructor. Es necesario prestar especial atenci\u00f3n a estos detalles. En caso de ver un m\u00e9todo que comience por may\u00fascula pero tenga tipo de return (aunque este sea void ), nunca ser\u00e1 un constructor. Se tratar\u00e1 de un m\u00e9todo normal que no ser\u00e1 ejecutado cuando se escriba new Chick() . El prop\u00f3sito de un constructor es inicializar las propiedades del objeto (aunque se pueda escribir dentro de \u00e9l lo que se desee). Otra forma de inicializar propiedades es hacerlo directamente en la l\u00ednea de c\u00f3digo donde estas son declaradas. En el siguiente ejemplo se pueden observar ambos casos: public class Chicken { int numEggs = 0;// Inicializada directamente String name; public Chicken() { name = \"Duke\";// Inicializada en elconstructor } } Muchas clases no precisan de un constructor expl\u00edcito, por lo que el compilador las provee de un constructor por defecto que no hace nada (es decir, su \u00fanica finalidad es permitir crear objetos, pero no tiene c\u00f3digo alguno en su interior).","title":"3.4.1. Constructores"},{"location":"bloques_basicos/#342-leer-y-modificar-las-propiedades-de-los-objetos","text":"Es posible leer y modificar las propiedades de un objeto a partir de s\u00ed mismo, por ejemplo: public class Swan { int numberEggs;// variable de instancia o propiedad de la clase Swan public static void main(String[] args) { Swan mother = new Swan(); mother.numberEggs = 1; // modifica la propiedad System.out.println(mother.numberEggs); // lee la propiedad } } En este caso, la propiedad numberEggs es obtenida directamente cuando es imprimida por consola. En el m\u00e9todo main , la variable numberEggs es modificada escribiendo en ella el valor 1. M\u00e1s adelante se ver\u00e1 la forma de prevenir que cualquiera pueda modificar las propiedades de un objeto directamente, para que, por ejemplo, no se pueda poner un n\u00famero de huevos negativo. Tambi\u00e9n es posible leer y escribir propiedades directamente al declararlas: 1: public class Name { 2: String first = \"Theodore\"; 3: String last = \"Moose\"; 4: String full = first + last; 5: } Las l\u00edneas 2 y 3 modifican las propiedades first y last , respectivamente, mientras que en la l\u00ednea 4 las propiedades first y last son le\u00eddas y, despu\u00e9s, se modifica la propiedad full con el valor de la concatenaci\u00f3n de ambas.","title":"3.4.2. Leer y modificar las propiedades de los objetos"},{"location":"bloques_basicos/#343-bloques-inicializadores-de-instancias","text":"A lo largo de los cap\u00edtulos anteriores se han visto diferentes m\u00e9todos, todos ellos conteniendo los caracteres {}. El c\u00f3digo entre llaves \u201c{}\u201d es llamado bloque de c\u00f3digo. La mayor\u00eda de las veces hay bloques de c\u00f3digo dentro de m\u00e9todos, que se ejecutan cuando el m\u00e9todo es llamado. Otras veces, los bloques de c\u00f3digo pueden aparecer fuera de un m\u00e9todo. Estos bloques son llamados inicializadores de instancia. \u00bfCu\u00e1ntos bloques hay en el siguiente c\u00f3digo? \u00bfCu\u00e1ntos de estos bloques son bloques inicializadores de instancias? 3: public static void main(String[] args) { 4: { System.out.println(\"Feathers\"); } 5: } 6: { System.out.println(\"Snowy\"); } Hay tres bloques y un inicializador de instancia. Contar el n\u00famero de bloques es sencillo: \u00fanicamente hay que contar los pares de llaves que hay en el c\u00f3digo. Si no hay el mismo n\u00famero de \u201c{\u201c que de \u201c}\u201d el c\u00f3digo no compilar\u00e1. Para poder identificar un bloque inicializador de instancia es necesario tener en cuenta que estos nunca podr\u00e1n aparecer dentro de un m\u00e9todo, por lo que el inicializador de instancia del c\u00f3digo anterior es el bloque que aparece en la l\u00ednea 6.","title":"3.4.3. Bloques inicializadores de instancias"},{"location":"bloques_basicos/#344-orden-de-inicializacion","text":"Cuando se escribe c\u00f3digo que inicializa propiedades en diferentes partes del programa, es necesario tener en cuenta el orden de inicializaci\u00f3n de las mismas. Por el momento, se tendr\u00e1 en cuenta las siguientes reglas a la hora de inicializar propiedades: Tanto las propiedades como los bloques de iniciaci\u00f3n de instancias son ejecutados en el orden en el que aparezcan en el c\u00f3digo. El constructor se ejecuta despu\u00e9s de que las propiedades y los bloques de inicializaci\u00f3n de instancias se hayan ejecutado. A continuaci\u00f3n, se ver\u00e1 el siguiente ejemplo: 1: public class Chick { 2: private String name = \"Fluffy\"; 3: { System.out.println(\"setting field\"); } 4: public Chick() { 5: name = \"Tiny\"; 6: System.out.println(\"setting constructor\"); 7: } 8: public static void main(String[] args) { 9: Chick chick = new Chick(); 10: S ystem.out.println(chick.name); } } Que imprimir\u00e1 por pantalla lo siguiente: setting field setting constructor Tiny En primer lugar, el programa comienza su ejecuci\u00f3n en el m\u00e9todo main() (como ocurre en cualquier programa Java). En la l\u00ednea 9, se llama al constructor de la clase Chick, y Java crea un nuevo objeto de la misma. Primero la propiedad name es inicializada con el valor \u201cFluffy\u201d en la l\u00ednea 2. Despu\u00e9s se ejecuta System.out.println(\"setting field\"); en la l\u00ednea 3. Una vez las propiedades y los bloques inicializadores de instancias se han ejecutado, Java vuelve al constructor. La l\u00ednea 5 cambia el valor de name a \u201cTiny\u201d y la l\u00ednea 6 vuelve a imprimir por pantalla mediante la sentencia System.out.println(\"setting constructor\"); En este punto, el constructor ha terminado de ejecutarse, y se retorna al m\u00e9todo main , concretamente, a la l\u00ednea 10. El orden del c\u00f3digo es importante. No se puede hacer referencia a una variable antes de que esta haya sido declarada. { System.out.println(name); } // NO COMPILA private String name = \"Fluffy\"; Otro ejemplo, \u00bfqu\u00e9 imprimir\u00e1 por pantalla el siguiente c\u00f3digo? public class Egg { public Egg() { number = 5; } public static void main(String[] args) { Egg egg = new Egg(); System.out.println(egg.number); } private int number = 3; { number = 4;} } La respuesta correcta ser\u00e1 \u201c5\u201d. Las propiedades y los bloques de c\u00f3digo inicializadores de instancia se ejecutar\u00e1n en primer lugar, cambiando number a 3 y luego a 4. Posteriormente, el constructor modifica number a 5, y esto es lo que se imprime por pantalla.","title":"3.4.4. Orden de inicializaci\u00f3n"},{"location":"bloques_basicos/#35-diferencia-entre-referencias-a-objetos-y-primitivas-de-datos","text":"Las aplicaciones Java contienen dos grupos de tipos de dato: variables de referencia y primitivas de datos. En este apartado se expondr\u00e1n las diferencias entre ambos grupos.","title":"3.5. Diferencia entre referencias a objetos y primitivas de datos"},{"location":"bloques_basicos/#351-primitivas-de-datos","text":"Java posee ocho tipos de dato incorporados en el propio lenguaje por defecto que se conocen como primitivas de datos. Estos ocho tipos de dato representan los cimientos de cualquier objeto Java, ya que todos los objetos son composiciones m\u00e1s o menos complejas de las primitivas de datos. La siguiente tabla muestra todas las primitivas de datos junto con su tama\u00f1o en bytes y el rango de valores que pueden adoptar. Palabra reservada(keyword) Tipo Ejemplo boolean true o false True byte Valor entero de 8 bits 123 short Valor entero de 16 bits 123 int Valor entero de 32 bits 123 long Valor entero de 64 bits 123 float Valor en coma flotante de 32 bits 123.45f double Valor en coma flotante de 64 bits 123.456 char Valor Unicode de 16 bits \u2018a\u2019 A continuaci\u00f3n se ver\u00e1, detalladamente, la informaci\u00f3n de la tabla anterior: float y double son utilizados para representar valores decimales. Los datos float necesitan poner la letra f seguido del n\u00famero para que Java los identifique como float. byte, short, int y long se utilizan para representar n\u00fameros enteros. Cada tipo num\u00e9rico utiliza dos veces m\u00e1s bits que el tipo num\u00e9rico m\u00e1s peque\u00f1o anterior a \u00e9l; por ejemplo, short utiliza el doble de bits que byte. Es necesario tener presente que un byte puede contener valores de -128 a 127, \u00bfPor qu\u00e9? Un byte son 8 bits. Un bit puede tener dos posibles valores. 2^8 es 256. Ya que el 0 tambi\u00e9n ha de ser incluido en el rango de n\u00fameros a abarcar, Java lo considera en la parte positiva, por lo que 256/2=128 (de -128 a 127). El n\u00famero de bits utilizado por Java cuando necesita reservar memoria para una primitiva de datos ser\u00e1 el n\u00famero de bits que ocupe cada tipo de dato. Por ejemplo, Java reservar\u00e1 32 bits de memoria cuando se escriba lo siguiente: int num; Continuando con las primitivas de datos num\u00e9ricas, cabe destacar que cuando un n\u00famero est\u00e1 presente en el c\u00f3digo, es llamado \u201cliteral\u201d. Por defecto, Java asume que el valor definido es del tipo int. En el ejemplo siguiente, el valor que se muestra es demasiado grande para ser de tipo int. int max = 3123456789; //NO COMPILA Java mostrar\u00e1 que ese n\u00famero est\u00e1 fuera de rango, lo cual es cierto teniendo en cuenta que pretende interpretarlo como un n\u00famero de tipo int. No obstante, no se pretende que sea el n\u00famero de tipo int. La soluci\u00f3n es a\u00f1adir la letra L al n\u00famero. long max = 3123456789L; //Ahora es cuando Java comprende que el n\u00famero es un long Otra manera de escribir n\u00fameros es cambar la base. Cuando se aprende a contar, se estudian los d\u00edgitos del 0 al 9 (n\u00fameros en base 10 o sistema decimal, ya que hay 10 n\u00fameros). Java permite escribir n\u00fameros de otras maneras: Octal (d\u00edgitos del 0-7). Para expresar un n\u00famero en octal, este ha de ir precedido por un 0. Por ejemplo: 017 Hexadecimal (d\u00edgitos del 0-9, letras de la A-F). Para expresar un n\u00famero en hexadecimal, este ha de ir precedido por el prefijo 0x o 0X. Por ejemplo: 0xFF. Binario (d\u00edgitos 0-1). Para expresar un n\u00famero en binario, este ha de ir precedido por el prefijo 0b o 0B. Por ejemplo: 0b10. Lo \u00faltimo a tener en cuenta sobre literales num\u00e9ricos es una caracter\u00edstica a\u00f1adida en Java 7, y es que es posible a\u00f1adir barras bajas a los n\u00fameros para facilitar su lectura: int million1 = 1000000; int million2 = 1_000_000; Las barras bajas se podr\u00e1n a\u00f1adir en cualquier parte del literal num\u00e9rico excepto: Al principio del literal. Al final del literal. Antes de un punto decimal. Despu\u00e9s de un punto decimal. Por ejemplo: double notAtStart = _1000.00; //NO COMPILA double notAtEnd = 1000.00_; //NO COMPILA double notByDecimal = 1000_.00; //NO COMPILA double goodOne = 1_00_0.0_0; //COMPILA","title":"3.5.1. Primitivas de datos"},{"location":"bloques_basicos/#352-tipos-referencia","text":"Un tipo referencia es un objeto (un objeto es una instancia de una clase). Al contrario que ocurre con las primitivas de datos, que guardan sus valores directamente en la memoria reservada por la variable, los tipos referencia no guardan los valores de los objetos en la direcci\u00f3n de memoria reservada cuando las variables son declaradas. En lugar de eso, la referencia \u201capunta\u201d al objeto asignado a la variable guardando la direcci\u00f3n de memoria donde este se encuentra, concepto tambi\u00e9n conocido como puntero. Al contrario que en otros lenguajes, Java no permite conocer cu\u00e1l es la direcci\u00f3n f\u00edsica en memoria donde est\u00e1n guardados sus objetos. La forma de declarar e inicializar tipos referencia es la siguiente, se consideran declaradas dos referencias, una de tipo java.util.Date , y otra de tipo String : java.util.Date hoy; String saludo; La variable hoy es una referencia de tipo Date, y \u00fanicamente puede \u201capuntar\u201d a un objeto de tipo Date. La variable saludo es una variable que \u00fanicamente puede \u201capuntar\u201d a un objeto de tipo String. Es posible asignar un valor a una referencia de las siguientes formas: A una referencia se le puede asignar un objeto de su mismo tipo de dato. A una referencia se le puede asignar un nuevo objeto utilizando para ello la palabra reservada new . Por ejemplo, el siguiente c\u00f3digo muestra dos asignaciones a nuevos objetos: hoy = new java.util.Date(); saludo = \u201c\u00a1Buenos d\u00edas!\u201d; La referencia hoy apunta a un Nuevo objeto de tipo Date en memoria, por lo que a partir de ahora hoy podr\u00e1 ser utilizada para acceder a los m\u00e9todos y atributos de la clase Date. De igual manera, la referencia saludo apunta a un nuevo objeto de tipo String, el cual tiene el valor \u201c\u00a1Buenos d\u00edas!\u201d. Los objetos String y Date \u00fanicamente pueden ser accedidos a trav\u00e9s de sus referencias. La siguiente figura muestra un ejemplo de c\u00f3mo las variables referencia se representan en memoria:","title":"3.5.2. Tipos referencia"},{"location":"bloques_basicos/#353-diferencias-clave","text":"Existen algunas diferencias muy importantes a tener en cuenta entre primitivas de datos y variables referencia. En primer lugar, las variables referencia pueden tener el valor null , lo que quiere decir que no tienen ning\u00fan objeto asignado. Las primitivas de datos mostrar\u00e1n un error de compilaci\u00f3n si se les intenta asignar el valor null. En el siguiente ejemplo, valor no puede ser null , ya que es de tipo int. int valor = null; //NO COMPILA String s = null; En segundo lugar, los tipos referencia pueden ser utilizados para llamar m\u00e9todos siempre y cuando no sean null. Las primitivas de datos no tienen m\u00e9todos. En el siguiente ejemplo, es posible llamar al m\u00e9todo length() desde la variable texto porque texto es una variable de referencia. Se puede saber que length es un m\u00e9todo ya que utiliza (). En la siguiente l\u00ednea, cuando se intenta llamar al m\u00e9todo length() sobre longitud , que es de tipo int (primitiva de datos), aparecer\u00e1 un error de compilaci\u00f3n, ya que las primitivas de tipo int no tienen una longitud definida. String texto = \u201chola\u201d; int longitud = texto.length(); int mal = longitud.length(); //NO COMPILA Por \u00faltimo cabe destacar que las primitivas de datos est\u00e1n escritas en el lenguaje comenzando con letra min\u00fasucla, mientras que las clases, siempre comienzan con letra may\u00fascula.","title":"3.5.3. Diferencias clave"},{"location":"bloques_basicos/#36-declarando-e-inicializando-variables","text":"Hasta ahora se han visto ya numerosas variables. Una variable es, en realidad, un espacio de memoria donde se guardan datos. Cuando se declara una variable, es necesario especificar tanto su nombre como su tipo de dato. Por ejemplo, el siguiente c\u00f3digo declara dos variables. Una es llamada zooName y es de tipo String. La otra es llamada numberAnimals y es de tipo int. String zooName; int numberAnimals; Ahora que se han declarados las variables, es posible asignarles valores; es decir, es posible inicializar las variables. Para inicializar una variable, es necesario escribir el nombre de la variable seguido del car\u00e1cter =, seguido del valor a inicializar: zooName = \"El mejor Zoo\"; numberAnimals = 100; Tambi\u00e9n es posible declarar e inicializar las variables en la misma l\u00ednea: String zooName = \" El mejor Zoo \"; int numberAnimals = 100;","title":"3.6. Declarando e inicializando variables"},{"location":"bloques_basicos/#361-declarar-multiples-variables","text":"Tambi\u00e9n es posible declarar e inicializar varias variables en la misma l\u00ednea. Por ejemplo, \u00bfCu\u00e1ntas variables se han declarado e inicializado en las siguientes dos l\u00edneas? String s1, s2; String s3 = \"yes\", s4 = \"no\"; La respuesta es cuatro variables de tipo String : s1, s2, s3 y s4. Es posible declarar tantas variables como se desee seguidas siempre y cuando estas pertenezcan al mismo tipo de dato. Tambi\u00e9n es posible inicializar estas variables en la misma l\u00ednea (todas, varias, o lo que se desee). En el ejemplo anterior, las variables s3 y s4 est\u00e1n inicializadas, pero las variables s1 y s2 est\u00e1n \u00fanicamente declaradas. Un ejemplo algo m\u00e1s complejo: int i1, i2, i3 = 0; En este caso se han declarado tres variables: i1 , i2 e i3 , pero \u00fanicamente i3 ha sido inicializada con el valor 0. Es necesario tener en cuenta que, por cada \u201c , \u201d, hay una variable diferente cuya inicializaci\u00f3n es independiente a las dem\u00e1s. El c\u00f3digo siguiente, por ejemplo, no compilar\u00eda, ya que no es posible declarar en la misma sentencia variables de tipos de dato diferente: int num, String value; // NO COMPILA Por \u00faltimo, se ver\u00e1 el siguiente ejemplo, \u00bfCu\u00e1les de las siguientes l\u00edneas ser\u00edan v\u00e1lidas y cu\u00e1les no compilar\u00edan? 1: boolean b1, b2; 2: String s1 = \"1\", s2; 3: double d1, double d2; 4: int i1; int i2; 5: int i3; i4; La l\u00ednea 1 es correcta. Declara dos variables de tipo boolean sin inicializar. La l\u00ednea 2 tambi\u00e9n es correcta, ya que declara dos variables de tipo String e inicializa la primera de ellas con el valor \u201c1\u201d. La tercera l\u00ednea no es correcta. Java no permite declarar dos variables de diferente tipo en la misma sentencia, y, a pesar de que en este caso ambas variables ser\u00edan de tipo double , si se quieren declarar dos variables de mismo tipo en la misma l\u00ednea, estas deben compartir la misma declaraci\u00f3n del tipo de dato, y no repetirlo. La l\u00ednea 4 tambi\u00e9n es correcta, y es que, aunque pueda parecer un caso igual al anterior, no es as\u00ed, ya que la l\u00ednea cuatro muestra dos sentencias en la misma l\u00ednea (separadas por \u201c;\u201d). La l\u00ednea 5 no es correcta, ya que, de nuevo, presenta dos sentencias, y la segunda de ella no tiene el tipo de dato necesario para declarar la variable i4 . Esto ser\u00eda como escribir: int i3; i4; //NO COMPILA","title":"3.6.1. Declarar m\u00faltiples variables"},{"location":"bloques_basicos/#362-identificadores","text":"Probablemente no sorprenda que Java tenga reglas precisas sobre nombres de identificadores. Afortunadamente, las mismas reglas para los identificadores se aplican a cualquier cosa que puedas nombrar, incluyendo variables, m\u00e9todos, clases y campos. S\u00f3lo hay tres reglas a recordar para los identificadores legales: El nombre debe comenzar con una letra o el s\u00edmbolo $ o _. Los caracteres posteriores tambi\u00e9n pueden ser n\u00fameros. No se puede usar el mismo nombre que una palabra reservada de Java. Una palabra reservada es una palabra clave que Java ha reservado para que no se le permita utilizarla. Recordar que Java distingue entre may\u00fasculas y min\u00fasculas, por lo que se puede utilizar versiones de las palabras clave que s\u00f3lo difieren en may\u00fasculas y min\u00fasculas, aunque es aconsejable no hacerlo. No hay que preocuparse, no se necesitar\u00e1 memorizar la lista completa de palabras reservadas. La siguiente lista es una lista de todas las palabras reservadas en Java. const y goto no se utilizan realmente en Java. Est\u00e1n reservados para que las personas que vienen de otros idiomas no los usen por accidente y en teor\u00eda, en caso de que Java quiera usarlos alg\u00fan d\u00eda. Lista de palabras resevadas de Java abstract assert boolean break byte case catch char class const continue default do double else enum extends enum extends false float for goto* if implements import instanceof int interface long native new null package private protected public return short static strictfp super switch synchronized this throw throws transient true try void volatile while Los siguientes ejemplos son legales: okidentifier $OK2Identifier _alsoOK1d3ntifi3r __SStillOkbutKnotsonice$ Estos ejemplos no son legales: 3DPointClass // Los identificadores no pueden comenzar por un n\u00famero hollywood@vine // @ no es una letra, d\u00edgito, $ o _ *$coffee // * no es una letra, d\u00edgito, $ o _ public // public es una palabra reservada Aunque se puede hacer locuras con nombres de identificaci\u00f3n, no se deber\u00eda. Java tiene convenciones para que el c\u00f3digo sea legible y consistente. Esta consistencia incluye CamelCase. En CamelCase, cada palabra comienza con una letra may\u00fascula. Esto facilita la lectura de nombres de variables de m\u00e1s de una palabra. \u00bfQu\u00e9 ser\u00eda m\u00e1s legible: thisismyclass name o ThisIsMyClass name? Cuando aparezca un identificador no est\u00e1ndar, hay que asegurarse de verificar si es legal.","title":"3.6.2. Identificadores"},{"location":"bloques_basicos/#identificadores-en-el-mundo-real","text":"La mayor\u00eda de los desarrolladores siguen estas convenciones para identificar nombres: Los nombres de m\u00e9todos y variables comienzan con una letra min\u00fascula seguida de CamelCase. Los nombres de las clases comienzan con una letra may\u00fascula seguida de CamelCase. No se deben usar identificadores con $. El compilador usa este s\u00edmbolo para algunos archivos. Adem\u00e1s, las letras v\u00e1lidas en Java no son s\u00f3lo caracteres del alfabeto ingl\u00e9s. Java soporta el conjunto de caracteres Unicode, por lo que hay m\u00e1s de 45.000 caracteres que pueden iniciar un identificador Java legal. Unos pocos centenares m\u00e1s son n\u00fameros no \u00e1rabes que pueden aparecer despu\u00e9s del primer car\u00e1cter en un identificador v\u00e1lido.","title":"Identificadores en el mundo real"},{"location":"bloques_basicos/#37-comprension-de-la-inicializacion-por-defecto-de-las-variables","text":"Antes de poder utilizar una variable, necesita un valor. Algunos tipos de variables obtienen este valor autom\u00e1ticamente y otras requieren que el programador lo especifique. En las siguientes secciones, se ver\u00e1n las diferencias entre los valores predeterminados para las variables locales, de instancia y de clase.","title":"3.7. Comprensi\u00f3n de la inicializaci\u00f3n por defecto de las variables"},{"location":"bloques_basicos/#371-variables-locales","text":"Una variable local es una variable definida dentro de un m\u00e9todo. Las variables locales deben ser inicializadas antes de su uso. No tienen un valor por defecto y contienen datos basura hasta que se inicializan. El compilador no le permitir\u00e1 leer un valor sin inicializar. Por ejemplo, el siguiente c\u00f3digo genera un error de compilaci\u00f3n: 4: public int notValid() { 5: int y = 10; 6: int x; 7: int reply = x + y; // DOES NOT COMPILE 8: return reply; 9: } y se inicializa a 10. Sin embargo, debido a que x no se inicializa antes de ser utilizado en la expresi\u00f3n de la l\u00ednea 7, el compilador genera el error de seguimiento: Test.java:5: variable x might not have been initialized int reply = x + y; ^ Hasta que a x no se le asigne un valor, no puede aparecer dentro de una expresi\u00f3n, y el compilador le recordar\u00e1 esta regla. El compilador sabe que su c\u00f3digo tiene el control de lo que sucede dentro del m\u00e9todo y puede esperar que inicialice los valores. El compilador es lo suficientemente inteligente como para reconocer variables que han sido inicializadas despu\u00e9s de su declaraci\u00f3n, pero antes de ser usadas. Aqu\u00ed hay un ejemplo: public int valid() { int y = 10; int x; // x is declared here x = 3; // and initialized here int reply = x + y; return reply; } El compilador tambi\u00e9n es lo suficientemente inteligente como para reconocer inicializaciones m\u00e1s complejas. En este ejemplo, hay dos ramas de c\u00f3digo y answer se inicializa en ambas. onlyOneBranch s\u00f3lo se inicializa si check es verdadero. El compilador sabe que existe la posibilidad de que check sea falso y de que por lo tanto onlyOneBranch no se inicialice nunca, por lo que en el c\u00f3digo hay un error de compilaci\u00f3n. Se aprender\u00e1 m\u00e1s sobre la declaraci\u00f3n if en el pr\u00f3ximo cap\u00edtulo. public void findAnswer(boolean check) { int answer; int onlyOneBranch; if(check) { onlyOneBranch = 1; answer = 1; } else { answer = 2; } System.out.println(answer);","title":"3.7.1. Variables locales"},{"location":"bloques_basicos/#372-variables-de-clase-e-instancia","text":"Las variables que no son variables locales se conocen como variables de instancia o variables de clase. Las variables de instancia tambi\u00e9n se denominan fields. Las variables de clase se comparten entre varios objetos. Se puede decir que una variable es una variable de clase porque tiene la palabra clave static delante de ella. Se encontrar\u00e1 m\u00e1s informaci\u00f3n al respecto en el cap\u00edtulo 4. Por ahora, s\u00f3lo se debe saber que una variable es una variable de clase si tiene la palabra clave static en su declaraci\u00f3n. Las variables de instancia y clase no requieren ser inicializadas. Tipo de variable Valor por defecto de inicializaci\u00f3n boolean false byte, short, int, long 0 (en la longitud de bits del tipo) float, double 0.0 (en la longitud de bits del tipo) char \u2018\\u0000\u2019 (NUL) Todas las referencias a objetos Null","title":"3.7.2. Variables de clase e instancia"},{"location":"bloques_basicos/#38-entendiendo-el-ambito-de-las-variables","text":"Se ha aprendido que las variables locales se declaran dentro de un m\u00e9todo. \u00bfCu\u00e1ntas variables locales se ven en este ejemplo? public void eat(int piecesOfCheese) { int bitesOfCheese = 1; } Hay dos variables locales en este m\u00e9todo. bitesOfCheese se declara dentro del m\u00e9todo. piecesOfCheese se llama par\u00e1metro de m\u00e9todo. Tambi\u00e9n es local al m\u00e9todo. Se dice que ambas variables tienen un alcance local al m\u00e9todo. Esto significa que no se pueden utilizar fuera del m\u00e9todo. Las variables locales nunca pueden tener un alcance mayor que el m\u00e9todo definido. Sin embargo, pueden tener un alcance menor. Ejemplo: 3: public void eatIfHungry(boolean hungry) { 4: if (hungry) { 5: int bitesOfCheese = 1; 6: } // bitesOfCheese goes out of scope here 7: System.out.println(bitesOfCheese);// NO COMPILA 8: } System.out.println(onlyOneBranch); // DOES NOT COMPILE } hungry tiene un alcance de todo el m\u00e9todo. bitesOfCheese tiene un alcance m\u00e1s peque\u00f1o. S\u00f3lo est\u00e1 disponible para su uso en la sentencia if porque se declara dentro de ella. Cuando se vea un juego de llaves ({ }) en el c\u00f3digo, significa que se ha introducido un nuevo bloque de c\u00f3digo. Cada bloque de c\u00f3digo tiene su propio alcance. Cuando hay bloques m\u00faltiples, se emparejan de dentro hacia fuera. En este caso, el bloque de sentencia if comienza en la l\u00ednea 4 y termina en la l\u00ednea 6. El bloque del m\u00e9todo comienza en la l\u00ednea 3 y termina en la l\u00ednea 8. Dado que bitesOfCheese se declara en tal bloque, el \u00e1mbito de aplicaci\u00f3n se limita a dicho bloque. Cuando el compilador llega a la l\u00ednea 7, muestra que no sabe nada sobre bitesOfCheese y da un error: bitesOfCheese cannot be resolved to a variable Recordar que los bloques pueden contener otros bloques. Estos bloques m\u00e1s peque\u00f1os contenidos pueden referenciar variables definidas en los bloques de mayor tama\u00f1o, pero no viceversa. Por ejemplo: 16: public void eatIfHungry(boolean hungry) { 17: if (hungry) { 18: int bitesOfCheese = 1; 19: { 20: boolean teenyBit = true; 21: System.out.println(bitesOfCheese); 22: } 23: } 24: System.out.println(teenyBit); // NO COMPILA 25: } La variable definida en la l\u00ednea 18 est\u00e1 en alcance hasta que el bloque termina en la l\u00ednea 23. Usarlo en el bloque m\u00e1s peque\u00f1o de las l\u00edneas 19 a 22 es seguro. La variable definida en la l\u00ednea 20 queda fuera del alcance en la l\u00ednea 22. No est\u00e1 permitido su uso en la l\u00ednea 24. No hay que preocuparse si a\u00fan no se est\u00e1 familiarizado con las declaraciones o los bucles. No importa lo que haga el c\u00f3digo, ya que se est\u00e1 hablando del alcance. A continuaci\u00f3n, se intentar\u00e1 determinar, en qu\u00e9 l\u00ednea, cada una de las variables locales entra y sale del alcance: 11: public void eatMore(boolean hungry, int amountOfFood) { 12: int roomInBelly = 5; 13: if (hungry) { 14: boolean timeToEat = true; 15: while (amountOfFood > 0) { 16: int amountEaten = 2; 17: roomInBelly = roomInBelly - amountEaten; 18: amountOfFood = amountOfFood - amountEaten; 19: } 20: } 21: System.out.println(amountOfFood); 22: } El primer paso para determinar el alcance es identificar los bloques de c\u00f3digo. En este caso, hay tres bloques. Se puede decir esto porque hay tres juegos de llaves. Partiendo del conjunto m\u00e1s interno, se puede ver d\u00f3nde comienza y termina el bloque del bucle while. Se repetir\u00e1 esto mientras se sale, para el bloque de sentencia if y el bloque de m\u00e9todo. La Tabla 1.3 muestra los n\u00fameros de l\u00ednea que cada bloque comienza y termina. Bloque Primera l\u00ednea del bloque Ultima l\u00ednea del bloque while 15 19 if 13 20 method 11 22 Se necesitar\u00e1 practicar mucho esto. La identificaci\u00f3n de bloques debe ser algo natural. La buena noticia es que hay muchos ejemplos de c\u00f3digos para practicar. Ahora que se sabe d\u00f3nde est\u00e1n los bloques, se puede ver el alcance de cada variable. hungry y amountOfFood son par\u00e1metros de m\u00e9todo, por lo que est\u00e1n disponibles para todo el m\u00e9todo. Esto significa que su \u00e1mbito de aplicaci\u00f3n son las l\u00edneas 11 a 22. roomInBelly entra en el \u00e1mbito de aplicaci\u00f3n de la l\u00ednea 12 porque ah\u00ed es donde se declara. Se mantiene en el alcance para el resto del m\u00e9todo y por lo tanto se sale del alcance en la l\u00ednea 22. timeToEat entra en el alcance en la l\u00ednea 14 donde se declara. Se sale del alcance en la l\u00ednea 20 donde termina el bloque if. amountEaten entra en el \u00e1mbito de aplicaci\u00f3n de la l\u00ednea 16 donde se declara. Se sale del alcance en la l\u00ednea 19 donde termina el bloque de tiempo. Todo eso era para variables locales. Afortunadamente, las reglas para las variables de instancia son m\u00e1s f\u00e1ciles: est\u00e1n disponibles tan pronto como se definen y duran toda la vida \u00fatil del objeto en s\u00ed. La regla para las variables de clase (static) es a\u00fan m\u00e1s f\u00e1cil: entran en alcance cuando se declaran como los otros tipos de variables. Sin embargo, permanecen en el alcance durante toda la vida del programa. A continuaci\u00f3n, se har\u00e1 un ejemplo m\u00e1s para asegurarse de que se tiene control sobre esto. Una vez m\u00e1s, se debe averiguar el tipo de las cuatro variables y cu\u00e1ndo entran y salen del alcance. 1: public class Mouse { 2: static int MAX_LENGTH = 5; 3: int length; 4: public void grow(int inches) { 5: if (length < MAX_LENGTH) { 6: int newSize = length + inches; 7: length = newSize; 8: } 9: } 10:} En esta clase, se tiene una variable de clase (MAX_LENGTH), una variable de instancia (length) y dos variables locales (inches y newSize.) MAX_LENGTH es una variable de clase porque tiene la palabra clave static en su declaraci\u00f3n. MAX_LENGTH entra en el \u00e1mbito de aplicaci\u00f3n de la l\u00ednea 2 donde se declara. Permanece en el alcance hasta que finaliza el programa. Length entra en el \u00e1mbito de la aplicaci\u00f3n en la l\u00ednea 3, donde se declara. Permanece en el alcance mientras el objeto Mouse exista. inches entra en alcance donde se declara en la l\u00ednea 4. Se sale del alcance al final del m\u00e9todo en la l\u00ednea 9. newSize entra en el alcance donde se declara en la l\u00ednea 6. Dado que est\u00e1 definido dentro del bloque de sentencia if, se sale del alcance cuando ese bloque termina en la l\u00ednea 8. \u00bfSe ha resuelto todo? Ahora, se revisar\u00e1n las reglas sobre el alcance: Variables locales: en el \u00e1mbito de aplicaci\u00f3n desde la declaraci\u00f3n hasta el final del bloque Variables de instancia: en el \u00e1mbito de aplicaci\u00f3n de la declaraci\u00f3n hasta que se recoge la basura del objeto. Variables de clase: en el \u00e1mbito de aplicaci\u00f3n de la declaraci\u00f3n hasta que finalice el programa.","title":"3.8. Entendiendo el \u00e1mbito de las variables"},{"location":"bloques_basicos/#39-ordenando-elementos-en-una-clase","text":"Ahora que se ha visto las partes m\u00e1s comunes de una clase, se echar\u00e1 un vistazo al orden correcto para escribirlas en un archivo. Los comentarios pueden ir en cualquier parte del c\u00f3digo. M\u00e1s all\u00e1 de eso, es necesario memorizar las reglas en la tabla siguiente: Elemento Ejemplo \u00bfNecesario? \u00bfD\u00f3nde va? Declaraci\u00f3n de paquete package abc; No Primera l\u00ednea del archivo Sentencias de importaci\u00f3n import java.util*; No Inmediatamente despu\u00e9s del paquete Declaraci\u00f3n de clase public class C Si Inmediatamente despu\u00e9s de la importaci\u00f3n Declaraci\u00f3n de campos int value; No Cualquier lugar dentro de la clase Declaraci\u00f3n de m\u00e9todos void method() No Cualquier lugar dentro de la clase Se ver\u00e1n algunos ejemplos para ayudar a recordar esto. El primer ejemplo contiene uno de cada elemento: package structure; // package must be first non-comment import java.util.*; // import must come after package public class Meerkat { // then comes the class double weight; // fields and methods can go in either order public double getWeight() { return weight; } double height; // another field \u2013 they don't need to be together } Hasta ahora todo bien. Este es un patr\u00f3n com\u00fan que se debe conocer. V\u00e9ase otro ejemplo: /* header */ package structure; // class Meerkat public class Meerkat { } Sigue siendo bueno. Se puede poner comentarios en cualquier lugar, y las importaciones son opcionales. En el siguiente ejemplo, hay un problema: import java.util.*; package structure; // DOES NOT COMPILE String name; // DOES NOT COMPILE public class Meerkat { } Hay dos problemas aqu\u00ed. Una es que el paquete y las declaraciones de importaci\u00f3n se anulan. Aunque ambos son opcionales, el paquete debe llegar antes de la importaci\u00f3n si est\u00e1 presente. La otra cuesti\u00f3n es que un campo intenta la declaraci\u00f3n fuera de una clase. Esto no est\u00e1 permitido. Los campos y m\u00e9todos deben estar dentro de una clase. \u00bfSe tiene todo? Un consejo, se debe recordar el acr\u00f3nimo PIC (picture): package, import y class. Los campos y m\u00e9todos son m\u00e1s f\u00e1ciles de recordar porque simplemente tienen que estar dentro de una clase. Se pueden definir varias clases en el mismo archivo, pero s\u00f3lo una de ellas puede ser p\u00fablica. La clase p\u00fablica coincide con el nombre del archivo. Por ejemplo, estas dos clases deben estar en un archivo llamado Meerkat. java: 1: public class Meerkat { } 2: class Paw { } En un archivo tambi\u00e9n se permite que ninguna de las clases sea p\u00fablica. Mientras no haya m\u00e1s de una clase p\u00fablica en un archivo, est\u00e1 bien.","title":"3.9. Ordenando elementos en una clase"},{"location":"bloques_basicos/#310-destruyendo-objetos","text":"Ahora que se ha trabajado con objetos, es hora de deshacerse de ellos. Por suerte, Java se encarga autom\u00e1ticamente de esto, proporcionando una herramienta llamada Garbage Collector (\u201crecolector de basura\u201d), el cual busca autom\u00e1ticamente objetos que ya no est\u00e1n en uso. Todos los objetos Java se almacenan en la memoria del programa, siendo el heap un gran grupo de memoria no utilizada asignada a una aplicaci\u00f3n Java. El heap puede ser bastante grande dependiendo del entorno, pero siempre tiene un l\u00edmite de tama\u00f1o. Si el programa sigue instanciando objetos y dej\u00e1ndolos en el heap , llegar\u00e1 un momento en el que se quedar\u00e1 sin memoria. En las siguientes secciones se ver\u00e1 la Garbage Collection o \"recolecci\u00f3n de basura\" y el m\u00e9todo finalize().","title":"3.10. Destruyendo Objetos"},{"location":"bloques_basicos/#3101-garbage-collection","text":"El concepto Garbage Collection en Java hace referencia al proceso de liberar autom\u00e1ticamente la memoria en el heap borrando objetos que ya no son accesibles en un programa; es decir, objetos que han quedado desreferenciados. Existen muchos algoritmos diferentes para la Garbage Collection, pero no es necesario conocer ninguno de ellos. S\u00ed que es necesario; no obstante, familiarizarse con el m\u00e9todo System.gc(), la cual ejecuta el Garbage Collector, recogiendo aquellos objetos ya no referenciados en el c\u00f3digo. El m\u00e9todo System.gc() no siempre puede ejecutar el Garbage Collector, sino que realmente, a pesar de que s\u00ed se le ordena a Java que lleve a cabo esta acci\u00f3n, esta podr\u00eda ser ignorada. La parte m\u00e1s interesante de la Garbage Collection es cuando la memoria perteneciente a un objeto ya desreferenciado es recuperada. Java es capaz de detectar cu\u00e1ndo un objeto ya no es utilizado en ninguna parte del c\u00f3digo. Esto puede darse en dos situaciones: El objeto ya no tiene referencias que lo apunten. Todas las referencias al objeto est\u00e1n fuera de \u00e1mbito. S","title":"3.10.1. Garbage Collection"},{"location":"bloques_basicos/#objetos-vs-referencias","text":"No debe confundirse una referencia con el objeto al que se refiere; son dos entidades diferentes. La referencia es una variable que tiene un nombre y se puede utilizar para acceder al contenido de un objeto. Se puede asignar una referencia a otra referencia, pasarla a un m\u00e9todo o devolverla desde un m\u00e9todo. Todas las referencias son del mismo tama\u00f1o, independientemente de su tipo. Un objeto se deposita en el heap y no tiene nombre. Por lo tanto, no hay manera de acceder a un objeto excepto a trav\u00e9s de una referencia. Los objetos vienen en todas las formas y tama\u00f1os diferentes y consumen cantidades variables de memoria. Un objeto no se puede asignar a otro objeto, ni tampoco se puede pasar un objeto a un m\u00e9todo o devolverlo desde un m\u00e9todo. Es el objeto quien recibe el Garbage Collection, no su referencia. Comprender la diferencia entre una referencia y un objeto ayuda mucho a entender la Garbage Collection, el operador new y muchas otras facetas del lenguaje Java. Observando el siguiente c\u00f3digo se puede ver cu\u00e1ndo un objeto es elegible para ser recolectado por el Garbage Collector: 1: public class Scope { 2: public static void main(String[] args) { 3: String one, two; 4: one = new String(\"a\"); 5: two = new String(\"b\"); 6: one = two; 7: String three = one; 8: one = null; 9: } } A la hora de llevar a cabo una traza del c\u00f3digo es posible cometer errores, por lo que habr\u00e1 que prestar especial atenci\u00f3n. En la l\u00ednea 3 se crean dos variables: one y two. S\u00f3lo las variables, que son referencias que no apuntan todav\u00eda a nada. No hay necesidad de dibujar cajas o flechas que ayuden a comprender el c\u00f3digo, ya que no hay objetos en el heap todav\u00eda. En la l\u00ednea 4 se crea el primer objeto. Se dibujar\u00e1 una caja con la cadena \"a\" dentro y luego una flecha de la palabra one a esa caja. La l\u00ednea 5 es similar. Se dibujar\u00e1 otra caja con la cadena \"b\" en ella esta vez y una flecha desde la palabra two. En este punto, el esquema deber\u00eda verse como la figura siguiente. En la l\u00ednea 6, la variable one cambia a \"b\". Se borrar\u00e1 la flecha de one y se dibujar\u00e1 una nueva flecha de one a \"b\". En la l\u00ednea 7, se tiene una nueva variable, as\u00ed que se escribir\u00e1 la palabra three y se dibujar\u00e1 una flecha de three a \"b\". Existen tres variables que se\u00f1alan a \"b\" en este momento, y ninguna que se\u00f1ale a \"a\". Finalmente habr\u00eda que eliminar la flecha entre one y \"b\", ya que la l\u00ednea 8 establece esta variable como nula. Este seguimiento pretend\u00eda encontrar cu\u00e1ndo los objetos eran elegibles para ser recolectados por el Garbage Collector. En la l\u00ednea 6 se elimin\u00f3 la \u00fanica referencia que apuntaba a \"a\", haciendo que ese objeto fuera apto para el Garbage Collector. \"B\" tiene referencias apuntando hacia \u00e9l hasta que sale del \u00e1mbito del c\u00f3digo. Esto significa que \"b\" no es escogido por el GC hasta el final del m\u00e9todo en la l\u00ednea 9.","title":"Objetos vs Referencias"},{"location":"bloques_basicos/#3102-finalize","text":"Java permite a los objetos implementar un m\u00e9todo llamado finalize(). Este m\u00e9todo se llama si el Garbage Collector intenta recoger el objeto. Si el Grabage Collector no se ejecuta, el m\u00e9todo no es llamado nunca. Si el Garbage Collector no puede recoger el objeto e intenta ejecutarse de nuevo m\u00e1s tarde, el m\u00e9todo no se vuelve a llamar por segunda vez. En la pr\u00e1ctica, esto significa que es muy poco probable que se utilice en proyectos reales. S\u00f3lo hay que tener en cuenta que puede que no se llame y que definitivamente no ser\u00e1 llamado dos veces. Dicho esto, esta llamada no produce ninguna salida cuando la ejecutamos: public class Finalizer { protected void finalize() { System.out.println(\"Calling finalize\"); } public static void main(String[] args) { Finalizer f = new Finalizer(); } } La raz\u00f3n es que el programa termina antes de que exista la necesidad de ejecutar el Garbage Collector. A pesar de que f es elegible para la Garbage Collection, Java no ejecuta el Garbage Collector constantemente. Ahora un ejemplo m\u00e1s interesante: public class Finalizer { private static List objects = new ArrayList(); protected void finalize() { objects.add(this); // Don't do this } } Es preciso recordar que finalize() s\u00f3lo se ejecuta cuando el objeto es elegible para el Garbage Collector. El problema aqu\u00ed es que al final del m\u00e9todo, el objeto ya no es elegible para el Garbage Collector porque una variable est\u00e1tica hace referencia a \u00e9l, y las variables est\u00e1ticas pertenecen al \u00e1mbito de la aplicaci\u00f3n hasta que el programa termina. Java es lo suficientemente inteligente como para darse cuenta de esto y aborta el intento de eliminar el objeto. Ahora sup\u00f3ngase que m\u00e1s tarde, en el programa, los objetos toman el valor de cero. Finalmente, se puede eliminar el objeto de la memoria. Java recuerda que ya se ha ejecutado finalize (en este objeto), y no lo har\u00e1 de nuevo.","title":"3.10.2. finalize()"},{"location":"bloques_basicos/#311-beneficios-de-java","text":"Java tiene algunos beneficios clave que se necesitar\u00e1 conocer:","title":"3.11. Beneficios de Java"},{"location":"bloques_basicos/#orientado-a-objetos","text":"Java es un lenguaje orientado a objetos, lo que significa que todo el c\u00f3digo se define en clases y la mayor\u00eda de esas clases pueden ser instanciadas en objetos. Muchos idiomas antes de Java eran procedurales, lo que significaba que hab\u00eda rutinas o m\u00e9todos, pero no hab\u00eda clases. Otro enfoque com\u00fan es la programaci\u00f3n funcional. Java permite la programaci\u00f3n funcional dentro de una clase, pero el objeto orientado sigue siendo la organizaci\u00f3n principal del c\u00f3digo.","title":"Orientado a Objetos:"},{"location":"bloques_basicos/#encapsulamiento","text":"Java soporta modificadores de acceso para proteger los datos de accesos y modificaciones no deseados. Se considera que la encapsulaci\u00f3n es un aspecto de los lenguajes orientados a objetos.","title":"Encapsulamiento :"},{"location":"bloques_basicos/#plataforma-independiente","text":"Java es un lenguaje interpretado porque se compila en bytecode. Una ventaja clave es que el c\u00f3digo Java se compila una vez en lugar de tener que ser recompilado para diferentes sistemas operativos. Esto se conoce como \"write once, run everywhere\u201d.","title":"Plataforma Independiente :"},{"location":"bloques_basicos/#robusto","text":"Una de las principales ventajas de Java sobre C++ es que previene las fugas de memoria. Java maneja la memoria por su cuenta y ejecuta el Garbage Collector autom\u00e1ticamente. La mala gesti\u00f3n de la memoria en C++ es una gran fuente de errores en los programas.","title":"Robusto:"},{"location":"bloques_basicos/#simple","text":"Java pretend\u00eda ser m\u00e1s simple que C++. Adem\u00e1s de eliminar los punteros, elimin\u00f3 la sobrecarga del operador. En C++, se podr\u00eda escribir a + b y hacer que signifique casi cualquier cosa.","title":"Simple:"},{"location":"bloques_basicos/#seguro","text":"El c\u00f3digo Java se ejecuta dentro del JVM. Esto crea una sandbox que dificulta que el c\u00f3digo Java lleve a cabo acciones maliciosas en el ordenador en el que se est\u00e1 ejecutando.","title":"Seguro:"},{"location":"bloques_basicos/#312-resumen","text":"En este cap\u00edtulo, se ha visto que: Estructura de las clases Java Las clases Java consisten en miembros llamados campos y m\u00e9todos. Un objeto es una instancia de una clase Java. Hay tres estilos de comentario: un comentario de una sola l\u00ednea (//), un comentario de varias l\u00edneas (/ /), y un comentario Javadoc (/* /). M\u00e9todo main Java inicia la ejecuci\u00f3n del programa con un m\u00e9todo main(). La cabecera m\u00e1s com\u00fan para este m\u00e9todo se ejecuta desde la l\u00ednea de comandos: public static void main (String[] args). Los argumentos se pasan despu\u00e9s del nombre de la clase, como en java NameOfClass firstArgument. - Los argumentos son indexados comenzando con 0. Paquetes e importaciones El c\u00f3digo Java est\u00e1 organizado en carpetas llamadas paquetes. Para hacer referencia a clases en otros paquetes, se utilizar\u00e1 una declaraci\u00f3n de importaci\u00f3n. El car\u00e1cter * al final de una sentencia de importaci\u00f3n significa que desea importar todas las clases en ese paquete. No incluye paquetes que est\u00e9n dentro de ese paquete. - - - java. lang es un paquete especial que no necesita ser importado. Crear objetos Java Los constructores crean objetos Java. Un constructor es un m\u00e9todo que corresponde al nombre de la clase y omite el tipo de devoluci\u00f3n. Cuando un objeto es instanciado, los bloques de c\u00f3digo se inicializan primero. Una vez inicializados, se puede hacer uso de los constructores. Referencias a objetos y primitivas de datos Los tipos primitivos son los bloques b\u00e1sicos de construcci\u00f3n de los tipos Java. Se montan en tipos de referencia. Las clases de referencia pueden tener m\u00e9todos y asignarse a nulo. Adem\u00e1s de los n\u00fameros \"normales\", se permite que los literales num\u00e9ricos comiencen con 0 (octal), 0x (hex), 0X (hex), 0b (binario), o 0B (binario). Los literales num\u00e9ricos tambi\u00e9n pueden contener guiones bajos siempre y cuando est\u00e9n directamente entre otros dos n\u00fameros. Declarar e inicializar variables Declarar una variable implica indicar el tipo de datos y darle un nombre a la variable. Las variables que representan campos en una clase se inicializan autom\u00e1ticamente a su correspondiente valor cero o nulo durante la instanciaci\u00f3n del objeto. Las variables locales deben ser inicializadas espec\u00edficamente. Los identificadores pueden contener letras, n\u00fameros, $ o _. Los identificadores no pueden comenzar con n\u00fameros. El \u00e1mbito de aplicaci\u00f3n se refiere a la parte del c\u00f3digo en la que se puede acceder a una variable. Hay tres tipos de variables en Java, dependiendo de su alcance: variables de instancia, variables de clase y variables locales. Las variables de instancia son los campos no est\u00e1ticos de su clase. Las variables de clase son los campos est\u00e1ticos dentro de una clase. Las variables locales se declaran dentro de un m\u00e9todo. Ordenando elementos de una clase Para algunos elementos de la clase, el orden importa dentro del c\u00f3digo. La declaraci\u00f3n del paquete viene primero si est\u00e1 presente. Luego vienen las declaraciones de importaci\u00f3n si est\u00e1n presentes. Luego viene la declaraci\u00f3n de clase. Los campos y m\u00e9todos pueden estar en cualquier orden dentro de la clase. Destruyendo objetos El Garbage Collector es el responsable de retirar objetos de la memoria cuando no se pueden volver a utilizar. Un objeto se convierte en elegible para el Garbage Collector cuando no hay m\u00e1s referencias a \u00e9l o sus referencias han salido del alcance. - El m\u00e9todo finalize() se ejecutar\u00e1 una vez para cada objeto cuando es ejecutado el Garbage Collector.","title":"3.12. Resumen"},{"location":"dise%C3%B1o_clases/","text":"","title":"Dise\u00f1o de clases"},{"location":"entorno/","text":"2. Entorno de desarrollo 2.1. Instalaci\u00f3n del JDK (Java Development Kit) En primer lugar se deber\u00e1 comprobar si el JDK ya est\u00e1 instalado en el equipo. Para ello, se deber\u00e1 escribir lo siguiente en la l\u00ednea de comandos: java -version En caso de tener el JDK instalado, se podr\u00e1 ver como resultado del comando algo similar a lo que se muestra en la siguiente imagen y se podr\u00e1 continuar con la instalaci\u00f3n del entorno de desarrollo Eclipse. En caso de no tener instalado el JDK, se deber\u00e1n seguir los siguientes pasos: Se deber\u00e1 descargar el JDK desde la siguiente URL: Link-Oracle Se a\u00f1adir\u00e1 el ejecutable de Java que se acaba de descargar al PATH del sistema, para ello: Se accede a la siguiente ubicaci\u00f3n del pc \u201cPanel de control\\Todos los elementos de Panel de control\\Sistema\u201d . A continuaci\u00f3n, se accede a \u201cConfiguraci\u00f3n avanzada del sistema\u201d , \u201cVariables de entorno\u201d . Es posible que se haya a\u00f1adido el JDK de manera autom\u00e1tica al equipo, por lo que se deber\u00e1 comprobar haciendo clic sobre \"Path\" ( que est\u00e1 seleccionado en la imagen ), y despu\u00e9s sobre \"Editar...\" En la imagen se puede ver que Java est\u00e1 instalado en el sistema, concretamente en \"C:\\ProgramData\\Oracle\\Java\\javapath\" . De no ser as\u00ed, habr\u00e1 que a\u00f1adirlo haciendo clic en \"Nuevo\" . 2.2. Instalaci\u00f3n del entorno de desarrollo Eclipse Se accede a la siguiente URL y se descarga la versi\u00f3n de Eclipse con la que se vaya a trabajar: Link-Eclipse Se descomprime el .zip en el disco D:. Para ejecutar Eclipse hay que hacer doble click en el archivo eclipse.exe que se encuentra dentro de la carpeta. Se puede crear un acceso directo al .exe de la aplicaci\u00f3n y guardarlo en el escritorio para mayor comodidad.","title":"Entorno de desarrollo"},{"location":"entorno/#2-entorno-de-desarrollo","text":"","title":"2. Entorno de desarrollo"},{"location":"entorno/#21-instalacion-del-jdk-java-development-kit","text":"En primer lugar se deber\u00e1 comprobar si el JDK ya est\u00e1 instalado en el equipo. Para ello, se deber\u00e1 escribir lo siguiente en la l\u00ednea de comandos: java -version En caso de tener el JDK instalado, se podr\u00e1 ver como resultado del comando algo similar a lo que se muestra en la siguiente imagen y se podr\u00e1 continuar con la instalaci\u00f3n del entorno de desarrollo Eclipse. En caso de no tener instalado el JDK, se deber\u00e1n seguir los siguientes pasos: Se deber\u00e1 descargar el JDK desde la siguiente URL: Link-Oracle Se a\u00f1adir\u00e1 el ejecutable de Java que se acaba de descargar al PATH del sistema, para ello: Se accede a la siguiente ubicaci\u00f3n del pc \u201cPanel de control\\Todos los elementos de Panel de control\\Sistema\u201d . A continuaci\u00f3n, se accede a \u201cConfiguraci\u00f3n avanzada del sistema\u201d , \u201cVariables de entorno\u201d . Es posible que se haya a\u00f1adido el JDK de manera autom\u00e1tica al equipo, por lo que se deber\u00e1 comprobar haciendo clic sobre \"Path\" ( que est\u00e1 seleccionado en la imagen ), y despu\u00e9s sobre \"Editar...\" En la imagen se puede ver que Java est\u00e1 instalado en el sistema, concretamente en \"C:\\ProgramData\\Oracle\\Java\\javapath\" . De no ser as\u00ed, habr\u00e1 que a\u00f1adirlo haciendo clic en \"Nuevo\" .","title":"2.1. Instalaci\u00f3n del JDK (Java Development Kit)"},{"location":"entorno/#22-instalacion-del-entorno-de-desarrollo-eclipse","text":"Se accede a la siguiente URL y se descarga la versi\u00f3n de Eclipse con la que se vaya a trabajar: Link-Eclipse Se descomprime el .zip en el disco D:. Para ejecutar Eclipse hay que hacer doble click en el archivo eclipse.exe que se encuentra dentro de la carpeta. Se puede crear un acceso directo al .exe de la aplicaci\u00f3n y guardarlo en el escritorio para mayor comodidad.","title":"2.2. Instalaci\u00f3n del entorno de desarrollo Eclipse"},{"location":"excepciones/","text":"","title":"Excepciones"},{"location":"java_intro/","text":"1. Java 1.1. Historia de Java Para hablar de la historia de java, hay que remontarse a los a\u00f1os 80, donde C pod\u00eda considerarse el lenguaje por antonomasia. Era un lenguaje vers\u00e1til, que pod\u00eda actuar a bajo nivel y resolv\u00edan problemas muy complejos. Era la cima de la programaci\u00f3n estructurada, para resolver estos complejos algoritmos, se generaban grandes procedimientos con un c\u00f3digo muy complicado de mantener a largo plazo. Por ello empez\u00f3 a surgir como alternativa la programaci\u00f3n orientada a objetos, y con ella naci\u00f3 C++. El objetivo de java era crear un lenguaje de programaci\u00f3n parecido a C++ en estructura y sintaxis, fuertemente orientado a objetos, pero con una m\u00e1quina virtual propia. Esto se hizo bajo el principio, de poder ser usado bajo cualquier arquitectura \"Write Once, Run Anywhere (escr\u00edbelo una vez, ejec\u00fatalo en cualquier sitio)\". En 1992 se presenta el proyecto, con los prototipos a bajo nivel. Entre 1993 y 1994 se trabaja para poder presentar un prototipo funcional (hotJava) donde se ve todo el potencial que JAVA puede ofrecer En 1995 finalmente, es presentada la versi\u00f3n alpha de java, y un a\u00f1o despu\u00e9s en 1996 es lanzado el primer JDK (JDK 1.0): software que provee herramientas de desarrollo para la creaci\u00f3n de programas en java. El desarrollo de java a partir de entonces es imparable, se van presentando nuevos paquetes y librer\u00edas hasta la actualidad. A d\u00eda de hoy, se puede decir, que Java es uno de los lenguajes m\u00e1s importantes del mundo. Con una comunidad extendida en todos los componentes y m\u00e1s de 4 millones de desarrolladores, existen millones de dispositivos que lo usan. Adem\u00e1s, tras el surgimiento de android, java es establecido como el lenguaje de programaci\u00f3n para m\u00f3viles m\u00e1s extendido del planeta. En las primeras versiones de Java 1.1, 1.2 y 1.3 es donde el lenguaje va tomando forma, con la inclusi\u00f3n de tecnolog\u00edas como JavaBeans, JDBC para el acceso a base de datos, RMI para las invocaciones en remoto, Collections para la gesti\u00f3n de m\u00faltiples estructuras de datos o AWT para el desarrollo gr\u00e1fico, entre otros. Una de las cosas que sucede en noviembre 2006 es que Sun Microsystems lo convierte en Open Source mediante una licencia GNU General Public License (GPL). Dando lugar en mayo de 2008 a lo que se conoce como OpenJDK, con OpenJDK 6. Llegado julio de 2011 ve la luz Java 7, la cual trae como novedades el soporte de lenguajes din\u00e1micos, dotando a la JVM de un soporte de m\u00fatiples lenguajes y una nueva librer\u00eda I/O para el manejo de ficheros. Tambi\u00e9n aparecen cosas menores, pero muy \u00fatiles como el manejo de String, dentro de la validaci\u00f3n en una estructura switch, o la capacidad de poner guiones de subrayado como separadores de miles en los n\u00fameros para facilitar su lectura (p. ej. 1_000_000). La \u00faltima versi\u00f3n de Java distribuida es Java 8, aparecida en marzo de 2014. Entre las caracter\u00edsticas de Java 8 se tiene el soporte para expresiones Lambda y uso de Streams, que permiten un estilo m\u00e1s similar a la programaci\u00f3n funcional para los programas Java. Dentro de este enfoque m\u00e1s cercano a la programaci\u00f3n funcional, tambi\u00e9n aparecen las transformaciones MapReduce. Ve la luz el Proyecto Nashorn para disponer de un engine Javascript y as\u00ed poder incluir este lenguaje dentro de las aplicaciones Java. Otras cosas son un nuevo API Date y Time y la inclusi\u00f3n de JavaFX 8 dentro de la JDK de Java. 1.2. La M\u00e1quina Virtual Java El lenguaje Java es a la vez compilado e interpretado. Con el compilador, se convierte el c\u00f3digo fuente que reside en archivos cuya extensi\u00f3n es .java, a un conjunto de instrucciones que recibe el nombre de bytecodes, que se guardan en un archivo cuya extensi\u00f3n es .class. Estas instrucciones son independientes del tipo de ordenador. El int\u00e9rprete ejecuta cada una de estas instrucciones en un ordenador espec\u00edfico (Windows, Macintosh, etc). Solamente es necesario, por tanto, compilar una vez el programa, pero se interpreta cada vez que se ejecuta en un ordenador. Cada int\u00e9rprete Java es una implementaci\u00f3n de la M\u00e1quina Virtual Java (JVM). Los bytecodes posibilitan el objetivo de \"write once, run anywhere\", de escribir el programa una vez y que se pueda ejecutar en cualquier plataforma que disponga de una implementaci\u00f3n de la JVM. Por ejemplo, el mismo programa Java puede ejecutarse en Windows 98, Solaris, Macintosh, etc. Java es, por tanto, algo m\u00e1s que un lenguaje, ya que la palabra Java se refiere a dos cosas inseparables: el lenguaje que nos sirve para crear programas y la M\u00e1quina Virtual Java que sirve para ejecutarlos. Como se puede ver en la figura, el API de Java y la M\u00e1quina Virtual Java forman una capa intermedia (Java platform) que a\u00edsla el programa Java de las especificidades del hardware (hardware-based platform). La M\u00e1quina Virtual Java (JVM) es el entorno en el que se ejecutan los programas Java. Su misi\u00f3n principal es la de garantizar la portabilidad de las aplicaciones Java. Define esencialmente un ordenador abstracto y especifica las instrucciones (bytecodes) que este ordenador puede ejecutar. El int\u00e9rprete Java espec\u00edfico ejecuta las instrucciones que se guardan en los archivos cuya extensi\u00f3n es .class. Las tareas principales de la JVM son las siguientes: Reservar espacio en memoria para los objetos creados Liberar la memoria no usada (garbage collection) Asignar variables a registros y pilas Llamar al sistema hu\u00e9sped para ciertas funciones, como los accesos a los dispositivos Vigilar el cumplimiento de las normas de seguridad de las aplicaciones Java Esta \u00faltima tarea, es una de las m\u00e1s importantes que realiza la JVM. Adem\u00e1s, las propias especificaciones del lenguaje Java contribuyen extraordinariamente a este objetivo: Las referencias a arrays son verificadas en el momento de la ejecuci\u00f3n del programa No hay manera de manipular de forma directa los punteros La JVM gestiona autom\u00e1ticamente el uso de la memoria, de modo que no queden huecos. No se permiten realizar ciertas conversiones (casting) entre distintos tipos de datos. 1.3. El lenguaje Java Java es un lenguaje de prop\u00f3sito general, de alto nivel, y orientado a objetos. Java es un lenguaje de programaci\u00f3n orientado a objetos puro, en el sentido de que no hay ninguna variable, funci\u00f3n o constante que no est\u00e9 dentro de una clase. Se accede a los miembros dato y las funciones miembro a trav\u00e9s de los objetos y de las clases. Por razones de eficiencia, se han conservado los tipos b\u00e1sicos de datos, int, float, double, char, etc, similares a los del lenguaje C/C++. La API de Java es muy rica, est\u00e1 formada por un conjunto de paquetes de clases que le proporcionan una gran funcionalidad. El n\u00facleo de la API viene con cada una de las implementaciones de la JVM: Lo esencial: tipos de datos, clases y objetos, arrays, cadenas de caracteres (strings), subprocesos (threads), entrada/salida (I/O), propiedades del sistema, etc. Applets Manejo de la red (networking) Internacionalizaci\u00f3n Seguridad Componentes (JavaBeans) Persistencia (Object serialization) Conexi\u00f3n a bases de datos (JDBC) Java proporciona tambi\u00e9n extensiones, por ejemplo, define un API para 3D, para los servidores, telefon\u00eda, reconocimiento de voz, etc.","title":"Java"},{"location":"java_intro/#1-java","text":"","title":"1. Java"},{"location":"java_intro/#11-historia-de-java","text":"Para hablar de la historia de java, hay que remontarse a los a\u00f1os 80, donde C pod\u00eda considerarse el lenguaje por antonomasia. Era un lenguaje vers\u00e1til, que pod\u00eda actuar a bajo nivel y resolv\u00edan problemas muy complejos. Era la cima de la programaci\u00f3n estructurada, para resolver estos complejos algoritmos, se generaban grandes procedimientos con un c\u00f3digo muy complicado de mantener a largo plazo. Por ello empez\u00f3 a surgir como alternativa la programaci\u00f3n orientada a objetos, y con ella naci\u00f3 C++. El objetivo de java era crear un lenguaje de programaci\u00f3n parecido a C++ en estructura y sintaxis, fuertemente orientado a objetos, pero con una m\u00e1quina virtual propia. Esto se hizo bajo el principio, de poder ser usado bajo cualquier arquitectura \"Write Once, Run Anywhere (escr\u00edbelo una vez, ejec\u00fatalo en cualquier sitio)\". En 1992 se presenta el proyecto, con los prototipos a bajo nivel. Entre 1993 y 1994 se trabaja para poder presentar un prototipo funcional (hotJava) donde se ve todo el potencial que JAVA puede ofrecer En 1995 finalmente, es presentada la versi\u00f3n alpha de java, y un a\u00f1o despu\u00e9s en 1996 es lanzado el primer JDK (JDK 1.0): software que provee herramientas de desarrollo para la creaci\u00f3n de programas en java. El desarrollo de java a partir de entonces es imparable, se van presentando nuevos paquetes y librer\u00edas hasta la actualidad. A d\u00eda de hoy, se puede decir, que Java es uno de los lenguajes m\u00e1s importantes del mundo. Con una comunidad extendida en todos los componentes y m\u00e1s de 4 millones de desarrolladores, existen millones de dispositivos que lo usan. Adem\u00e1s, tras el surgimiento de android, java es establecido como el lenguaje de programaci\u00f3n para m\u00f3viles m\u00e1s extendido del planeta. En las primeras versiones de Java 1.1, 1.2 y 1.3 es donde el lenguaje va tomando forma, con la inclusi\u00f3n de tecnolog\u00edas como JavaBeans, JDBC para el acceso a base de datos, RMI para las invocaciones en remoto, Collections para la gesti\u00f3n de m\u00faltiples estructuras de datos o AWT para el desarrollo gr\u00e1fico, entre otros. Una de las cosas que sucede en noviembre 2006 es que Sun Microsystems lo convierte en Open Source mediante una licencia GNU General Public License (GPL). Dando lugar en mayo de 2008 a lo que se conoce como OpenJDK, con OpenJDK 6. Llegado julio de 2011 ve la luz Java 7, la cual trae como novedades el soporte de lenguajes din\u00e1micos, dotando a la JVM de un soporte de m\u00fatiples lenguajes y una nueva librer\u00eda I/O para el manejo de ficheros. Tambi\u00e9n aparecen cosas menores, pero muy \u00fatiles como el manejo de String, dentro de la validaci\u00f3n en una estructura switch, o la capacidad de poner guiones de subrayado como separadores de miles en los n\u00fameros para facilitar su lectura (p. ej. 1_000_000). La \u00faltima versi\u00f3n de Java distribuida es Java 8, aparecida en marzo de 2014. Entre las caracter\u00edsticas de Java 8 se tiene el soporte para expresiones Lambda y uso de Streams, que permiten un estilo m\u00e1s similar a la programaci\u00f3n funcional para los programas Java. Dentro de este enfoque m\u00e1s cercano a la programaci\u00f3n funcional, tambi\u00e9n aparecen las transformaciones MapReduce. Ve la luz el Proyecto Nashorn para disponer de un engine Javascript y as\u00ed poder incluir este lenguaje dentro de las aplicaciones Java. Otras cosas son un nuevo API Date y Time y la inclusi\u00f3n de JavaFX 8 dentro de la JDK de Java.","title":"1.1. Historia de Java"},{"location":"java_intro/#12-la-maquina-virtual-java","text":"El lenguaje Java es a la vez compilado e interpretado. Con el compilador, se convierte el c\u00f3digo fuente que reside en archivos cuya extensi\u00f3n es .java, a un conjunto de instrucciones que recibe el nombre de bytecodes, que se guardan en un archivo cuya extensi\u00f3n es .class. Estas instrucciones son independientes del tipo de ordenador. El int\u00e9rprete ejecuta cada una de estas instrucciones en un ordenador espec\u00edfico (Windows, Macintosh, etc). Solamente es necesario, por tanto, compilar una vez el programa, pero se interpreta cada vez que se ejecuta en un ordenador. Cada int\u00e9rprete Java es una implementaci\u00f3n de la M\u00e1quina Virtual Java (JVM). Los bytecodes posibilitan el objetivo de \"write once, run anywhere\", de escribir el programa una vez y que se pueda ejecutar en cualquier plataforma que disponga de una implementaci\u00f3n de la JVM. Por ejemplo, el mismo programa Java puede ejecutarse en Windows 98, Solaris, Macintosh, etc. Java es, por tanto, algo m\u00e1s que un lenguaje, ya que la palabra Java se refiere a dos cosas inseparables: el lenguaje que nos sirve para crear programas y la M\u00e1quina Virtual Java que sirve para ejecutarlos. Como se puede ver en la figura, el API de Java y la M\u00e1quina Virtual Java forman una capa intermedia (Java platform) que a\u00edsla el programa Java de las especificidades del hardware (hardware-based platform). La M\u00e1quina Virtual Java (JVM) es el entorno en el que se ejecutan los programas Java. Su misi\u00f3n principal es la de garantizar la portabilidad de las aplicaciones Java. Define esencialmente un ordenador abstracto y especifica las instrucciones (bytecodes) que este ordenador puede ejecutar. El int\u00e9rprete Java espec\u00edfico ejecuta las instrucciones que se guardan en los archivos cuya extensi\u00f3n es .class. Las tareas principales de la JVM son las siguientes: Reservar espacio en memoria para los objetos creados Liberar la memoria no usada (garbage collection) Asignar variables a registros y pilas Llamar al sistema hu\u00e9sped para ciertas funciones, como los accesos a los dispositivos Vigilar el cumplimiento de las normas de seguridad de las aplicaciones Java Esta \u00faltima tarea, es una de las m\u00e1s importantes que realiza la JVM. Adem\u00e1s, las propias especificaciones del lenguaje Java contribuyen extraordinariamente a este objetivo: Las referencias a arrays son verificadas en el momento de la ejecuci\u00f3n del programa No hay manera de manipular de forma directa los punteros La JVM gestiona autom\u00e1ticamente el uso de la memoria, de modo que no queden huecos. No se permiten realizar ciertas conversiones (casting) entre distintos tipos de datos.","title":"1.2. La M\u00e1quina Virtual Java"},{"location":"java_intro/#13-el-lenguaje-java","text":"Java es un lenguaje de prop\u00f3sito general, de alto nivel, y orientado a objetos. Java es un lenguaje de programaci\u00f3n orientado a objetos puro, en el sentido de que no hay ninguna variable, funci\u00f3n o constante que no est\u00e9 dentro de una clase. Se accede a los miembros dato y las funciones miembro a trav\u00e9s de los objetos y de las clases. Por razones de eficiencia, se han conservado los tipos b\u00e1sicos de datos, int, float, double, char, etc, similares a los del lenguaje C/C++. La API de Java es muy rica, est\u00e1 formada por un conjunto de paquetes de clases que le proporcionan una gran funcionalidad. El n\u00facleo de la API viene con cada una de las implementaciones de la JVM: Lo esencial: tipos de datos, clases y objetos, arrays, cadenas de caracteres (strings), subprocesos (threads), entrada/salida (I/O), propiedades del sistema, etc. Applets Manejo de la red (networking) Internacionalizaci\u00f3n Seguridad Componentes (JavaBeans) Persistencia (Object serialization) Conexi\u00f3n a bases de datos (JDBC) Java proporciona tambi\u00e9n extensiones, por ejemplo, define un API para 3D, para los servidores, telefon\u00eda, reconocimiento de voz, etc.","title":"1.3. El lenguaje Java"},{"location":"metodos_encapsulamiento/","text":"","title":"M\u00e9todos y encapsulamiento"},{"location":"operaciones_sentencias/","text":"4. Operadores y sentencias 4.1. Entender los operadores de Java Los operadores de java son s\u00edmbolos especiales que se aplican un grupo de variables, valores o \u201cliterales\u201d y que devuelven un valor. Existen tres tipos de operadores en Java: unario, binario y ternario. Estos tipos de operadores pueden ser aplicados a uno, dos o tres operandos. Los operadores de java no siempre se eval\u00faan de izquierda a derecha. En el siguiente ejemplo se puede observar como la expresi\u00f3n se eval\u00faa de derecha a izquierda: int y = 4; double x = 3 + 2 * --y; En el ejemplo primero se reduce en uno la variable y, despu\u00e9s se multiplica por 2 y por \u00faltimo se le suman 3. El resultado final ser\u00e1 convertido de 9 a 9.0 y asignado a la variable x. Los valores de x e y ser\u00e1n 9.0 y 3. A menos que est\u00e9n entre par\u00e9ntesis, los operadores de Java siguen un orden de operaci\u00f3n que se encuentran listados en la tabla. Si dos operadores est\u00e1n en el mismo nivel se evaluar\u00e1n de izquierda a derecha. Operador S\u00edmbolos y ejemplos Operadores post-unarios Expresi\u00f3n++, Expresi\u00f3n-- Operadores pre-unarios ++Expresi\u00f3n, --Expresi\u00f3n Operadores unarios +, -,! Multiplicaci\u00f3n, Divisi\u00f3n, M\u00f3dulo *, /, % Suma, Resta +, - Operadores de cambio <<, >>, >>> Operadores relacionales <, >, <=, >=, instanceof Igual, Distinto ==, != Operadores l\u00f3gicos &, ^, Operadores l\u00f3gicos de cortocircuito &&, Operadores ternarios Expresi\u00f3n booleana? expresi\u00f3n1 : expresi\u00f3n 2 Operadores de asignaci\u00f3n =, +=, -=, *=, /=, %=, &=, ^=, !=, <<=, >>=, >>>= 4.2. Trabajando con operadores binarios aritm\u00e9ticos 4.2.1. Operadores aritm\u00e9ticos Los operadores aritm\u00e9ticos son los utilizados en las matem\u00e1ticas y son los siguiente: la suma (+), la resta (-), la multiplicaci\u00f3n (*), la divisi\u00f3n (/) y el m\u00f3dulo (%). Tambi\u00e9n se incluyen los operadores unarios ++ y --. Como puedes comprobar en la tabla anterior los operadores , / y % tienen mayor orden de preferencia que los operadores + y -, por lo que la siguiente expresi\u00f3n: int x = 2 * 5 + 3 * 4 \u2013 8; Se evaluar\u00e1 primero 2 5 y 3*4 simplificando la expresi\u00f3n a la siguiente: int x = 10 + 12 \u2013 8; Despu\u00e9s se evaluar\u00e1 la expresi\u00f3n de izquierda a derecha dando como resultado 14. Se puede cambiar el orden de la operaci\u00f3n a\u00f1adiendo par\u00e9ntesis a las secciones que se quiere evaluar primero. Se compara el ejemplo de antes con el siguiente que incorpora par\u00e9ntesis: int x = 2 * ((5 + 3) * 4 \u2013 8); Esta vez se deber\u00e1 evaluar la suma 5 + 3 primero, que reducir\u00e1 la expresi\u00f3n a: int x = 2 * (8 * 4 - 8); Se podr\u00e1 reducir la expresi\u00f3n multiplicando los dos primeros valores dentro del par\u00e9ntesis: int x = 2 * (32 - 8); Despu\u00e9s se restar\u00e1 los valores de dentro del par\u00e9ntesis antes de multiplicarlos por el valor de fuera: int x = 2 * 24; Finalmente se multiplicar\u00e1n los valores restantes, dando un resultado de 48. Todos los operadores aritm\u00e9ticos pueden ser aplicados a cualquier tipo primitivo de Java, salvo los tipos boolean y string. Adem\u00e1s, solo los operadores + y += pueden ser aplicados a variables string, lo que resulta ser una concatenaci\u00f3n de string. El m\u00f3dulo es el resto de la divisi\u00f3n de dos n\u00fameros, por ejemplo 9 divido entre 3 no tiene resto por lo que 9 % 3 ser\u00e1 0. Por otra parte 11 divido entre 3 si tiene resto por lo tanto 11 % 3 ser\u00e1 igual a 2. Hay que tener clara la diferencia entre la divisi\u00f3n y el m\u00f3dulo. La divisi\u00f3n devuelve el cociente, mientras que el m\u00f3dulo devuelve el resto de la divisi\u00f3n. Los siguientes ejemplos ilustran la diferencia entre ambas operaciones: System.out.print(9 / 3); // Outputs 3 System.out.print(9 % 3); // Outputs 0 System.out.print(10 / 3); // Outputs 3 System.out.print(10 % 3); // Outputs 1 System.out.print(11 / 3); // Outputs 3 System.out.print(11 % 3); // Outputs 2 System.out.print(12 / 3); // Outputs 4 System.out.print(12 % 3); // Outputs 0 Hay que tener en cuenta que el resultado de la divisi\u00f3n solo se incrementa cuando el valor de la izquierda se incrementa de 9 a 12, mientras que el m\u00f3dulo incrementa en 1, cada vez que el valor de la izquierda se incrementa, hasta que se convierte en 0. Para un divisor dado y, que es 3 en estos ejemplos, la operaci\u00f3n de m\u00f3dulo da como resultado un valor entre 0 y (y - 1) para dividendos positivos. Esto significa que el resultado de una operaci\u00f3n de m\u00f3dulo es siempre 0,1 o 2. El funcionamiento del m\u00f3dulo no se limita a los valores enteros positivos en Java y tambi\u00e9n puede aplicarse a n\u00fameros enteros negativos y n\u00fameros enteros de coma flotante. Para un divisor \u201cy\u201d y dividendo negativo dado, el valor del m\u00f3dulo resultante est\u00e1 entre (-y + 1) y 0. 4.2.2. Promoci\u00f3n num\u00e9rica Reglas de la promoci\u00f3n num\u00e9rica: Si dos variables tienes diferente tipo, Java autom\u00e1ticamente convertir\u00e1 una de las variables al tipo m\u00e1s grande de las dos. Si una de las variables es Integer y la otra de coma flotante(float), Java autom\u00e1ticamente convertir\u00e1 la variable Integer en una de coma flotante. Los tipos de datos peque\u00f1os como byte, short y char son convertidos a Int siempre que son usados por un operador aritm\u00e9tico binario, incluso si ninguno de los operandos es un Int. Despu\u00e9s de que se hayan convertido las variables y los operandos tengan el mismo tipo, el resultado se guardar\u00e1 con el mismo tipo al que se hayan convertido los operandos. Las dos \u00faltimas reglas son aquellas con las que la mayor\u00eda de la gente tiene problemas. Por lo que respecta a la tercera regla, debe tenerse en cuenta que los operadores unitarios est\u00e1n excluidos de esta. Por ejemplo, aplicar ++ a un valor short dar\u00e1 como resultado un valor short. 4.3. Trabajando con operadores unarios Por definici\u00f3n un operador unario es uno que requiere exactamente un operando o variable para funcionar. Como se muestra en la tabla suelen realizar tareas simples como incrementar en uno una variable o negar el valor de un boolean. Operador unario Descripci\u00f3n + Indica que un n\u00famero es positivo, aunque se supone que los n\u00fameros son positivos en Java a menos que vayan acompa\u00f1ados de un operador negativo unario. - Indica que un n\u00famero es negativo o niega una expresi\u00f3n ++ Incremento una variable en 1 -- Decremento de una variable en 1 ! Invierte el valor l\u00f3gico de un boolean 4.3.1. Complemento l\u00f3gico y operadores de negaci\u00f3n El operador de complemento l\u00f3gico(!) invierte el valor de una expresi\u00f3n booleana. Por ejemplo, si el valor es true, se invertir\u00eda a false, y viceversa. Para demostrar esto, se comparar\u00e1 la salida de las siguientes instrucciones: boolean x = false; System.out.printl(x); //false x = !x; System.out.println(x); //true Por otra parte, el operador de negaci\u00f3n (-) cambia el signo de una expresi\u00f3n num\u00e9rica como se muestra a continuaci\u00f3n: double x = 1.21; System.out.println(x); //1.21 x = -x; System.out.println(x); //-1.21 x = -x; System.out.println(x); //1.21 Si uno se basa en la descripci\u00f3n, podr\u00eda ser obvio que algunos operadores requieran la variable de un tipo espec\u00edfico. No se puede utilizar un operador de negaci\u00f3n, -, con una expresi\u00f3n booleana, ni se puede aplicar un complemento l\u00f3gico a una expresi\u00f3n num\u00e9rica. Por ejemplo, ninguna de las siguientes l\u00edneas de c\u00f3digo compilar\u00e1: int x = !5; // DOES NOT COMPILE boolean y = -true; // DOES NOT COMPILE boolean z = !0; // DOES NOT COMPILE La primera declaraci\u00f3n no se compilar\u00e1 debido al hecho de que en Java no se puede realizar una inversi\u00f3n l\u00f3gica de un valor num\u00e9rico. La segunda declaraci\u00f3n no compilar\u00e1 porque no se puede negar num\u00e9ricamente un valor booleano, es necesario utilizar el operador l\u00f3gico inverso. Finalmente, la \u00faltima sentencia no se compila porque no se puede tomar el complemento l\u00f3gico de un valor num\u00e9rico, ni se puede asignar un entero a una variable booleana. 4.3.2. Operadores de incremento y decremento. Los operadores de incremento y decremento (++, --) pueden aplicarse a operandos num\u00e9ricos y tienen mayor preferencia que los operadores binarios. Los operadores de incremento y decremento requieren un cuidado especial ya que el orden en el que son utilizados con los operandos pueden provocar un procesamiento distinto de la expresi\u00f3n. Si el operador est\u00e1 situado delante del operando entonces el operador se aplica primero y luego se devuelve el valor. Por otro lado, si el operador se encuentra detr\u00e1s del operando se devuelve primero el valor original y luego se aplica el operador. El siguiente c\u00f3digo ilustra las diferencias: int counter = 0; System.out.println(counter); // Outputs 0 System.out.println(++counter); // Outputs 1 System.out.println(counter); // Outputs 1 System.out.println(counter--); // Outputs 1 System.out.println(counter); // Outputs 0 El primer operador de pre-incremento actualiza el valor del contador y devuelve el nuevo valor de 1. El siguiente operador de post-decremento tambi\u00e9n actualiza el valor del contador pero devuelve el valor antes de que se produzca la disminuci\u00f3n. El siguiente ejemplo es todav\u00eda m\u00e1s complicado ya que se modifica el valor 3 veces en la misma l\u00ednea: int x = 3; int y = ++x * 5 / x-- + --x; System.out.println(\"x is \" + x); System.out.println(\"y is \" + y); Cada vez que se modifica, la expresi\u00f3n pasa de izquierda a derecha, el valor de x cambia, con diferentes valores asignados a la variable. Como recordar\u00e1s de nuestra discusi\u00f3n sobre la precedencia del operador, el orden de la operaci\u00f3n juega un papel importante en evaluando este ejemplo. Primero, la x se incrementa y se devuelve a la expresi\u00f3n, que se multiplica por 5: int y = 4 * 5 / x-- + --x; // x con valor 4 A continuaci\u00f3n, se decrementa x, pero el valor original de 4 se utiliza en la expresi\u00f3n, lo que lleva a esto: int y = 4 * 5 / 4 + --x; // x con valor 3 La asignaci\u00f3n final de x reduce el valor a 2, y como se trata de un operador pre-incremental, se devuelve ese valor: int y = 4 * 5 / 4 + 2; // x con valor 2 Finalmente, se realiza la multiplicaci\u00f3n y a continuaci\u00f3n la divisi\u00f3n, y por \u00faltimo la suma dando como resultado: x is 2 y is 7 4.4. Usando los operadores binarios adicionales 4.4.1. Operadores de asignaci\u00f3n Los operadores de asignaci\u00f3n son operadores binarios que modifican la variable con el valor del lado derecho de la ecuaci\u00f3n. El operador de asignaci\u00f3n m\u00e1s simple es el operador \u201c=\u201d: int x = 1; Esta declaraci\u00f3n asigna a x el valor 1. Java transformar\u00e1 autom\u00e1ticamente de tipos de datos peque\u00f1os a grandes, como vimos en la secci\u00f3n anterior, pero lanzar\u00e1 una excepci\u00f3n de compilador si detecta que est\u00e1 intentando convertir tipos de datos grandes a peque\u00f1os. Vamos a ver unos ejemplos para demostrar como el \u201ccasting\u201d puede resolver estos problemas: int x = 1.0; // DOES NOT COMPILE short y = 1921222; // DOES NOT COMPILE int z = 9f; // DOES NOT COMPILE long t = 192301398193810323; // DOES NOT COMPILE La primera sentencia no compila porque est\u00e1 tratando de asignar un double a un valor int. A pesar de que el valor es un entero, al sumar \u201c. 0\u201d, est\u00e1 indicando al compilador que lo trate como un double. La segunda declaraci\u00f3n no compila porque el valor 1921222 est\u00e1 fuera del rango de short. La tercera declaraci\u00f3n no compila debido a la \u201cf\u201d a\u00f1adida al final del n\u00famero que indica al compilador que ha de tratar al n\u00famero como un float. Finalmente, el \u00faltimo enunciado no compila porque Java interpreta el valor como un int y nota que es mayor de lo que permite int. El \u00faltimo caso necesitar\u00eda un postfix L para ser considerado un long. 4.4.2. Casting de valores primitivos Se pueden arreglar los ejemplos de la secci\u00f3n anterior, haciendo \u201ccasting\u201d a los resultados. El \u201ccasting\u201d es necesario siempre que se pase de un dato num\u00e9rico m\u00e1s grande a un tipo de datos num\u00e9ricos m\u00e1s peque\u00f1os, o la conversi\u00f3n de un n\u00famero float a un valor int. int x = (int)1.0; short y = (short)1921222; // Stored as 20678 int z = (int)9l; long t = 192301398193810323L; Algunos ejemplos: short x = 10; short y = 3; short z = x * y; // DOES NOT COMPILE Basando todo en lo que se ha aprendido hasta ahora, \u00bfpor qu\u00e9 las \u00faltimas l\u00edneas de esta declaraci\u00f3n no compilar\u00e1n? Recordar, los valores short se transforman autom\u00e1ticamente a int con cualquier operador aritm\u00e9tico, con el valor resultante de tipo int. Tratar de establecer una variable corta en una int resulta en un error del compilador, como piensa Java, est\u00e1 intentando convertir impl\u00edcitamente de un tipo de datos m\u00e1s grande a uno m\u00e1s peque\u00f1o. Hay ocasiones en las que se puede querer anular el comportamiento predeterminado del compilador. Por ejemplo, en el ejemplo anterior, se sabe que el resultado de 10 * 3 es 30, que puede ser guardado en un short. Sin embargo, si se necesita que el resultado sea un short puede sustituirse este comportamiento haciendo \u201ccasting\u201d del resultado de la multiplicaci\u00f3n: short x = 10; short y = 3; short z = (short)(x * y); Al realizar este \u201ccasting\u201d de un tipo de datos mayor a un tipo de datos m\u00e1s peque\u00f1o, se est\u00e1 ordenando al compilador que ignore su comportamiento predeterminado. En otras palabras, se le est\u00e1 diciendo al compilador que se est\u00e1 tomando medidas adicionales para evitar el overflow o el underflow. Overflow y Underflow Las expresiones en el ejemplo anterior ahora compilan, aunque hay un coste. El segundo valor, 1.921.222, es demasiado grande para ser almacenado como un valor short, por lo que se produce un overflow y se convierte en 20.678. El overflow es cuando un n\u00famero es tan grande que ya no se puede guardar dentro de un tipo de datos, por lo que el sistema se \"envuelve\" en el siguiente valor m\u00ednimo y cuenta desde ah\u00ed. Tambi\u00e9n hay un underflow analogo, cuando el n\u00famero es demasiado bajo para guardarlo en el tipo de datos. Por ejemplo, la siguiente sentencia genera un n\u00famero negativo: _System.out.println(2147483647+1); // - 214748364848_ Dado que 2147483647 es el valor m\u00e1ximo de int, sumando cualquier valor estrictamente positivo a \u00e9l se obtendr\u00e1 lo siguiente al siguiente n\u00famero negativo. 4.4.3. Operadores de asignaci\u00f3n compuestos Adem\u00e1s del operador simple de asignaci\u00f3n, =, existen tambi\u00e9n numerosos operadores de asignaci\u00f3n compuestos. S\u00f3lo se requieren dos de los operadores compuestos enumerados en la Tabla 2.1, += y =. Los operadores complejos son en realidad una mejora de los operadores de asignaci\u00f3n simple con una operaci\u00f3n aritm\u00e9tica o l\u00f3gica incorporada que se aplican de izquierda a derecha de la expresi\u00f3n y almacena el valor resultante en la variable de la parte izquierda de la pantalla. Por ejemplo, las dos expresiones siguientes despu\u00e9s de la declaraci\u00f3n de x y z son equivalentes: int x = 2, z = 3; x = x * z; // Simple assignment operator x *= z; // Compound assignment operator El lado izquierdo del operador compuesto s\u00f3lo se puede aplicar a una variable que ya est\u00e9 definida y no se puede utilizar para declarar una nueva variable. En el ejemplo anterior, si x no estaba ya definida, entonces la expresi\u00f3n x *=z no compilar\u00eda. Los operadores compuestos son \u00fatiles para algo m\u00e1s que la mera abreviatura, tambi\u00e9n se puede ahorrar el tener que hacer \u201ccasting\u201d a un valor. Por ejemplo, si se considera el siguiente ejemplo en que la \u00faltima l\u00ednea no compilar\u00e1 debido a que el resultado es transformado a long y asignado a una variable int: long x = 10; int y = 5; y = y * x; // DOES NOT COMPILE Si uno se basa en las dos \u00faltimas secciones, se deber\u00eda poder detectar el problema en la \u00faltima l\u00ednea. Esta \u00faltima l\u00ednea podr\u00eda ser fijada con un \u201ccasting\u201d a int, pero hay una manera mejor, usando el operador de asignaci\u00f3n compuesto: long x = 10; int y = 5; y*= x; El operador compuesto har\u00e1 un \u201ccasting\u201d primero de x a long, aplicar\u00e1 la multiplicaci\u00f3n de dos valores long, y luego devolver\u00e1 el resultado a un int. A diferencia del ejemplo anterior, en el que el compilador lanzar\u00e1 una excepci\u00f3n, en este ejemplo vemos que el compilador har\u00e1 un \u201ccasting\u201d autom\u00e1ticamente del valor resultante al tipo de datos de la variable del lado izquierdo del operador compuesto. Una cosa importante que se debe saber acerca del operador de asignaci\u00f3n es que el resultado de la asignaci\u00f3n es una expresi\u00f3n en s\u00ed misma, igual al valor de la asignaci\u00f3n. Por ejemplo, el siguiente fragmento de c\u00f3digo es perfectamente v\u00e1lido, aunque un poco extra\u00f1o: long x = 5; long y = (x=3); System.out.println(x); // Outputs 3 System.out.println(y); // Also, outputs 3 La clave aqu\u00ed es que (x=3) hace dos cosas. En primer lugar, fija el valor de la variable x para que sea 3. En segundo lugar, devuelve el valor de la asignaci\u00f3n, que tambi\u00e9n es 3. 4.4.4. Operadores relacionales Ahora se pasar\u00e1 a los operadores relacionales, que comparan dos expresiones y devuelven un valor booleano. Los primeros cuatro operadores relacionales (ver la tabla se aplican solo a tipos de datos primitivos num\u00e9ricos. Si los dos operando num\u00e9ricos no son del mismo tipo de datos, el par\u00e1metro m\u00e1s peque\u00f1o se transforma de la manera anteriormente discutida. Operador relacional Descripci\u00f3n < Estrictamente menos que <= Menos que o igual a > Estrictamente mayor que >= Mayor que o igual a A continuaci\u00f3n, se ver\u00e1n unos ejemplos de estos operadores: int x = 10, y = 20, z = 10; System.out.println(x < y); // Outputs true System.out.println(x <= y); // Outputs true System.out.println(x >= z); // Outputs true System.out.println(x > z); // Outputs false Observar que el \u00faltimo ejemplo produce una salida false, porque, aunque x y z son el mismo valor, x no es estrictamente mayor que z. El quinto operador relacional (ver la tabla de abajo) se aplica a objetos y clases, o bien a interfaces. Operador relacional Descripci\u00f3n a instanceof b Verdadero si la referencia a la que apunta \u201ca\u201d es una instancia de una clase, subclase o clase que implementa una interfaz particular, como se nombra en b Cabe destacar lo siguiente respecto al operador instanceof: String str = null; System.out.println(str instanceof String ); // false Es decir: no basta con declarar la variable como de un tipo sino que debe ser realmente un objeto de ese tipo (como consecuencia, no es necesario comparar contra null). if (x != null && x instanceof X) ... Se puede simplificar a: if (x instanceof X) ... 4.4.5. Operadores l\u00f3gicos Los operadores l\u00f3gicos, (&), (|) y (^), se pueden aplicar a datos de tipo num\u00e9ricos y booleanos. Cuando se aplican a tipos de datos booleanos, se los denomina operadores l\u00f3gicos. Alternativamente, cuando se aplican a tipos de datos num\u00e9ricos, se les llama operadores a nivel de bit, ya que realizan comparacionesbit a bit de los bits que componen el n\u00famero. Se debe familiarizar con las tablas de las figuras, donde se supone que x e y son tipos de datos booleanos. X & Y (AND) Y=true Y=false X = true True False X = false False False X | Y (Inclusive OR) Y=true Y=false X = true True True X = false True False X ^ Y (Exclusive OR) Y=true Y=false X = true False True X = false True False Aqu\u00ed hay algunos consejos para ayudar a recordar esta tabla: AND solo es verdadero si ambos operandos son verdaderos. OR inclusivo solo es falso si ambos operandos son falsos. Exclusive OR solo es verdadero si los operandos son diferentes. Finalmente, se presentan los operadores condicionales, && y || , que a menudo se conocen como operadores de cortocircuito. Los operadores de cortocircuito son casi id\u00e9nticos a los operadores l\u00f3gicos, & y | , respectivamente, excepto que el lado derecho de la expresi\u00f3n nunca puede ser evaluado si el resultado final puede ser determinado por el lado izquierdo de la expresi\u00f3n. Por ejemplo, si se considera la siguiente declaraci\u00f3n: boolean x = true || (y < 4); En referencia a las tablas de verdad, el valor x solo puede ser falso si ambos lados de la expresi\u00f3n son falsas. Como sabemos que el lado izquierdo es verdadero, no hay necesidad de evaluar el lado derecho, ya que nada har\u00e1 que el valor de x sea diferente de verdadero. Para ilustrar este concepto prueba a ejecutar la l\u00ednea de c\u00f3digo anterior para varios valores de y. El ejemplo m\u00e1s com\u00fan de d\u00f3nde se usan los operadores de cortocircuito es la comprobaci\u00f3n de objetos nulos antes de realizar una operaci\u00f3n, como esta: if(x != null && x.getValue() < 5) { // Do something } En este ejemplo, si x fuera nulo, entonces el cortocircuito evita lanzar una excepci\u00f3n NullPointerException, ya que la evaluaci\u00f3n de x.getValue () <5 nunca se alcanza. Alternativamente, si usamos un & l\u00f3gico, entonces ambos lados siempre se evaluar\u00e1n y cuando x fuese nulo esto arrojar\u00eda una excepci\u00f3n: if(x != null & x.getValue() < 5) { // Throws an exception if x is null // Do something } \u00bfCu\u00e1l es el resultado del siguiente c\u00f3digo? int x = 6; boolean y = (x >= 6) || (++x <= 7); System.out.println(x); Como x >= 6 es verdadero, el operador de incremento en el lado derecho de la expresi\u00f3n nunca se eval\u00faa, por lo que la salida es 6 . 4.4.6. Operadores de igualdad La determinaci\u00f3n de la igualdad en Java puede no ser trivial, ya que hay una diferencia sem\u00e1ntica entre \"dos objetos son lo mismo\" y \"dos objetos son equivalentes\". Es a\u00fan m\u00e1s complicado por el hecho de que para tipos primitivos num\u00e9ricos (entre los que se incluye tambi\u00e9n el tipo de dato char) y booleanos, no existe tal distinci\u00f3n. Comenzando por lo m\u00e1s sencillo: el operador de igualdad (==) y el operador de desigualdad (!=). Como los operadores relacionales, comparan dos operandos y devuelven un valor booleano si las expresiones o valores son iguales o no iguales, respectivamente. Los operadores de igualdad se utilizan en uno de tres casos: Comparando dos tipos primitivos num\u00e9ricos. Si los valores num\u00e9ricos son de diferente tipo de datos, los valores se transforman autom\u00e1ticamente como se describi\u00f3 anteriormente. Por ejemplo, 5 == 5.00 devuelve verdadero ya que el lado izquierdo se transforma a un double. Comparando dos valores booleanos. Comparando dos objetos, incluidos los valores nulos y String. Las comparaciones para la igualdad se limitan a estos tres casos, por lo que no se pueden mezclar tipos. Por ejemplo, cada uno de los siguientes devolver\u00eda en un error del compilador: boolean x = true == 3; // DOES NOT COMPILE boolean y = false != \"Giraffe\"; // DOES NOT COMPILE boolean z = 3 == \"Kangaroo\"; // DOES NOT COMPILE Si se observa el siguiente fragmento: boolean y = false; boolean x = (y = true); System.out.println(x); // Outputs true A primera vista, se podr\u00eda pensar que la salida deber\u00eda ser falsa, y si la expresi\u00f3n fuese (y == true), se tendr\u00eda raz\u00f3n. En este ejemplo, sin embargo, la expresi\u00f3n est\u00e1 asignando el valor true a y, y como se vio en la secci\u00f3n de operadores de asignaci\u00f3n, la asignaci\u00f3n misma tiene el valor de la asignaci\u00f3n. Por lo tanto, la salida ser\u00eda verdadera. Para la comparaci\u00f3n de objetos, el operador de igualdad se aplica a las referencias a estos objetos, no a los objetos a los que apuntan. Dos referencias son iguales si y solo si apuntan a lo mismo objeto, o ambos apuntan a nulo. Si se ven algunos ejemplos se entender\u00e1 mejor: File x = new File(\"myFile.txt\"); File y = new File(\"myFile.txt\"); File z = x; System.out.println(x == y); // Outputs false System.out.println(x == z); // Outputs true Aunque todas las variables apuntan a la misma informaci\u00f3n de archivo, solo dos, x y z, son iguales en t\u00e9rminos de == . En el Cap\u00edtulo 3 , \"Core Java APIs\" , se continuar\u00e1 la discusi\u00f3n sobre la igualdad de objetos introduciendo lo que significa que dos objetos diferentes sean equivalentes. Tambi\u00e9n se tratar\u00e1 la igualdad de los String y se mostrar\u00e1 c\u00f3mo este puede ser un tema no trivial. 4.5. Comprender las sentencias de Java Los operadores Java permiten crear muchas expresiones complejas, pero est\u00e1n limitadas en la manera en que pueden controlar el flujo del programa. Por ejemplo, imaginar que se quiere una secci\u00f3n de c\u00f3digo que solo sea ejecutado bajo ciertas condiciones que no pueden ser evaluadas hasta que no se ejecute. O si se desea que un segmento particular de c\u00f3digo se repita una vez por cada elemento en alguna lista. Como se dijo en el Cap\u00edtulo 1, una declaraci\u00f3n de Java es una unidad completa de ejecuci\u00f3n en Java, terminando con un punto y una coma (;) . En el cap\u00edtulo, se mostrar\u00e1n varias declaraciones de control de flujo en Java. Las declaraciones de control de flujo rompen el flujo de ejecuci\u00f3n mediante la toma de decisiones, el bucle y la ramificaci\u00f3n, permitiendo que la aplicaci\u00f3n seleccione segmentos particulares del c\u00f3digo para ejecutar. Las declaraciones se pueden aplicar a expresiones simples, o a un bloque de c\u00f3digo. Un bloque de c\u00f3digo en Java es un grupo de cero o m\u00e1s declaraciones entre llaves, ({}) , y se puede usar en cualquier lugar donde se permita usar una declaraci\u00f3n simple. 4.5.1. if-then De vez en cuando, solo se quiere ejecutar un bloque de c\u00f3digo seg\u00fan ciertas condiciones. El if-then, como se muestra en el c\u00f3digo siguiente, permite que la aplicaci\u00f3n ejecute un bloque particular de c\u00f3digo si y solo si una expresi\u00f3n booleana se eval\u00faa como verdadera en tiempo de ejecuci\u00f3n. if(booleanExpression){ //Branch if true } Por ejemplo, si se tiene una funci\u00f3n que utiliza la hora del d\u00eda para mostrar un mensaje al usuario: if(hourOfDay < 11) System.out.println(\u201cGood Morning\u201d); Si la hora es menor que 11 entonces la funci\u00f3n mostrar\u00e1 el mensaje. Si se quisiera adem\u00e1s incrementar alg\u00fan valor, morningGreetingCount, cada vez que el mensaje se muestra se podr\u00eda repetir la declaraci\u00f3n if-then, pero Java permite escribirlo a continuaci\u00f3n del output convirtiendo el c\u00f3digo en un bloque: if(hourOfDay < 11){ System.out.println(\u201cGood Morning\u201d); morningGreetingCount++; } El bloque permite que se ejecuten m\u00faltiples instrucciones basadas en la evaluaci\u00f3n del if-then. Hay que tener en cuenta que la primera instrucci\u00f3n no contiene un bloque dentro de la secci\u00f3n de impresi\u00f3n, pero podr\u00eda tenerlo. Para mejorar la legibilidad del c\u00f3digo, se considera una buena pr\u00e1ctica colocar los bloques dentro de las sentencias if-then, as\u00ed como muchas otras sentencias de control de flujo, aunque no es obligatorio. a. Sangr\u00eda y llaves Echar un vistazo a esta forma ligeramente modificada del ejemplo: if(hourOfDay < 11) System.out.println(\"Good Morning\"); morningGreetingCount++; Si se observan las sangr\u00edas, se puede pensar que la variable morningGreetingCount solo se va a incrementar cuando la hora sea menor que 11, pero no es lo que hace el c\u00f3digo. Mostrar\u00e1 el mensaje solo si la hora es menor que 11 pero incrementar\u00e1 el valor de la variable siempre. Recuerda que en Java los espacios en blanco no son considerados parte de la ejecuci\u00f3n. 4.5.2. if-then-else Se va a complicar el ejemplo anterior, \u00bfqu\u00e9 pasar\u00eda si se quisiera mostrar otro mensaje cuando la hora sea mayor o igual a 11? if(hourOfDay < 11) { System.out.println(\"Good Morning\"); } if(hourOfDay >= 11) { System.out.println(\"Good Afternoon\"); } Esto es un poco redundante, ya que estamos evaluando hourOfDay dos veces, y esto puede ser computacionalmente costoso. Java permite solucionar esto gracias a la sentencia if-then-else que se muestra en el siguiente c\u00f3digo: if(booleanExpression){ // Branch if true } else { // Branch if false } Veamos este ejemplo: if(hourOfDay < 11) { System.out.println(\"Good Morning\"); } else { System.out.println(\"Good Afternoon\"); } Ahora el c\u00f3digo se est\u00e1 ramificando entre una de las dos opciones posibles, con la evaluaci\u00f3n booleana solo una vez. El operador else utiliza una declaraci\u00f3n o un bloque, de la misma manera que la sentencia if. De esta manera, se puede agregar declaraciones if-then adicionales a un bloque else para llegar a un ejemplo m\u00e1s refinado: if(hourOfDay < 11) { System.out.println(\"Good Morning\"); }else if(hourOfDay < 15) { System.out.println(\"Good Afternoon\"); }else{ System.out.println(\"Good Evening\"); } En este ejemplo, el proceso de Java continuar\u00e1 la ejecuci\u00f3n hasta que encuentre un if-then que se eval\u00fae como verdadero. Si ninguna de las dos primeras expresiones es verdadera, se ejecutar\u00e1 el c\u00f3digo del bloque else del final. Una cosa a tener en cuenta al crear complejas declaraciones if-then-else es que el orden es importante. Por ejemplo, si se reordena el fragmento de c\u00f3digo anterior de la siguiente manera: if(hourOfDay < 15) { System.out.println(\"Good Afternoon\"); } else if(hourOfDay < 11) { System.out.println(\"Good Morning\"); // UNREACHABLE CODE } else { System.out.println(\"Good Evening\"); } Para horas menores que 11, este c\u00f3digo se comporta de forma diferente al anterior. Si un valor es menor que 11, ser\u00e1 tambi\u00e9n menor que 15. Por lo tanto, si se puede alcanzar la segunda rama en el ejemplo, tambi\u00e9n se puede alcanzar la primera rama. Ya que la ejecuci\u00f3n de cada rama es excluyente, solo una rama se puede ejecutar, si se ejecuta la primera rama no se podr\u00e1 ejecutar la segunda. Por lo tanto, no hay forma de que la segunda rama se ejecute alguna vez, y el c\u00f3digo se considera inalcanzable. a. Verificando si la sentencia if se eval\u00faa en una expresi\u00f3n booleana Echar un vistazo a las siguientes l\u00edneas de c\u00f3digo: int x = 1; if(x) { // DOES NOT COMPILE ... } Esta declaraci\u00f3n puede ser v\u00e1lida en algunos otros lenguajes de programaci\u00f3n y scripting, pero no en Java, donde 0 y 1 no se consideran valores booleanos. Adem\u00e1s, hay que tener cuidado con los operadores de asignaci\u00f3n que se utilizan como si fueran operadores iguales (==) en declaraciones if-then: int x = 1; if(x = 5) { // DOES NOT COMPILE ... } 4.5.3. Operador Ternario Ahora que se ha visto las declaraciones if-then-else, se puede volver brevemente a la discusi\u00f3n de los operadores y presentar al \u00faltimo operador. El operador condicional,? :, tambi\u00e9n conocido como operador ternario, es el \u00fanico operador que utiliza tres operandos y tiene la forma: booleanExpression? expression1 : expression2 El primer operando debe ser una expresi\u00f3n booleana, y el segundo y el tercero pueden ser cualquier expresi\u00f3n que devuelva un valor. La operaci\u00f3n ternaria es realmente una forma condensada de un ifthen- else que devuelve un valor. Por ejemplo, los siguientes dos fragmentos de c\u00f3digo son equivalentes: int y = 10; final int x; if(y > 5) { x = 2 * y; } else { x = 3 * y; } Comparar el c\u00f3digo anterior con el siguiente c\u00f3digo equivalente con el operador ternario: int y = 10; int x = (y > 5)? (2 * y) : (3 * y); Tener en cuenta que a menudo es \u00fatil para la legibilidad agregar par\u00e9ntesis alrededor de las expresiones en operaciones ternarias, aunque no es necesario. No es necesario que la segunda y tercera expresiones tengan los mismos tipos de datos, aunque puede entrar en juego cuando se combina con la asignaci\u00f3n operador. Comparar las siguientes dos afirmaciones: System.out.println((y > 5)? 21 : \"Zebra\"); int animal = (y < 91)? 9 : \"Horse\"; // DOES NOT COMPILE Ambas expresiones eval\u00faan valores booleanos similares y devuelven un int y un String, aunque solo se compilar\u00e1 la primera l\u00ednea. El System.out.println () no se preocupa de que las sentencias sean de tipos completamente diferentes, ya que pueden convertir ambos a String. Por otro lado, el compilador sabe que \"Horse\" es de un tipo de datos incorrecto y no puede ser asignado a un int; por lo tanto, no permitir\u00e1 que se compile el c\u00f3digo. a. Evaluaci\u00f3n de las expresiones ternarias A partir de Java 7, solo una de las expresiones de la derecha del operador ternario ser\u00e1 evaluado en tiempo de ejecuci\u00f3n. De manera similar a los operadores de cortocircuito, si una de las dos expresiones de la derecha del operador ternario realiza un efecto secundario, entonces no se puede aplicar en tiempo de ejecuci\u00f3n. Vamos a ilustrar este principio con el siguiente ejemplo: int y = 1; int z = 1; final int x = y<10? y++ : z++; System.out.println(y+\",\"+z); // Outputs 2,1 Tener en cuenta que como la parte de la izquierda de la expresi\u00f3n es verdadera solo se incrementa y. Contr\u00e1star con el siguiente ejemplo: int y = 1; int z = 1; final int x = y>=10? y++ : z++; System.out.println(y+\",\"+z); // Outputs 1,2 Ahora que la expresi\u00f3n booleana de la izquierda se eval\u00faa como falsa, solo z se incrementa. De esta manera, se ve c\u00f3mo las expresiones en un operador ternario pueden no aplicarse si la expresi\u00f3n particular no se usa. ### 4.5.4. switch Una sentencia switch, como se muestra en la Figura 2.4, es una estructura compleja de toma de decisiones en el que se eval\u00faa un solo valor y el flujo se redirige a la primera rama correspondiente, conocida como \u201ccase\u201d. Si no se encuentra dicha declaraci\u00f3n de caso que coincida con el valor, una opci\u00f3n predeterminada ser\u00e1 ejecutada. Si no hay tal opci\u00f3n predeterminada disponible, la totalidad de la sentencia switch ser\u00e1 omitida. a. Tipos de datos soportados Como se muestra en el siguiente c\u00f3digo, una instrucci\u00f3n switch tiene una variable que se eval\u00faa en tiempo de ejecuci\u00f3n. Antes de Java 5.0, esta variable solo pod\u00eda ser valores int o aquellos valores que pod\u00edan ser transformados a int, de forma espec\u00edfica byte, short, char o int. Cuando se agreg\u00f3 \u201cenum\u201d en Java 5.0, se agreg\u00f3 el soporte para que los switch pudiesen admitir valores \u201cenum\u201d. En Java 7, las sentencias switch se actualizaron a\u00fan m\u00e1s para permitir los valores string. Finalmente, la sentencia switch es compatible con cualquiera de las clases primitivas de car\u00e1cter num\u00e9rico, como Byte, Short, Character o Integer. switch(variableToTest) { case constantExpression1: // Branch for case1; break; case constantExpression2: // Branch for case2; break; ... default: } Tipos de datos soportados por la sentencia switch: - int y Integer - byte y Byte - short y Short - char y Character - String - Valores enum b. Valores constantes en tiempo de compilaci\u00f3n Los valores de cada case deben ser del mismo tipo de dato que el valor introducido en el switch. Esto significa que solo se pueden utilizar literales, constantes enum o variables constantes finales del mismo tipo de datos. Ejemplo: int dayOfWeek = 5; switch(dayOfWeek) { default: System.out.println(\"Weekday\"); break; case 0: System.out.println(\"Sunday\"); break; case 6: System.out.println(\"Saturday\"); break; } Con el valor de dayOfWeek de 5 el c\u00f3digo devolver\u00e1 \u201cWeekday\u201d. Lo primero que se puede notar es que hay una sentencia break al final de cada case y la secci\u00f3n predeterminada(default). Se discutir\u00e1 las sentencias break en detalle cuando se vean los bucles, pero por ahora, todo lo que se necesita saber es que finaliza la sentencia switch y el control de flujo vuelve a la sentencia adjunta. Como se ver\u00e1 pronto, si se omite la declaraci\u00f3n del break, el flujo continuar\u00e1 hasta el siguiente caso en curso o bloque predeterminado. Otra cosa que se puede notar es que el bloque predeterminado no est\u00e1 al final del switch. No es un requisito que el caso o las declaraciones predeterminadas est\u00e9n en un orden en particular, a menos que tenga v\u00edas que lleguen a m\u00faltiples secciones del bloque switch en una sola ejecuci\u00f3n. Para ilustrar lo aprendido se considerar\u00e1 la siguiente variaci\u00f3n: int dayOfWeek = 5; switch(dayOfWeek) { case 0: System.out.println(\"Sunday\"); default: System.out.println(\"Weekday\"); case 6 : System.out.println(\"Saturday\"); break; } Este c\u00f3digo se parece mucho al ejemplo anterior, excepto que dos de las declaraciones break han sido eliminadas y el orden ha cambiado. Esto significa que por el valor dado de dayOfWeek, 5, el c\u00f3digo saltar\u00e1 al bloque predeterminado y luego ejecutar\u00e1 todos los case en orden hasta que encuentre una sentencia break o finalice la estructura. El orden de los case y del bloque predeterminado es importante ahora ya que dejando el bloque predeterminado al final del switch, este, solo devolver\u00e1 una palabra. Si el valor de dayOfWeek fuese 6 el switch devolver\u00eda \u201cSaturday\u201d. Aunque el bloque predeterminado estaba antes del bloque case, solo se ejecut\u00f3 el bloque case. Si se recuerda la definici\u00f3n del bloque predeterminado, solo se ramificar\u00e1 si no ha coincidido el valor del caso con el valor del switch, independientemente de su posici\u00f3n dentro del switch. Por \u00faltimo, si el valor de dayOfWeek fuese 0, la salida mostrar\u00eda: Sunday Weekday Saturday Tener en cuenta que, en este \u00faltimo ejemplo, se ejecuta el bloque predeterminado porque no hay una instrucci\u00f3n break al final de los bloques de case anteriores. Mientras el c\u00f3digo no se ramifique hacia la sentencia predeterminada si hay un valor de case que coincida dentro de la declaraci\u00f3n del switch, se ejecutar\u00e1 la instrucci\u00f3n predeterminada si se encuentra despu\u00e9s de una declaraci\u00f3n de case para la que no hay declaraci\u00f3n de break. Conclusi\u00f3n, se acepta que el tipo de datos para las declaraciones de case, debe coincidir con el tipo de datos de la variable del switch. Como ya se discuti\u00f3, el valor de la declaraci\u00f3n de case tambi\u00e9n debe ser una constante literal, enum o una variable final. Por ejemplo, dada la siguiente instrucci\u00f3n switch, observar qu\u00e9 afirmaciones de case compilar\u00e1n y cuales no: private int getSortOrder(String firstName, final String lastName) { String middleName = \"Patricia\"; final String suffix = \"JR\"; int id = 0; switch(firstName){ case \"Test\": return 52; case middleName: // DOES NOT COMPILE id = 5; break; case suffix: id = 0; break; case lastName: // DOES NOT COMPILE id = 8; break; case 5: // DOES NOT COMPILE id = 7; break; case 'J': // DOES NOT COMPILE id = 10; break; case java.time.DayOfWeek.SUNDAY: // DOES NOT COMPILE id = 15; break; } return id; } La primera declaraci\u00f3n de case compila sin problemas usando un String, y es un buen ejemplo de c\u00f3mo una declaraci\u00f3n de return, se puede usar para salir del switch. La segunda declaraci\u00f3n de case no se compila porque middleName no es una variable final, a pesar de tener un valor conocido en esta l\u00ednea de ejecuci\u00f3n en particular. La tercera declaraci\u00f3n compila sin problema porque suffix es una variable constante final. La cuarta declaraci\u00f3n, aunque LastName sea final, no es una constante ya que se ha pasado a la funci\u00f3n, por lo tanto, esta l\u00ednea tampoco compila. Finalmente, los tres \u00faltimos case no compilan porque ninguno de ellos coincide con el tipo String de la variable del switch, el \u00faltimo es de tipo enum value. ### 4.5.5. while Una estructura de control de repetici\u00f3n, tambi\u00e9n conocida como bucle, ejecuta el mismo c\u00f3digo varias veces seguidas. Mediante el uso de variables no constantes, cada repetici\u00f3n de la sentencia puede ser diferente. Por ejemplo, una declaraci\u00f3n que se itera sobre una lista de nombres \u00fanicos y las salidas devolver\u00e1n un nuevo nombre en cada ejecuci\u00f3n del bucle. La estructura de control de repetici\u00f3n m\u00e1s simple en Java es la instrucci\u00f3n while, descrita en el siguiente c\u00f3digo. Como todas las estructuras de control de repetici\u00f3n, tiene una condici\u00f3n de terminaci\u00f3n, implementada como una expresi\u00f3n booleana, que continuar\u00e1 mientras la expresi\u00f3n se eval\u00fae a true. while(booleanExpression){ //Body } Como se muestra en el c\u00f3digo, un bucle while es similar a las sentencias if-then ya que est\u00e1 compuesta por una expresi\u00f3n booleana e instrucciones o bloque de instrucciones. Durante la ejecuci\u00f3n, la expresi\u00f3n booleana es evaluada antes de cada iteraci\u00f3n del bucle y termina si la evaluaci\u00f3n devuelve un false. Es importante darse cuenta que el bucle while puede terminar despu\u00e9s de su primera evaluaci\u00f3n de la expresi\u00f3n booleana. De esta forma el bloque de instrucciones puede no ejecutarse nunca. Si se vuelve al ejemplo de rat\u00f3n del cap\u00edtulo 3 y se muestra un bucle que puede ser utilizado para modelar un rat\u00f3n comiendo una comida: int roomInBelly = 5; public void eatCheese(int bitesOfCheese) { while(bitesOfCheese > 0 && roomInBelly > 0) { bitesOfCheese--; roomInBelly--; } System.out.println(bitesOfCheese+\" pieces of cheese left\"); } Este m\u00e9todo coge una cantidad de comida, en este caso de queso, y continua hasta que el rat\u00f3n no tenga m\u00e1s espacio en su est\u00f3mago o no quede comida para comer. Con cada iteraci\u00f3n del bucle, el rat\u00f3n come un trozo de comida y pierde una parte del espacio en su est\u00f3mago. Utilizando una sentencia booleana compuesta, nos aseguramos de que el bucle while pueda terminar por cualquiera de las condiciones. a. Bucles infinitos Considerar el siguiente c\u00f3digo: int x = 2; int y = 5; while(x < 10) y++; Se puede observar un evidente problema con esta declaraci\u00f3n: nunca acabar\u00e1. La expresi\u00f3n booleana que se eval\u00faa antes de cada iteraci\u00f3n del bucle nunca se modifica por lo que la expresi\u00f3n (x < 10) siempre ser\u00e1 evaluada a true. El resultado es que el bucle nunca acabar\u00e1 creando lo que se conoce como bucle infinito. Los bucles infinitos son algo que se debe tener en cuenta al crear bucles. Se tiene que estar seguro de que el bucle termina bajo alguna condici\u00f3n. Primero comprobar que la variable del bucle se modifica. Luego, asegurarse que la condici\u00f3n de terminaci\u00f3n se alcanza bajo cualquier circunstancia. Como se ver\u00e1 en \u201cEntendiendo los flujos de control avanzados\u201d de un bucle se puede salir tambi\u00e9n con otras condiciones como con la sentencia break. ### 4.5.6. do-while Java tambi\u00e9n permite crear bucles do-while, que como al bucle while, es una estructura de control de repetici\u00f3n con una condici\u00f3n de terminaci\u00f3n e instrucciones o bloques de instrucciones, como se muestra en el siguiente c\u00f3digo. Al contrario que el bucle while, el bucle do-while garantiza que la instrucci\u00f3n o el bloque de instrucciones se ejecutar\u00e1 m\u00ednimo una vez. do{ //Body }while(booleanExpression); La principal diferencia entre la estructura del do-while y del while es que ordena intencionadamente las instrucciones o los bloques de instrucciones antes de la expresi\u00f3n condicional, para recalcar que la instrucci\u00f3n ser\u00e1 ejecutada antes de evaluar la expresi\u00f3n. Por ejemplo, mirar la salida del siguiente c\u00f3digo: int x = 0; do { x++; }while(false); System.out.println(x); // Outputs 1 Java ejecutar\u00e1 primero el bloque de instrucciones, y luego comprobar\u00e1 la condici\u00f3n del bucle. A pesar de que el bucle termina inmediatamente, el bloque de instrucciones se ejecuta una vez y el programa devuelve 1. a. Cuando usar bucles while o do-while En la pr\u00e1ctica, puede ser dif\u00edcil determinar cu\u00e1ndo se debe utilizar un bucle while y un bucle do-while. No importa cual se utilice ya que cualquier bucle while se puede convertir en un bucle do-while y viceversa. Comparar estos dos bucles: while(x > 10) { x--; } if(x > 10) { do { x--; }while(x > 10); } Aunque uno de los bucles es m\u00e1s f\u00e1cil de leer, son funcionalmente iguales. Java recomienda utilizar los bucles while cuando no sea necesario ejecutar sus instrucciones, y utilizar los bucles do-while cuando sea imprescindible que se ejecute como m\u00ednimo una vez, pero, en la pr\u00e1ctica, elegir entre uno u otro es algo personal. Por ejemplo, pese a que la primera declaraci\u00f3n es m\u00e1s corta, la segunda tiene una ventaja que permite hacer uso de la sentencia if-then y realizar otras operaciones en la rama del else, como se muestra en el ejemplo: if(x > 10) { do { x-- ; }while(x > 10); } else { x++; } ### 4.5.7. La sentencia for Ahora se extender\u00e1 el conocimiento con otra estructura de control repetici\u00f3n llamada \u201cfor\u201d. Existen dos tipos de sentencia for, la primera se refiere al bucle simple for, la segunda se llama for-each que es una mejora de la sentencia for. a. La sentencia for simple Un bucle for simple tiene la misma condici\u00f3n booleana o bloque de instrucciones que los otros bucles que hemos visto, e incluye dos nuevas secciones: la inicializaci\u00f3n y la actualizaci\u00f3n. El siguiente c\u00f3digo muestra como estos componentes est\u00e1n organizados: for(initialization; booleanExpression; updateStatement) { // Body } El c\u00f3digo puede parecer algo confusa y arbitraria al principio, la organizaci\u00f3n de los componentes y el flujo permite crear poderosas sentencias en poco espacio al contrario de otros bucles que necesitar\u00edan m\u00faltiples l\u00edneas. Fijarse que cada secci\u00f3n est\u00e1 separada por punto y coma (;) y la inicializaci\u00f3n y la actualizaci\u00f3n pueden contener varias sentencias separadas por comas. Las variables creadas en el bloque de inicializaci\u00f3n tienen un \u00e1mbito limitado y solo ser\u00e1n accesibles dentro del bucle for. Alternativamente, las variables declaradas antes del for y modificadas en el bloque de inicializaci\u00f3n pueden ser utilizadas fuera del bucle for ya que su \u00e1mbito es anterior a la creaci\u00f3n del bucle for. A continuaci\u00f3n, este ejemplo imprime en pantalla los n\u00fameros del 0 al 9: for(int i = 0; i < 10; i++) { System.out.print(i + \" \"); } La variable local i se inicializa a 0. Esta variable tiene un \u00e1mbito dentro del bucle y no es accesible desde fuera del bucle una vez el bucle haya terminado. Como en los bucles while, la expresi\u00f3n booleana es evaluada en cada iteraci\u00f3n del bucle antes de que se ejecuten las instrucciones del este. Si devuelve un true, el bucle se ejecuta e imprime el 0 seguido de un espacio en blanco. Luego el bucle ejecuta el bloque de actualizaci\u00f3n, que en este caso incrementa el valor de i a 1. Entonces el bucle eval\u00faa otra vez la expresi\u00f3n booleana y el proceso se repite varias veces, imprimiendo lo siguiente: 0 1 2 3 4 5 6 7 8 9 En la d\u00e9cima iteraci\u00f3n del bucle, el valor de i alcanza el 9 y se incrementa a 10. En la und\u00e9cima iteraci\u00f3n del bucle la expresi\u00f3n booleana ser\u00e1 evaluada a falso ya que 10 no es menor que 10, el bucle terminar\u00e1 sin ejecutar el bloque de instrucciones. Ejemplos con los que familiarizarse: - Creaci\u00f3n de un bucle infinito for( ; ; ) { System.out.println(\"Hello World\"); } Puede parecer que este bucle for dar\u00e1 problemas de compilaci\u00f3n, pero compilar\u00e1 y funcionar\u00e1 sin problemas. Es un bucle infinito que imprimir\u00e1 el mismo mensaje repetidas veces. Este ejemplo refuerza la idea de que los componentes del bucle for son opcionales, y recuerda que el punto y coma que separa las secciones son necesarios, for() no compilar\u00e1. - Adici\u00f3n de varios t\u00e9rminos a la sentencia for int x = 0; for(long y = 0, z = 4; x < 5 && y < 10; x++, y++) { System.out.print(y + \" \"); } System.out.print(x); Este c\u00f3digo demuestra tres variaciones del bucle for que puede que a\u00fan no se hayan visto. Primero, se puede declarar una variable, como x en el ejemplo, antes de que el bucle empiece y usarla despu\u00e9s de que termine. Segundo, el bloque de inicializaci\u00f3n, la expresi\u00f3n booleana, y el bloque de actualizaci\u00f3n, pueden incluir variables extra que pueden no referenciarse entre ellas. Por ejemplo, z est\u00e1 definida en el bloque de inicializaci\u00f3n y nunca se usa. Finalmente, el bloque de actualizaci\u00f3n puede modificar m\u00faltiples variables. El c\u00f3digo imprimir\u00e1: 0 1 2 3 4 - Re-declarando una variable en el bloque de inicializaci\u00f3n int x = 0; for(long y = 0, x = 4; x < 5 && y < 10; x++, y++) { // DOES NOT COMPILE System.out.print(x + \" \"); } Este ejemplo parece similar al anterior, pero no compila debido al bloque de inicializaci\u00f3n. La diferencia es que x se repite en el bloque de inicializaci\u00f3n despu\u00e9s de haber sido declarado ya antes del loop, dando lugar a que el compilador se detenga debido a una declaraci\u00f3n de variable duplicada. Se puede fijar este bucle cambiando la declaraci\u00f3n de x y y como sigue: int x = 0; long y = 10; for(y = 0, x = 4; x < 5 && y < 10; x++, y++) { System.out.print(x + \" \"); } Tener en cuenta que esta variaci\u00f3n si compilar\u00e1 porque el bloque de inicializaci\u00f3n simplemente asigna un valor a x y no lo declara. - Utilizando tipos de datos incompatibles en el bloque de inicializaci\u00f3n for(long y = 0, int x = 4; x < 5 && y<10; x++, y++) { // DOES NOT COMPILE System.out.print(x + \" \"); } Este ejemplo tambi\u00e9n se parece mucho al segundo ejemplo, pero como en el tercer ejemplo no compilar\u00e1, aunque esta vez por una raz\u00f3n diferente. Las variables del bloque de inicializaci\u00f3n deben ser del mismo tipo. En el primer ejemplo, y y z eran ambos long, as\u00ed que el c\u00f3digo compilar\u00e1 sin problema, pero en este ejemplo tienen tipos diferentes, por lo que el c\u00f3digo no se compilar\u00e1. - Usando variables del bucle fuera de este for(long y = 0, x = 4; x < 5 && y < 10; x++, y++) { System.out.print(y + \" \"); } System.out.print(x); // DOES NOT COMPILE La variaci\u00f3n final del segundo ejemplo no compilar\u00e1 por una raz\u00f3n diferente a la de los ejemplos anteriores. Fijarse que x se define en el bloque de inicializaci\u00f3n del bucle, y luego se usa despu\u00e9s de que el bucle termine. Puesto que x s\u00f3lo tiene \u00e1mbito para el bucle, usarlo fuera del bucle lanzar\u00e1 un error de compilaci\u00f3n. ### 4.5.8. La sentencia for-each A partir de Java 5.0, los desarrolladores han tenido una mejora para el bucle for a su disposici\u00f3n, uno espec\u00edficamente dise\u00f1ado para iterar sobre arrays y colecci\u00f3n de objetos. Esto mejora el bucle for, que para mayor claridad se har\u00e1 referencia a \u00e9l como un bucle for-each, como se muestra en el siguiente c\u00f3digo: for(datatype instance : collection){ //Body } La declaraci\u00f3n del bucle for-each est\u00e1 compuesta por una secci\u00f3n de inicializaci\u00f3n y un objeto para utilizarlo repetidas veces. El lado derecho de la sentencia for-each debe ser un array o un objeto que implemente la clase Java.lang.Iterable, que incluye la mayor parte de los frameworks de Java Collections. El lado izquierdo del bucle for-each debe incluir una declaraci\u00f3n para una instancia de una variable, cuyo tipo coincida con el tipo de un miembro del array o de la colecci\u00f3n en el lado derecho de la sentencia. Ejemplos: final String[] names = new String[3]; names[0] = \"Lisa\"; names[1] = \"Kevin\"; names[2] = \"Roger\"; for(String name : names) { System.out.print(name + \", \"); } Este c\u00f3digo compilar\u00e1 e imprimir\u00e1: Lisa, Kevin, Roger, java.util.List<String> values = new java.util.ArrayList<String>(); values.add(\"Lisa\"); values.add(\"Kevin\"); values.add(\"Roger\"); for(String value : values) { System.out.print(value + \", \"); } Este c\u00f3digo compilar\u00e1 e imprimir\u00e1: Lisa, Kevin, Roger, String names = \"Lisa\"; for(String name : names) { // DOES NOT COMPILE System.out.print(name + \" \"); } En este ejemplo, el String names no es un array y no implementa la clase java.lang.iterable, as\u00ed que el compilador lanzar\u00e1 una excepci\u00f3n ya que no sabe como iterar un String. String[] names = new String[3]; for(int name : names) { // DOES NOT COMPILE System.out.print(name + \" \"); } Este c\u00f3digo no compilar\u00e1 porque en el lado izquierdo del bucle no se define una instancia de String. N\u00f3tese que, en este \u00faltimo ejemplo, el array se inicializa con tres valores de puntero cero. En s\u00ed mismo, eso no causar\u00e1 un fallo de compilaci\u00f3n, s\u00f3lo imprimir\u00e1 tres veces cero. a. Comparaci\u00f3n del bucle for y el bucle for-each Dado que for y for-each usan la misma palabra clave, es posible preguntarse c\u00f3mo est\u00e1n relacionados. Tomar un momento para explorar c\u00f3mo el compilador convierte cada for-each en bucles for. Cuando se introdujo el bucle for-each en Java 5, se agreg\u00f3 como una mejora de compilaci\u00f3n. Esto significa que Java realmente convierte el bucle for-each en un bucle for est\u00e1ndar durante compilaci\u00f3n. Por ejemplo, asumiendo que names es un array de String[] como se vio en la primera parte. Ejemplo, los dos bucles siguientes son equivalentes: for(String name : names) { System.out.print(name + \", \"); } for(int i=0; i < names.length; i++) { String name = names[i]; System.out.print(name + \", \"); } Para los objetos que heredan de Java.lang.iterable, hay una conversi\u00f3n diferente, pero similar. Por ejemplo, asumiendo que los valores son una instancia de List , como vimos en el segundo caso ejemplo, los dos bucles siguientes son equivalentes: for(int value : values) { System.out.print(value + \", \"); } for(java.util.Iterator<Integer> i = values.iterator(); i.hasNext(); ) { int value = i.next(); System.out.print(value + \", \"); } Observar que, en la segunda versi\u00f3n, no hay declaraci\u00f3n de actualizaci\u00f3n ya que no se requiere cuando se usa la clase java.util.Iterator. Es posible que se haya notado que, en los ejemplos anteriores, hab\u00eda una coma extra impresa al final de la lista: Lisa, Kevin, Roger, Mientras que la declaraci\u00f3n for-each es conveniente para trabajar con listas en muchos casos, oculta el acceso a la variable iterator del bucle. Si se quisiera imprimir s\u00f3lo la coma entre nombres, se podr\u00eda convertir el ejemplo en un bucle for est\u00e1ndar, como en el ejemplo siguiente: java.util.List names = new java.util.ArrayList (); names.add(\"Lisa\"); names.add(\"Kevin\"); names.add(\"Roger\"); for(int i=0; i 0) { System.out.print(\", \"); } System.out.print(name); } Este c\u00f3digo de muestra producir\u00eda lo siguiente: Lisa, Kevin, Roger Tambi\u00e9n es com\u00fan utilizar un bucle for sobre un bucle for-each si se comparan m\u00faltiples elementos en un bucle dentro de una sola iteraci\u00f3n, como en el ejemplo siguiente. Observar que se salta la ejecuci\u00f3n del primer bucle, ya que el valor[-1] no est\u00e1 definido y arrojar\u00eda un IndexOutOfBoundsException error. int[] values = new int[3]; values[0] = 10; values[1] = new Integer(5); values[2] = 15; for(int i=1; i<values.length; i++) { System.out.print(values[i]-values[i- 1]); } Este c\u00f3digo devolver\u00e1 lo siguiente: - 5, 10, A pesar de estos ejemplos, los bucles mejorados for-each son bastante \u00fatiles en Java en una gran variedad de circunstancias. Como desarrollador, sin embargo, siempre se puede volver a un for est\u00e1ndar si se necesita un control m\u00e1s fino. ## 4.6. Comprendiendo el control de flujo avanzado Hasta ahora, se ha tratado con bucles simples que s\u00f3lo terminaban cuando su expresi\u00f3n booleana es evaluada como falsa. Ahora se mostrar\u00e1 otras formas en la que los bucles podr\u00edan terminar, o ramificar, y se ver\u00e1 que el camino tomado durante el tiempo de ejecuci\u00f3n puede no ser tan sencillo como en los ejemplos anteriores. ### 4.6.1. Bucles anidados En primer lugar, los bucles pueden contener otros bucles. Por ejemplo, considerar el siguiente c\u00f3digo que itera sobre una matriz bidimensional, una matriz que contiene otras matrices como sus miembros. Se cubrir\u00e1 los arreglos multidimensionales en detalle en el Cap\u00edtulo 3, pero por ahora se supondr\u00e1 que la siguiente es la forma de declarar un arreglo bidimensional. int[][] myComplexArray = {{5,2,1,3},{3,9,8,9},{5,7,12,7}}; for(int[] mySimpleArray : myComplexArray) { for(int i=0; i<mySimpleArray.length; i++) { System.out.print(mySimpleArray[i]+\"\\t\"); } System.out.println(); } N\u00f3tese que en este ejemplo se mezcla intencionalmente un bucle for y uno for-each. Los bucles externos se ejecutar\u00e1n un total de tres veces. Cada vez que se ejecuta el bucle exterior, el bucle interior se ejecutar\u00e1 cuatro veces. Cuando se ejecuta este c\u00f3digo, se ve la siguiente salida: 5 2 1 3 3 9 8 9 5 7 12 7 Los bucles anidados pueden incluir bucles while y do-while, como se muestra en este ejemplo. Ver si se puede determinar lo que este c\u00f3digo saldr\u00e1. int x = 20; while(x>0) { do { x -= 2 }while (x>5); x--; System.out.print(x+\"\\t\"); } La primera vez que este bucle se ejecuta, el bucle interno se repite hasta que el valor de x es 4. El valor ser\u00e1 entonces decrementado a 3 y ser\u00e1 la salida, al final de la primera iteraci\u00f3n del bucle exterior. En la segunda iteraci\u00f3n del bucle exterior, el do-while interno se ejecutar\u00e1 una vez, aunque x no sea mayor que 5. Recordar que las sentencias do-while siempre se ejecutan al menos una vez. Esto reducir\u00e1 el valor a 1, que ser\u00e1 decrementado a\u00fan m\u00e1s por el operador de decremento en el bucle exterior a 0. Una vez que el valor alcance 0, el bucle externo se termina. El resultado es que el c\u00f3digo emitir\u00e1 lo siguiente: 3 0 ### 4.6.2. A\u00f1adiendo etiquetas opcionales Una cosa que se omite cuando se presentan las sentencias if-then, las sentencias switch y bucles es que todos ellos pueden tener etiquetas opcionales. Una etiqueta es un puntero opcional a la cabeza de una instrucci\u00f3n que permite a la aplicaci\u00f3n saltar a ella o acabar. Es una sola palabra que procede de dos puntos (:). Por ejemplo, se puede a\u00f1adir etiquetas opcionales a uno de los ejemplos anteriores: int[][] myComplexArray = {{5,2,1,3},{3,9,8,9},{5,7,12,7}}; OUTER_LOOP: for(int[] mySimpleArray : myComplexArray) { INNER_LOOP: for(int i=0; i<mySimpleArray.length; i++) { System.out.print(mySimpleArray[i]+\"\\t\"); } System.out.println(); } Cuando se trata de un solo bucle, no a\u00f1aden ning\u00fan valor, pero como se ver\u00e1 en la siguiente secci\u00f3n, son extremadamente \u00fatiles en entornos anidados. Las etiquetas opcionales a menudo s\u00f3lo se utilizan en estructuras de bucle. Dicho esto, rara vez se considera una buena pr\u00e1ctica de codificaci\u00f3n hacerlo. Las etiquetas siguen las mismas reglas para los identificadores. En cuanto a la legibilidad, se expresan com\u00fanmente en may\u00fasculas, con barra baja entre palabras, para distinguirlas de las variables regulares. ### 4.6.3. La declaraci\u00f3n break Como se vio al trabajar con las sentencia switch, una declaraci\u00f3n break transfiere el flujo de control a la declaraci\u00f3n adjunta. Lo mismo es v\u00e1lido para las sentencias break que aparecen dentro de bucles while, do-while, y bucles for, ya que terminaran el bucle temprano, como se muestra en el siguiente c\u00f3digo: optionalLabel: while(booleanExpression) { // Body // Somewhere in loop break optionalLabel; } Observar en el c\u00f3digo que la sentencia break puede tomar un par\u00e1metro opcional de etiqueta. Sin un par\u00e1metro de etiqueta, la sentencia break terminar\u00e1 el bucle interno m\u00e1s cercano que est\u00e9 ejecutando actualmente. El par\u00e1metro de etiqueta opcional permite salir de un bucle exterior de nivel superior. En el siguiente ejemplo, se busca la primera posici\u00f3n del \u00edndice de matriz (x, y) de un n\u00famero dentro de una matriz bidimensional no clasificada: public class SearchSample { public static void main(String[] args) { int[][] list = {{1,13,5},{1,2,5},{2,7,2}}; int searchValue = 2; int positionX = -1; int positionY = -1; PARENT_LOOP: for(int i=0; i<list.length; i++) { for(int j=0; j<list[i].length; j++) { if(list[i][j]==searchValue){ positionX = i; positionY = j; break PARENT_LOOP; } } } if(positionX==-1 || positionY==-1) { System.out.println(\"Value \"+searchValue+\" not found\"); } else { System.out.println(\"Value \"+searchValue+\" found at: \" + \"(\"+positionX+\",\"+positionY+ \")\"); } } } Cuando se ejecute, este c\u00f3digo saldr\u00e1: Value 2 found at: (1,1) En particular, \u00e9chese un vistazo a la sentencia break PARENT_LOOP. Esta declaraci\u00f3n romper\u00e1 de toda la estructura del bucle tan pronto como se encuentre el primer valor que se ajuste. Ahora, imaginar lo que pasar\u00eda si se reemplazara el cuerpo del bucle interno por el siguiente: if(list[i][j]==searchValue) { positionX = i; positionY = j; break; } \u00bfC\u00f3mo cambiar\u00eda esto la salida? En lugar de salir cuando se encuentra el primer valor que coincida, el programa s\u00f3lo saldr\u00e1 del bucle interno cuando se cumpla la condici\u00f3n. En otras palabras, la estructura ahora encontrar\u00e1 el primer valor que se ajuste del \u00faltimo bucle interno que contenga el valor, resultando en la siguiente salida: Value 2 found at: (2,0) Finalmente, \u00bfqu\u00e9 tal si se elimina el break por completo? if(list[i][j]==searchValue) { positionX = i; positionY = j; } En este caso, el c\u00f3digo buscar\u00e1 el \u00faltimo valor de toda la estructura que tenga el valor equivalente. La salida se ver\u00e1 as\u00ed: Value 2 found at: (2,2) Se puede ver en este ejemplo que el uso de una etiqueta en una sentencia break en un bucle anidado, o el no uso de la sentencia break en absoluto, puede hacer que el bucle se comporte de forma muy diferente. ### 4.6.4. La sentencia continue Se completar\u00e1 ahora la discusi\u00f3n sobre el control avanzado del bucle con la sentencia continue, una declaraci\u00f3n que causa que el flujo de datos finalice la ejecuci\u00f3n del bucle actual, como se muestra en el siguiente c\u00f3digo: Se puede notar que la sintaxis de la declaraci\u00f3n continue refleja la declaraci\u00f3n break. De hecho, las sentencias son similares en cuanto a su uso, pero con resultados diferentes. Mientras que la sentencia break transfiere el control a la sentencia adjunta, la sentencia continue transfiere el control a la expresi\u00f3n booleana que determina si el bucle debe continuar. En otras palabras, termina la iteraci\u00f3n actual del bucle. Tambi\u00e9n, al igual que la declaraci\u00f3n break, la declaraci\u00f3n continue se aplica al bucle interno m\u00e1s cercano en ejecuci\u00f3n usando instrucciones de etiqueta opcionales para anular este comportamiento. Ejemplo: public class SwitchSample { public static void main(String[] args) { FIRST_CHAR_LOOP: for (int a = 1; a <= 4; a++) { for (char x = 'a'; x <= 'c'; x++) { if (a == 2 || x == 'b') continue FIRST_CHAR_LOOP; System.out.print(\" \" + a + x); } } } } Con la estructura definida, el bucle devolver\u00e1 el control al bucle padre cada vez que el primer valor sea 2 o el segundo valor sea b. Esto resulta en una ejecuci\u00f3n del bucle interno para cada una de las tres llamadas del bucle exterior. La salida se ve as\u00ed: 1a 3a 4a Ahora, imaginar que se elimina la etiqueta FIRST_CHAR_LOOP en la declaraci\u00f3n continue para que el control sea devuelto al bucle interno en vez del externo. Mirar c\u00f3mo cambiar\u00e1 la salida: 1a 1c 3a 3c 4a 4c optionalLabel: while(booleanExpression) { // Body // Somewhere in loop continue optionalLabel; } Por \u00faltimo, si se elimina la sentencia continue y la sentencia if-then asociada a \u00e9sta, se llega a una estructura que produce todos los valores, tales como: 1a 1b 1c 2a 2b 2c 3a 3b 3c 4a 4b 4c La siguiente tabla ayudar\u00e1 a recordar cuando se permiten etiquetas, break, y sentencias continue en Java. Aunque para fines ilustrativos los ejemplos han incluido el uso de estas sentencias en bucles anidados, tambi\u00e9n se pueden usar dentro de bucles simples. (^) Permite etiquetas opcionales Permite sentencias break Permite sentencias continue if Si No No while Si Si Si do while Si Si Si for Si Si Si switch Si Si No ### 4.6.1. Resumen En este cap\u00edtulo, se ha visto que: Entender los operadores de Java - C\u00f3mo utilizar todos los operadores Java requeridos que se describen. - Saber c\u00f3mo influye la precedencia del operador en la forma en que se interpreta una expresi\u00f3n determinada. Usando operadores binarios - Los operadores de asignaci\u00f3n son operadores binarios que modifican la variable con el valor del lado derecho de la ecuaci\u00f3n. - El \u201ccasting\u201d es necesario siempre que se pase de un dato num\u00e9rico m\u00e1s grande a un tipo de datos num\u00e9ricos m\u00e1s peque\u00f1os, o la conversi\u00f3n de un n\u00famero float a un valor int. - Los operadores complejos son operadores de asignaci\u00f3n con una operaci\u00f3n aritm\u00e9tica o l\u00f3gica incorporada que se aplican de izquierda a derecha de la expresi\u00f3n y almacena el valor resultante en la variable de la parte izquierda de la pantalla. - Los operadores relacionales son aquellos que comparan dos expresiones y devuelven un valor booleano. - Los operadores l\u00f3gicos, (&), (|) y (^), se pueden aplicar a datos de tipo num\u00e9ricos y booleanos. - Los operadores de igualdad comparan dos operandos y devuelven un valor booleano si las expresiones o valores son iguales, o no iguales, respectivamente. Comprender las sentencias de Java - Las estructuras de control: las estructuras de control de la toma de decisiones, incluidas las de tipo ifthen, if-then-else y switch, as\u00ed como las estructuras de control de la repetici\u00f3n, incluidas for, for-each, while y do-while. - La mayor\u00eda de estas estructuras requieren la evaluaci\u00f3n de una expresi\u00f3n booleana en particular, ya sea para las decisiones de ramificaci\u00f3n o una vez por repetici\u00f3n. - La sentencia switch es la \u00fanica que soporta una variedad de tipos de datos, incluyendo variables String a partir de Java 7. - Con un for-each no es necesario escribir expl\u00edcitamente una expresi\u00f3n booleana, ya que el compilador las construye impl\u00edcitamente. Para mayor claridad, se refiere a un bucle for mejorado como un bucle foreach, pero sint\u00e1cticamente est\u00e1n escritos como una declaraci\u00f3n for. Comprendiendo el control de flujo avanzado ``` - Los bucles pueden contener otros bucles, incluidos bucles while y do-while. - Una etiqueta es un puntero opcional a la cabeza de una instrucci\u00f3n que permite a la aplicaci\u00f3n saltar a ella o acabar. - C\u00f3mo se puede mejorar el flujo a trav\u00e9s de los bucles anidados, de sentencias break y de sentencias continue.","title":"Operaciones y Sentencias"},{"location":"operaciones_sentencias/#4-operadores-y-sentencias","text":"","title":"4. Operadores y sentencias"},{"location":"operaciones_sentencias/#41-entender-los-operadores-de-java","text":"Los operadores de java son s\u00edmbolos especiales que se aplican un grupo de variables, valores o \u201cliterales\u201d y que devuelven un valor. Existen tres tipos de operadores en Java: unario, binario y ternario. Estos tipos de operadores pueden ser aplicados a uno, dos o tres operandos. Los operadores de java no siempre se eval\u00faan de izquierda a derecha. En el siguiente ejemplo se puede observar como la expresi\u00f3n se eval\u00faa de derecha a izquierda: int y = 4; double x = 3 + 2 * --y; En el ejemplo primero se reduce en uno la variable y, despu\u00e9s se multiplica por 2 y por \u00faltimo se le suman 3. El resultado final ser\u00e1 convertido de 9 a 9.0 y asignado a la variable x. Los valores de x e y ser\u00e1n 9.0 y 3. A menos que est\u00e9n entre par\u00e9ntesis, los operadores de Java siguen un orden de operaci\u00f3n que se encuentran listados en la tabla. Si dos operadores est\u00e1n en el mismo nivel se evaluar\u00e1n de izquierda a derecha. Operador S\u00edmbolos y ejemplos Operadores post-unarios Expresi\u00f3n++, Expresi\u00f3n-- Operadores pre-unarios ++Expresi\u00f3n, --Expresi\u00f3n Operadores unarios +, -,! Multiplicaci\u00f3n, Divisi\u00f3n, M\u00f3dulo *, /, % Suma, Resta +, - Operadores de cambio <<, >>, >>> Operadores relacionales <, >, <=, >=, instanceof Igual, Distinto ==, != Operadores l\u00f3gicos &, ^, Operadores l\u00f3gicos de cortocircuito &&, Operadores ternarios Expresi\u00f3n booleana? expresi\u00f3n1 : expresi\u00f3n 2 Operadores de asignaci\u00f3n =, +=, -=, *=, /=, %=, &=, ^=, !=, <<=, >>=, >>>=","title":"4.1. Entender los operadores de Java"},{"location":"operaciones_sentencias/#42-trabajando-con-operadores-binarios-aritmeticos","text":"","title":"4.2. Trabajando con operadores binarios aritm\u00e9ticos"},{"location":"operaciones_sentencias/#421-operadores-aritmeticos","text":"Los operadores aritm\u00e9ticos son los utilizados en las matem\u00e1ticas y son los siguiente: la suma (+), la resta (-), la multiplicaci\u00f3n (*), la divisi\u00f3n (/) y el m\u00f3dulo (%). Tambi\u00e9n se incluyen los operadores unarios ++ y --. Como puedes comprobar en la tabla anterior los operadores , / y % tienen mayor orden de preferencia que los operadores + y -, por lo que la siguiente expresi\u00f3n: int x = 2 * 5 + 3 * 4 \u2013 8; Se evaluar\u00e1 primero 2 5 y 3*4 simplificando la expresi\u00f3n a la siguiente: int x = 10 + 12 \u2013 8; Despu\u00e9s se evaluar\u00e1 la expresi\u00f3n de izquierda a derecha dando como resultado 14. Se puede cambiar el orden de la operaci\u00f3n a\u00f1adiendo par\u00e9ntesis a las secciones que se quiere evaluar primero. Se compara el ejemplo de antes con el siguiente que incorpora par\u00e9ntesis: int x = 2 * ((5 + 3) * 4 \u2013 8); Esta vez se deber\u00e1 evaluar la suma 5 + 3 primero, que reducir\u00e1 la expresi\u00f3n a: int x = 2 * (8 * 4 - 8); Se podr\u00e1 reducir la expresi\u00f3n multiplicando los dos primeros valores dentro del par\u00e9ntesis: int x = 2 * (32 - 8); Despu\u00e9s se restar\u00e1 los valores de dentro del par\u00e9ntesis antes de multiplicarlos por el valor de fuera: int x = 2 * 24; Finalmente se multiplicar\u00e1n los valores restantes, dando un resultado de 48. Todos los operadores aritm\u00e9ticos pueden ser aplicados a cualquier tipo primitivo de Java, salvo los tipos boolean y string. Adem\u00e1s, solo los operadores + y += pueden ser aplicados a variables string, lo que resulta ser una concatenaci\u00f3n de string. El m\u00f3dulo es el resto de la divisi\u00f3n de dos n\u00fameros, por ejemplo 9 divido entre 3 no tiene resto por lo que 9 % 3 ser\u00e1 0. Por otra parte 11 divido entre 3 si tiene resto por lo tanto 11 % 3 ser\u00e1 igual a 2. Hay que tener clara la diferencia entre la divisi\u00f3n y el m\u00f3dulo. La divisi\u00f3n devuelve el cociente, mientras que el m\u00f3dulo devuelve el resto de la divisi\u00f3n. Los siguientes ejemplos ilustran la diferencia entre ambas operaciones: System.out.print(9 / 3); // Outputs 3 System.out.print(9 % 3); // Outputs 0 System.out.print(10 / 3); // Outputs 3 System.out.print(10 % 3); // Outputs 1 System.out.print(11 / 3); // Outputs 3 System.out.print(11 % 3); // Outputs 2 System.out.print(12 / 3); // Outputs 4 System.out.print(12 % 3); // Outputs 0 Hay que tener en cuenta que el resultado de la divisi\u00f3n solo se incrementa cuando el valor de la izquierda se incrementa de 9 a 12, mientras que el m\u00f3dulo incrementa en 1, cada vez que el valor de la izquierda se incrementa, hasta que se convierte en 0. Para un divisor dado y, que es 3 en estos ejemplos, la operaci\u00f3n de m\u00f3dulo da como resultado un valor entre 0 y (y - 1) para dividendos positivos. Esto significa que el resultado de una operaci\u00f3n de m\u00f3dulo es siempre 0,1 o 2. El funcionamiento del m\u00f3dulo no se limita a los valores enteros positivos en Java y tambi\u00e9n puede aplicarse a n\u00fameros enteros negativos y n\u00fameros enteros de coma flotante. Para un divisor \u201cy\u201d y dividendo negativo dado, el valor del m\u00f3dulo resultante est\u00e1 entre (-y + 1) y 0.","title":"4.2.1. Operadores aritm\u00e9ticos"},{"location":"operaciones_sentencias/#422-promocion-numerica","text":"Reglas de la promoci\u00f3n num\u00e9rica: Si dos variables tienes diferente tipo, Java autom\u00e1ticamente convertir\u00e1 una de las variables al tipo m\u00e1s grande de las dos. Si una de las variables es Integer y la otra de coma flotante(float), Java autom\u00e1ticamente convertir\u00e1 la variable Integer en una de coma flotante. Los tipos de datos peque\u00f1os como byte, short y char son convertidos a Int siempre que son usados por un operador aritm\u00e9tico binario, incluso si ninguno de los operandos es un Int. Despu\u00e9s de que se hayan convertido las variables y los operandos tengan el mismo tipo, el resultado se guardar\u00e1 con el mismo tipo al que se hayan convertido los operandos. Las dos \u00faltimas reglas son aquellas con las que la mayor\u00eda de la gente tiene problemas. Por lo que respecta a la tercera regla, debe tenerse en cuenta que los operadores unitarios est\u00e1n excluidos de esta. Por ejemplo, aplicar ++ a un valor short dar\u00e1 como resultado un valor short.","title":"4.2.2. Promoci\u00f3n num\u00e9rica"},{"location":"operaciones_sentencias/#43-trabajando-con-operadores-unarios","text":"Por definici\u00f3n un operador unario es uno que requiere exactamente un operando o variable para funcionar. Como se muestra en la tabla suelen realizar tareas simples como incrementar en uno una variable o negar el valor de un boolean. Operador unario Descripci\u00f3n + Indica que un n\u00famero es positivo, aunque se supone que los n\u00fameros son positivos en Java a menos que vayan acompa\u00f1ados de un operador negativo unario. - Indica que un n\u00famero es negativo o niega una expresi\u00f3n ++ Incremento una variable en 1 -- Decremento de una variable en 1 ! Invierte el valor l\u00f3gico de un boolean","title":"4.3. Trabajando con operadores unarios"},{"location":"operaciones_sentencias/#431-complemento-logico-y-operadores-de-negacion","text":"El operador de complemento l\u00f3gico(!) invierte el valor de una expresi\u00f3n booleana. Por ejemplo, si el valor es true, se invertir\u00eda a false, y viceversa. Para demostrar esto, se comparar\u00e1 la salida de las siguientes instrucciones: boolean x = false; System.out.printl(x); //false x = !x; System.out.println(x); //true Por otra parte, el operador de negaci\u00f3n (-) cambia el signo de una expresi\u00f3n num\u00e9rica como se muestra a continuaci\u00f3n: double x = 1.21; System.out.println(x); //1.21 x = -x; System.out.println(x); //-1.21 x = -x; System.out.println(x); //1.21 Si uno se basa en la descripci\u00f3n, podr\u00eda ser obvio que algunos operadores requieran la variable de un tipo espec\u00edfico. No se puede utilizar un operador de negaci\u00f3n, -, con una expresi\u00f3n booleana, ni se puede aplicar un complemento l\u00f3gico a una expresi\u00f3n num\u00e9rica. Por ejemplo, ninguna de las siguientes l\u00edneas de c\u00f3digo compilar\u00e1: int x = !5; // DOES NOT COMPILE boolean y = -true; // DOES NOT COMPILE boolean z = !0; // DOES NOT COMPILE La primera declaraci\u00f3n no se compilar\u00e1 debido al hecho de que en Java no se puede realizar una inversi\u00f3n l\u00f3gica de un valor num\u00e9rico. La segunda declaraci\u00f3n no compilar\u00e1 porque no se puede negar num\u00e9ricamente un valor booleano, es necesario utilizar el operador l\u00f3gico inverso. Finalmente, la \u00faltima sentencia no se compila porque no se puede tomar el complemento l\u00f3gico de un valor num\u00e9rico, ni se puede asignar un entero a una variable booleana.","title":"4.3.1. Complemento l\u00f3gico y operadores de negaci\u00f3n"},{"location":"operaciones_sentencias/#432-operadores-de-incremento-y-decremento","text":"Los operadores de incremento y decremento (++, --) pueden aplicarse a operandos num\u00e9ricos y tienen mayor preferencia que los operadores binarios. Los operadores de incremento y decremento requieren un cuidado especial ya que el orden en el que son utilizados con los operandos pueden provocar un procesamiento distinto de la expresi\u00f3n. Si el operador est\u00e1 situado delante del operando entonces el operador se aplica primero y luego se devuelve el valor. Por otro lado, si el operador se encuentra detr\u00e1s del operando se devuelve primero el valor original y luego se aplica el operador. El siguiente c\u00f3digo ilustra las diferencias: int counter = 0; System.out.println(counter); // Outputs 0 System.out.println(++counter); // Outputs 1 System.out.println(counter); // Outputs 1 System.out.println(counter--); // Outputs 1 System.out.println(counter); // Outputs 0 El primer operador de pre-incremento actualiza el valor del contador y devuelve el nuevo valor de 1. El siguiente operador de post-decremento tambi\u00e9n actualiza el valor del contador pero devuelve el valor antes de que se produzca la disminuci\u00f3n. El siguiente ejemplo es todav\u00eda m\u00e1s complicado ya que se modifica el valor 3 veces en la misma l\u00ednea: int x = 3; int y = ++x * 5 / x-- + --x; System.out.println(\"x is \" + x); System.out.println(\"y is \" + y); Cada vez que se modifica, la expresi\u00f3n pasa de izquierda a derecha, el valor de x cambia, con diferentes valores asignados a la variable. Como recordar\u00e1s de nuestra discusi\u00f3n sobre la precedencia del operador, el orden de la operaci\u00f3n juega un papel importante en evaluando este ejemplo. Primero, la x se incrementa y se devuelve a la expresi\u00f3n, que se multiplica por 5: int y = 4 * 5 / x-- + --x; // x con valor 4 A continuaci\u00f3n, se decrementa x, pero el valor original de 4 se utiliza en la expresi\u00f3n, lo que lleva a esto: int y = 4 * 5 / 4 + --x; // x con valor 3 La asignaci\u00f3n final de x reduce el valor a 2, y como se trata de un operador pre-incremental, se devuelve ese valor: int y = 4 * 5 / 4 + 2; // x con valor 2 Finalmente, se realiza la multiplicaci\u00f3n y a continuaci\u00f3n la divisi\u00f3n, y por \u00faltimo la suma dando como resultado: x is 2 y is 7","title":"4.3.2. Operadores de incremento y decremento."},{"location":"operaciones_sentencias/#44-usando-los-operadores-binarios-adicionales","text":"","title":"4.4. Usando los operadores binarios adicionales"},{"location":"operaciones_sentencias/#441-operadores-de-asignacion","text":"Los operadores de asignaci\u00f3n son operadores binarios que modifican la variable con el valor del lado derecho de la ecuaci\u00f3n. El operador de asignaci\u00f3n m\u00e1s simple es el operador \u201c=\u201d: int x = 1; Esta declaraci\u00f3n asigna a x el valor 1. Java transformar\u00e1 autom\u00e1ticamente de tipos de datos peque\u00f1os a grandes, como vimos en la secci\u00f3n anterior, pero lanzar\u00e1 una excepci\u00f3n de compilador si detecta que est\u00e1 intentando convertir tipos de datos grandes a peque\u00f1os. Vamos a ver unos ejemplos para demostrar como el \u201ccasting\u201d puede resolver estos problemas: int x = 1.0; // DOES NOT COMPILE short y = 1921222; // DOES NOT COMPILE int z = 9f; // DOES NOT COMPILE long t = 192301398193810323; // DOES NOT COMPILE La primera sentencia no compila porque est\u00e1 tratando de asignar un double a un valor int. A pesar de que el valor es un entero, al sumar \u201c. 0\u201d, est\u00e1 indicando al compilador que lo trate como un double. La segunda declaraci\u00f3n no compila porque el valor 1921222 est\u00e1 fuera del rango de short. La tercera declaraci\u00f3n no compila debido a la \u201cf\u201d a\u00f1adida al final del n\u00famero que indica al compilador que ha de tratar al n\u00famero como un float. Finalmente, el \u00faltimo enunciado no compila porque Java interpreta el valor como un int y nota que es mayor de lo que permite int. El \u00faltimo caso necesitar\u00eda un postfix L para ser considerado un long.","title":"4.4.1. Operadores de asignaci\u00f3n"},{"location":"operaciones_sentencias/#442-casting-de-valores-primitivos","text":"Se pueden arreglar los ejemplos de la secci\u00f3n anterior, haciendo \u201ccasting\u201d a los resultados. El \u201ccasting\u201d es necesario siempre que se pase de un dato num\u00e9rico m\u00e1s grande a un tipo de datos num\u00e9ricos m\u00e1s peque\u00f1os, o la conversi\u00f3n de un n\u00famero float a un valor int. int x = (int)1.0; short y = (short)1921222; // Stored as 20678 int z = (int)9l; long t = 192301398193810323L; Algunos ejemplos: short x = 10; short y = 3; short z = x * y; // DOES NOT COMPILE Basando todo en lo que se ha aprendido hasta ahora, \u00bfpor qu\u00e9 las \u00faltimas l\u00edneas de esta declaraci\u00f3n no compilar\u00e1n? Recordar, los valores short se transforman autom\u00e1ticamente a int con cualquier operador aritm\u00e9tico, con el valor resultante de tipo int. Tratar de establecer una variable corta en una int resulta en un error del compilador, como piensa Java, est\u00e1 intentando convertir impl\u00edcitamente de un tipo de datos m\u00e1s grande a uno m\u00e1s peque\u00f1o. Hay ocasiones en las que se puede querer anular el comportamiento predeterminado del compilador. Por ejemplo, en el ejemplo anterior, se sabe que el resultado de 10 * 3 es 30, que puede ser guardado en un short. Sin embargo, si se necesita que el resultado sea un short puede sustituirse este comportamiento haciendo \u201ccasting\u201d del resultado de la multiplicaci\u00f3n: short x = 10; short y = 3; short z = (short)(x * y); Al realizar este \u201ccasting\u201d de un tipo de datos mayor a un tipo de datos m\u00e1s peque\u00f1o, se est\u00e1 ordenando al compilador que ignore su comportamiento predeterminado. En otras palabras, se le est\u00e1 diciendo al compilador que se est\u00e1 tomando medidas adicionales para evitar el overflow o el underflow.","title":"4.4.2. Casting de valores primitivos"},{"location":"operaciones_sentencias/#overflow-y-underflow","text":"Las expresiones en el ejemplo anterior ahora compilan, aunque hay un coste. El segundo valor, 1.921.222, es demasiado grande para ser almacenado como un valor short, por lo que se produce un overflow y se convierte en 20.678. El overflow es cuando un n\u00famero es tan grande que ya no se puede guardar dentro de un tipo de datos, por lo que el sistema se \"envuelve\" en el siguiente valor m\u00ednimo y cuenta desde ah\u00ed. Tambi\u00e9n hay un underflow analogo, cuando el n\u00famero es demasiado bajo para guardarlo en el tipo de datos. Por ejemplo, la siguiente sentencia genera un n\u00famero negativo: _System.out.println(2147483647+1); // - 214748364848_ Dado que 2147483647 es el valor m\u00e1ximo de int, sumando cualquier valor estrictamente positivo a \u00e9l se obtendr\u00e1 lo siguiente al siguiente n\u00famero negativo.","title":"Overflow y Underflow"},{"location":"operaciones_sentencias/#443-operadores-de-asignacion-compuestos","text":"Adem\u00e1s del operador simple de asignaci\u00f3n, =, existen tambi\u00e9n numerosos operadores de asignaci\u00f3n compuestos. S\u00f3lo se requieren dos de los operadores compuestos enumerados en la Tabla 2.1, += y =. Los operadores complejos son en realidad una mejora de los operadores de asignaci\u00f3n simple con una operaci\u00f3n aritm\u00e9tica o l\u00f3gica incorporada que se aplican de izquierda a derecha de la expresi\u00f3n y almacena el valor resultante en la variable de la parte izquierda de la pantalla. Por ejemplo, las dos expresiones siguientes despu\u00e9s de la declaraci\u00f3n de x y z son equivalentes: int x = 2, z = 3; x = x * z; // Simple assignment operator x *= z; // Compound assignment operator El lado izquierdo del operador compuesto s\u00f3lo se puede aplicar a una variable que ya est\u00e9 definida y no se puede utilizar para declarar una nueva variable. En el ejemplo anterior, si x no estaba ya definida, entonces la expresi\u00f3n x *=z no compilar\u00eda. Los operadores compuestos son \u00fatiles para algo m\u00e1s que la mera abreviatura, tambi\u00e9n se puede ahorrar el tener que hacer \u201ccasting\u201d a un valor. Por ejemplo, si se considera el siguiente ejemplo en que la \u00faltima l\u00ednea no compilar\u00e1 debido a que el resultado es transformado a long y asignado a una variable int: long x = 10; int y = 5; y = y * x; // DOES NOT COMPILE Si uno se basa en las dos \u00faltimas secciones, se deber\u00eda poder detectar el problema en la \u00faltima l\u00ednea. Esta \u00faltima l\u00ednea podr\u00eda ser fijada con un \u201ccasting\u201d a int, pero hay una manera mejor, usando el operador de asignaci\u00f3n compuesto: long x = 10; int y = 5; y*= x; El operador compuesto har\u00e1 un \u201ccasting\u201d primero de x a long, aplicar\u00e1 la multiplicaci\u00f3n de dos valores long, y luego devolver\u00e1 el resultado a un int. A diferencia del ejemplo anterior, en el que el compilador lanzar\u00e1 una excepci\u00f3n, en este ejemplo vemos que el compilador har\u00e1 un \u201ccasting\u201d autom\u00e1ticamente del valor resultante al tipo de datos de la variable del lado izquierdo del operador compuesto. Una cosa importante que se debe saber acerca del operador de asignaci\u00f3n es que el resultado de la asignaci\u00f3n es una expresi\u00f3n en s\u00ed misma, igual al valor de la asignaci\u00f3n. Por ejemplo, el siguiente fragmento de c\u00f3digo es perfectamente v\u00e1lido, aunque un poco extra\u00f1o: long x = 5; long y = (x=3); System.out.println(x); // Outputs 3 System.out.println(y); // Also, outputs 3 La clave aqu\u00ed es que (x=3) hace dos cosas. En primer lugar, fija el valor de la variable x para que sea 3. En segundo lugar, devuelve el valor de la asignaci\u00f3n, que tambi\u00e9n es 3.","title":"4.4.3. Operadores de asignaci\u00f3n compuestos"},{"location":"operaciones_sentencias/#444-operadores-relacionales","text":"Ahora se pasar\u00e1 a los operadores relacionales, que comparan dos expresiones y devuelven un valor booleano. Los primeros cuatro operadores relacionales (ver la tabla se aplican solo a tipos de datos primitivos num\u00e9ricos. Si los dos operando num\u00e9ricos no son del mismo tipo de datos, el par\u00e1metro m\u00e1s peque\u00f1o se transforma de la manera anteriormente discutida. Operador relacional Descripci\u00f3n < Estrictamente menos que <= Menos que o igual a > Estrictamente mayor que >= Mayor que o igual a A continuaci\u00f3n, se ver\u00e1n unos ejemplos de estos operadores: int x = 10, y = 20, z = 10; System.out.println(x < y); // Outputs true System.out.println(x <= y); // Outputs true System.out.println(x >= z); // Outputs true System.out.println(x > z); // Outputs false Observar que el \u00faltimo ejemplo produce una salida false, porque, aunque x y z son el mismo valor, x no es estrictamente mayor que z. El quinto operador relacional (ver la tabla de abajo) se aplica a objetos y clases, o bien a interfaces. Operador relacional Descripci\u00f3n a instanceof b Verdadero si la referencia a la que apunta \u201ca\u201d es una instancia de una clase, subclase o clase que implementa una interfaz particular, como se nombra en b Cabe destacar lo siguiente respecto al operador instanceof: String str = null; System.out.println(str instanceof String ); // false Es decir: no basta con declarar la variable como de un tipo sino que debe ser realmente un objeto de ese tipo (como consecuencia, no es necesario comparar contra null). if (x != null && x instanceof X) ... Se puede simplificar a: if (x instanceof X) ...","title":"4.4.4. Operadores relacionales"},{"location":"operaciones_sentencias/#445-operadores-logicos","text":"Los operadores l\u00f3gicos, (&), (|) y (^), se pueden aplicar a datos de tipo num\u00e9ricos y booleanos. Cuando se aplican a tipos de datos booleanos, se los denomina operadores l\u00f3gicos. Alternativamente, cuando se aplican a tipos de datos num\u00e9ricos, se les llama operadores a nivel de bit, ya que realizan comparacionesbit a bit de los bits que componen el n\u00famero. Se debe familiarizar con las tablas de las figuras, donde se supone que x e y son tipos de datos booleanos. X & Y (AND) Y=true Y=false X = true True False X = false False False X | Y (Inclusive OR) Y=true Y=false X = true True True X = false True False X ^ Y (Exclusive OR) Y=true Y=false X = true False True X = false True False Aqu\u00ed hay algunos consejos para ayudar a recordar esta tabla: AND solo es verdadero si ambos operandos son verdaderos. OR inclusivo solo es falso si ambos operandos son falsos. Exclusive OR solo es verdadero si los operandos son diferentes. Finalmente, se presentan los operadores condicionales, && y || , que a menudo se conocen como operadores de cortocircuito. Los operadores de cortocircuito son casi id\u00e9nticos a los operadores l\u00f3gicos, & y | , respectivamente, excepto que el lado derecho de la expresi\u00f3n nunca puede ser evaluado si el resultado final puede ser determinado por el lado izquierdo de la expresi\u00f3n. Por ejemplo, si se considera la siguiente declaraci\u00f3n: boolean x = true || (y < 4); En referencia a las tablas de verdad, el valor x solo puede ser falso si ambos lados de la expresi\u00f3n son falsas. Como sabemos que el lado izquierdo es verdadero, no hay necesidad de evaluar el lado derecho, ya que nada har\u00e1 que el valor de x sea diferente de verdadero. Para ilustrar este concepto prueba a ejecutar la l\u00ednea de c\u00f3digo anterior para varios valores de y. El ejemplo m\u00e1s com\u00fan de d\u00f3nde se usan los operadores de cortocircuito es la comprobaci\u00f3n de objetos nulos antes de realizar una operaci\u00f3n, como esta: if(x != null && x.getValue() < 5) { // Do something } En este ejemplo, si x fuera nulo, entonces el cortocircuito evita lanzar una excepci\u00f3n NullPointerException, ya que la evaluaci\u00f3n de x.getValue () <5 nunca se alcanza. Alternativamente, si usamos un & l\u00f3gico, entonces ambos lados siempre se evaluar\u00e1n y cuando x fuese nulo esto arrojar\u00eda una excepci\u00f3n: if(x != null & x.getValue() < 5) { // Throws an exception if x is null // Do something } \u00bfCu\u00e1l es el resultado del siguiente c\u00f3digo? int x = 6; boolean y = (x >= 6) || (++x <= 7); System.out.println(x); Como x >= 6 es verdadero, el operador de incremento en el lado derecho de la expresi\u00f3n nunca se eval\u00faa, por lo que la salida es 6 .","title":"4.4.5. Operadores l\u00f3gicos"},{"location":"operaciones_sentencias/#446-operadores-de-igualdad","text":"La determinaci\u00f3n de la igualdad en Java puede no ser trivial, ya que hay una diferencia sem\u00e1ntica entre \"dos objetos son lo mismo\" y \"dos objetos son equivalentes\". Es a\u00fan m\u00e1s complicado por el hecho de que para tipos primitivos num\u00e9ricos (entre los que se incluye tambi\u00e9n el tipo de dato char) y booleanos, no existe tal distinci\u00f3n. Comenzando por lo m\u00e1s sencillo: el operador de igualdad (==) y el operador de desigualdad (!=). Como los operadores relacionales, comparan dos operandos y devuelven un valor booleano si las expresiones o valores son iguales o no iguales, respectivamente. Los operadores de igualdad se utilizan en uno de tres casos: Comparando dos tipos primitivos num\u00e9ricos. Si los valores num\u00e9ricos son de diferente tipo de datos, los valores se transforman autom\u00e1ticamente como se describi\u00f3 anteriormente. Por ejemplo, 5 == 5.00 devuelve verdadero ya que el lado izquierdo se transforma a un double. Comparando dos valores booleanos. Comparando dos objetos, incluidos los valores nulos y String. Las comparaciones para la igualdad se limitan a estos tres casos, por lo que no se pueden mezclar tipos. Por ejemplo, cada uno de los siguientes devolver\u00eda en un error del compilador: boolean x = true == 3; // DOES NOT COMPILE boolean y = false != \"Giraffe\"; // DOES NOT COMPILE boolean z = 3 == \"Kangaroo\"; // DOES NOT COMPILE Si se observa el siguiente fragmento: boolean y = false; boolean x = (y = true); System.out.println(x); // Outputs true A primera vista, se podr\u00eda pensar que la salida deber\u00eda ser falsa, y si la expresi\u00f3n fuese (y == true), se tendr\u00eda raz\u00f3n. En este ejemplo, sin embargo, la expresi\u00f3n est\u00e1 asignando el valor true a y, y como se vio en la secci\u00f3n de operadores de asignaci\u00f3n, la asignaci\u00f3n misma tiene el valor de la asignaci\u00f3n. Por lo tanto, la salida ser\u00eda verdadera. Para la comparaci\u00f3n de objetos, el operador de igualdad se aplica a las referencias a estos objetos, no a los objetos a los que apuntan. Dos referencias son iguales si y solo si apuntan a lo mismo objeto, o ambos apuntan a nulo. Si se ven algunos ejemplos se entender\u00e1 mejor: File x = new File(\"myFile.txt\"); File y = new File(\"myFile.txt\"); File z = x; System.out.println(x == y); // Outputs false System.out.println(x == z); // Outputs true Aunque todas las variables apuntan a la misma informaci\u00f3n de archivo, solo dos, x y z, son iguales en t\u00e9rminos de == . En el Cap\u00edtulo 3 , \"Core Java APIs\" , se continuar\u00e1 la discusi\u00f3n sobre la igualdad de objetos introduciendo lo que significa que dos objetos diferentes sean equivalentes. Tambi\u00e9n se tratar\u00e1 la igualdad de los String y se mostrar\u00e1 c\u00f3mo este puede ser un tema no trivial.","title":"4.4.6. Operadores de igualdad"},{"location":"operaciones_sentencias/#45-comprender-las-sentencias-de-java","text":"Los operadores Java permiten crear muchas expresiones complejas, pero est\u00e1n limitadas en la manera en que pueden controlar el flujo del programa. Por ejemplo, imaginar que se quiere una secci\u00f3n de c\u00f3digo que solo sea ejecutado bajo ciertas condiciones que no pueden ser evaluadas hasta que no se ejecute. O si se desea que un segmento particular de c\u00f3digo se repita una vez por cada elemento en alguna lista. Como se dijo en el Cap\u00edtulo 1, una declaraci\u00f3n de Java es una unidad completa de ejecuci\u00f3n en Java, terminando con un punto y una coma (;) . En el cap\u00edtulo, se mostrar\u00e1n varias declaraciones de control de flujo en Java. Las declaraciones de control de flujo rompen el flujo de ejecuci\u00f3n mediante la toma de decisiones, el bucle y la ramificaci\u00f3n, permitiendo que la aplicaci\u00f3n seleccione segmentos particulares del c\u00f3digo para ejecutar. Las declaraciones se pueden aplicar a expresiones simples, o a un bloque de c\u00f3digo. Un bloque de c\u00f3digo en Java es un grupo de cero o m\u00e1s declaraciones entre llaves, ({}) , y se puede usar en cualquier lugar donde se permita usar una declaraci\u00f3n simple.","title":"4.5. Comprender las sentencias de Java"},{"location":"operaciones_sentencias/#451-if-then","text":"De vez en cuando, solo se quiere ejecutar un bloque de c\u00f3digo seg\u00fan ciertas condiciones. El if-then, como se muestra en el c\u00f3digo siguiente, permite que la aplicaci\u00f3n ejecute un bloque particular de c\u00f3digo si y solo si una expresi\u00f3n booleana se eval\u00faa como verdadera en tiempo de ejecuci\u00f3n. if(booleanExpression){ //Branch if true } Por ejemplo, si se tiene una funci\u00f3n que utiliza la hora del d\u00eda para mostrar un mensaje al usuario: if(hourOfDay < 11) System.out.println(\u201cGood Morning\u201d); Si la hora es menor que 11 entonces la funci\u00f3n mostrar\u00e1 el mensaje. Si se quisiera adem\u00e1s incrementar alg\u00fan valor, morningGreetingCount, cada vez que el mensaje se muestra se podr\u00eda repetir la declaraci\u00f3n if-then, pero Java permite escribirlo a continuaci\u00f3n del output convirtiendo el c\u00f3digo en un bloque: if(hourOfDay < 11){ System.out.println(\u201cGood Morning\u201d); morningGreetingCount++; } El bloque permite que se ejecuten m\u00faltiples instrucciones basadas en la evaluaci\u00f3n del if-then. Hay que tener en cuenta que la primera instrucci\u00f3n no contiene un bloque dentro de la secci\u00f3n de impresi\u00f3n, pero podr\u00eda tenerlo. Para mejorar la legibilidad del c\u00f3digo, se considera una buena pr\u00e1ctica colocar los bloques dentro de las sentencias if-then, as\u00ed como muchas otras sentencias de control de flujo, aunque no es obligatorio. a. Sangr\u00eda y llaves Echar un vistazo a esta forma ligeramente modificada del ejemplo: if(hourOfDay < 11) System.out.println(\"Good Morning\"); morningGreetingCount++; Si se observan las sangr\u00edas, se puede pensar que la variable morningGreetingCount solo se va a incrementar cuando la hora sea menor que 11, pero no es lo que hace el c\u00f3digo. Mostrar\u00e1 el mensaje solo si la hora es menor que 11 pero incrementar\u00e1 el valor de la variable siempre. Recuerda que en Java los espacios en blanco no son considerados parte de la ejecuci\u00f3n.","title":"4.5.1. if-then"},{"location":"operaciones_sentencias/#452-if-then-else","text":"Se va a complicar el ejemplo anterior, \u00bfqu\u00e9 pasar\u00eda si se quisiera mostrar otro mensaje cuando la hora sea mayor o igual a 11? if(hourOfDay < 11) { System.out.println(\"Good Morning\"); } if(hourOfDay >= 11) { System.out.println(\"Good Afternoon\"); } Esto es un poco redundante, ya que estamos evaluando hourOfDay dos veces, y esto puede ser computacionalmente costoso. Java permite solucionar esto gracias a la sentencia if-then-else que se muestra en el siguiente c\u00f3digo: if(booleanExpression){ // Branch if true } else { // Branch if false } Veamos este ejemplo: if(hourOfDay < 11) { System.out.println(\"Good Morning\"); } else { System.out.println(\"Good Afternoon\"); } Ahora el c\u00f3digo se est\u00e1 ramificando entre una de las dos opciones posibles, con la evaluaci\u00f3n booleana solo una vez. El operador else utiliza una declaraci\u00f3n o un bloque, de la misma manera que la sentencia if. De esta manera, se puede agregar declaraciones if-then adicionales a un bloque else para llegar a un ejemplo m\u00e1s refinado: if(hourOfDay < 11) { System.out.println(\"Good Morning\"); }else if(hourOfDay < 15) { System.out.println(\"Good Afternoon\"); }else{ System.out.println(\"Good Evening\"); } En este ejemplo, el proceso de Java continuar\u00e1 la ejecuci\u00f3n hasta que encuentre un if-then que se eval\u00fae como verdadero. Si ninguna de las dos primeras expresiones es verdadera, se ejecutar\u00e1 el c\u00f3digo del bloque else del final. Una cosa a tener en cuenta al crear complejas declaraciones if-then-else es que el orden es importante. Por ejemplo, si se reordena el fragmento de c\u00f3digo anterior de la siguiente manera: if(hourOfDay < 15) { System.out.println(\"Good Afternoon\"); } else if(hourOfDay < 11) { System.out.println(\"Good Morning\"); // UNREACHABLE CODE } else { System.out.println(\"Good Evening\"); } Para horas menores que 11, este c\u00f3digo se comporta de forma diferente al anterior. Si un valor es menor que 11, ser\u00e1 tambi\u00e9n menor que 15. Por lo tanto, si se puede alcanzar la segunda rama en el ejemplo, tambi\u00e9n se puede alcanzar la primera rama. Ya que la ejecuci\u00f3n de cada rama es excluyente, solo una rama se puede ejecutar, si se ejecuta la primera rama no se podr\u00e1 ejecutar la segunda. Por lo tanto, no hay forma de que la segunda rama se ejecute alguna vez, y el c\u00f3digo se considera inalcanzable. a. Verificando si la sentencia if se eval\u00faa en una expresi\u00f3n booleana Echar un vistazo a las siguientes l\u00edneas de c\u00f3digo: int x = 1; if(x) { // DOES NOT COMPILE ... } Esta declaraci\u00f3n puede ser v\u00e1lida en algunos otros lenguajes de programaci\u00f3n y scripting, pero no en Java, donde 0 y 1 no se consideran valores booleanos. Adem\u00e1s, hay que tener cuidado con los operadores de asignaci\u00f3n que se utilizan como si fueran operadores iguales (==) en declaraciones if-then: int x = 1; if(x = 5) { // DOES NOT COMPILE ... }","title":"4.5.2. if-then-else"},{"location":"operaciones_sentencias/#453-operador-ternario","text":"Ahora que se ha visto las declaraciones if-then-else, se puede volver brevemente a la discusi\u00f3n de los operadores y presentar al \u00faltimo operador. El operador condicional,? :, tambi\u00e9n conocido como operador ternario, es el \u00fanico operador que utiliza tres operandos y tiene la forma: booleanExpression? expression1 : expression2 El primer operando debe ser una expresi\u00f3n booleana, y el segundo y el tercero pueden ser cualquier expresi\u00f3n que devuelva un valor. La operaci\u00f3n ternaria es realmente una forma condensada de un ifthen- else que devuelve un valor. Por ejemplo, los siguientes dos fragmentos de c\u00f3digo son equivalentes: int y = 10; final int x; if(y > 5) { x = 2 * y; } else { x = 3 * y; } Comparar el c\u00f3digo anterior con el siguiente c\u00f3digo equivalente con el operador ternario: int y = 10; int x = (y > 5)? (2 * y) : (3 * y); Tener en cuenta que a menudo es \u00fatil para la legibilidad agregar par\u00e9ntesis alrededor de las expresiones en operaciones ternarias, aunque no es necesario. No es necesario que la segunda y tercera expresiones tengan los mismos tipos de datos, aunque puede entrar en juego cuando se combina con la asignaci\u00f3n operador. Comparar las siguientes dos afirmaciones: System.out.println((y > 5)? 21 : \"Zebra\"); int animal = (y < 91)? 9 : \"Horse\"; // DOES NOT COMPILE Ambas expresiones eval\u00faan valores booleanos similares y devuelven un int y un String, aunque solo se compilar\u00e1 la primera l\u00ednea. El System.out.println () no se preocupa de que las sentencias sean de tipos completamente diferentes, ya que pueden convertir ambos a String. Por otro lado, el compilador sabe que \"Horse\" es de un tipo de datos incorrecto y no puede ser asignado a un int; por lo tanto, no permitir\u00e1 que se compile el c\u00f3digo. a. Evaluaci\u00f3n de las expresiones ternarias A partir de Java 7, solo una de las expresiones de la derecha del operador ternario ser\u00e1 evaluado en tiempo de ejecuci\u00f3n. De manera similar a los operadores de cortocircuito, si una de las dos expresiones de la derecha del operador ternario realiza un efecto secundario, entonces no se puede aplicar en tiempo de ejecuci\u00f3n. Vamos a ilustrar este principio con el siguiente ejemplo: int y = 1; int z = 1; final int x = y<10? y++ : z++; System.out.println(y+\",\"+z); // Outputs 2,1 Tener en cuenta que como la parte de la izquierda de la expresi\u00f3n es verdadera solo se incrementa y. Contr\u00e1star con el siguiente ejemplo: int y = 1; int z = 1; final int x = y>=10? y++ : z++; System.out.println(y+\",\"+z); // Outputs 1,2 Ahora que la expresi\u00f3n booleana de la izquierda se eval\u00faa como falsa, solo z se incrementa. De esta manera, se ve c\u00f3mo las expresiones en un operador ternario pueden no aplicarse si la expresi\u00f3n particular no se usa. ### 4.5.4. switch Una sentencia switch, como se muestra en la Figura 2.4, es una estructura compleja de toma de decisiones en el que se eval\u00faa un solo valor y el flujo se redirige a la primera rama correspondiente, conocida como \u201ccase\u201d. Si no se encuentra dicha declaraci\u00f3n de caso que coincida con el valor, una opci\u00f3n predeterminada ser\u00e1 ejecutada. Si no hay tal opci\u00f3n predeterminada disponible, la totalidad de la sentencia switch ser\u00e1 omitida. a. Tipos de datos soportados Como se muestra en el siguiente c\u00f3digo, una instrucci\u00f3n switch tiene una variable que se eval\u00faa en tiempo de ejecuci\u00f3n. Antes de Java 5.0, esta variable solo pod\u00eda ser valores int o aquellos valores que pod\u00edan ser transformados a int, de forma espec\u00edfica byte, short, char o int. Cuando se agreg\u00f3 \u201cenum\u201d en Java 5.0, se agreg\u00f3 el soporte para que los switch pudiesen admitir valores \u201cenum\u201d. En Java 7, las sentencias switch se actualizaron a\u00fan m\u00e1s para permitir los valores string. Finalmente, la sentencia switch es compatible con cualquiera de las clases primitivas de car\u00e1cter num\u00e9rico, como Byte, Short, Character o Integer. switch(variableToTest) { case constantExpression1: // Branch for case1; break; case constantExpression2: // Branch for case2; break; ... default: } Tipos de datos soportados por la sentencia switch: - int y Integer - byte y Byte - short y Short - char y Character - String - Valores enum b. Valores constantes en tiempo de compilaci\u00f3n Los valores de cada case deben ser del mismo tipo de dato que el valor introducido en el switch. Esto significa que solo se pueden utilizar literales, constantes enum o variables constantes finales del mismo tipo de datos. Ejemplo: int dayOfWeek = 5; switch(dayOfWeek) { default: System.out.println(\"Weekday\"); break; case 0: System.out.println(\"Sunday\"); break; case 6: System.out.println(\"Saturday\"); break; } Con el valor de dayOfWeek de 5 el c\u00f3digo devolver\u00e1 \u201cWeekday\u201d. Lo primero que se puede notar es que hay una sentencia break al final de cada case y la secci\u00f3n predeterminada(default). Se discutir\u00e1 las sentencias break en detalle cuando se vean los bucles, pero por ahora, todo lo que se necesita saber es que finaliza la sentencia switch y el control de flujo vuelve a la sentencia adjunta. Como se ver\u00e1 pronto, si se omite la declaraci\u00f3n del break, el flujo continuar\u00e1 hasta el siguiente caso en curso o bloque predeterminado. Otra cosa que se puede notar es que el bloque predeterminado no est\u00e1 al final del switch. No es un requisito que el caso o las declaraciones predeterminadas est\u00e9n en un orden en particular, a menos que tenga v\u00edas que lleguen a m\u00faltiples secciones del bloque switch en una sola ejecuci\u00f3n. Para ilustrar lo aprendido se considerar\u00e1 la siguiente variaci\u00f3n: int dayOfWeek = 5; switch(dayOfWeek) { case 0: System.out.println(\"Sunday\"); default: System.out.println(\"Weekday\"); case 6 : System.out.println(\"Saturday\"); break; } Este c\u00f3digo se parece mucho al ejemplo anterior, excepto que dos de las declaraciones break han sido eliminadas y el orden ha cambiado. Esto significa que por el valor dado de dayOfWeek, 5, el c\u00f3digo saltar\u00e1 al bloque predeterminado y luego ejecutar\u00e1 todos los case en orden hasta que encuentre una sentencia break o finalice la estructura. El orden de los case y del bloque predeterminado es importante ahora ya que dejando el bloque predeterminado al final del switch, este, solo devolver\u00e1 una palabra. Si el valor de dayOfWeek fuese 6 el switch devolver\u00eda \u201cSaturday\u201d. Aunque el bloque predeterminado estaba antes del bloque case, solo se ejecut\u00f3 el bloque case. Si se recuerda la definici\u00f3n del bloque predeterminado, solo se ramificar\u00e1 si no ha coincidido el valor del caso con el valor del switch, independientemente de su posici\u00f3n dentro del switch. Por \u00faltimo, si el valor de dayOfWeek fuese 0, la salida mostrar\u00eda: Sunday Weekday Saturday Tener en cuenta que, en este \u00faltimo ejemplo, se ejecuta el bloque predeterminado porque no hay una instrucci\u00f3n break al final de los bloques de case anteriores. Mientras el c\u00f3digo no se ramifique hacia la sentencia predeterminada si hay un valor de case que coincida dentro de la declaraci\u00f3n del switch, se ejecutar\u00e1 la instrucci\u00f3n predeterminada si se encuentra despu\u00e9s de una declaraci\u00f3n de case para la que no hay declaraci\u00f3n de break. Conclusi\u00f3n, se acepta que el tipo de datos para las declaraciones de case, debe coincidir con el tipo de datos de la variable del switch. Como ya se discuti\u00f3, el valor de la declaraci\u00f3n de case tambi\u00e9n debe ser una constante literal, enum o una variable final. Por ejemplo, dada la siguiente instrucci\u00f3n switch, observar qu\u00e9 afirmaciones de case compilar\u00e1n y cuales no: private int getSortOrder(String firstName, final String lastName) { String middleName = \"Patricia\"; final String suffix = \"JR\"; int id = 0; switch(firstName){ case \"Test\": return 52; case middleName: // DOES NOT COMPILE id = 5; break; case suffix: id = 0; break; case lastName: // DOES NOT COMPILE id = 8; break; case 5: // DOES NOT COMPILE id = 7; break; case 'J': // DOES NOT COMPILE id = 10; break; case java.time.DayOfWeek.SUNDAY: // DOES NOT COMPILE id = 15; break; } return id; } La primera declaraci\u00f3n de case compila sin problemas usando un String, y es un buen ejemplo de c\u00f3mo una declaraci\u00f3n de return, se puede usar para salir del switch. La segunda declaraci\u00f3n de case no se compila porque middleName no es una variable final, a pesar de tener un valor conocido en esta l\u00ednea de ejecuci\u00f3n en particular. La tercera declaraci\u00f3n compila sin problema porque suffix es una variable constante final. La cuarta declaraci\u00f3n, aunque LastName sea final, no es una constante ya que se ha pasado a la funci\u00f3n, por lo tanto, esta l\u00ednea tampoco compila. Finalmente, los tres \u00faltimos case no compilan porque ninguno de ellos coincide con el tipo String de la variable del switch, el \u00faltimo es de tipo enum value. ### 4.5.5. while Una estructura de control de repetici\u00f3n, tambi\u00e9n conocida como bucle, ejecuta el mismo c\u00f3digo varias veces seguidas. Mediante el uso de variables no constantes, cada repetici\u00f3n de la sentencia puede ser diferente. Por ejemplo, una declaraci\u00f3n que se itera sobre una lista de nombres \u00fanicos y las salidas devolver\u00e1n un nuevo nombre en cada ejecuci\u00f3n del bucle. La estructura de control de repetici\u00f3n m\u00e1s simple en Java es la instrucci\u00f3n while, descrita en el siguiente c\u00f3digo. Como todas las estructuras de control de repetici\u00f3n, tiene una condici\u00f3n de terminaci\u00f3n, implementada como una expresi\u00f3n booleana, que continuar\u00e1 mientras la expresi\u00f3n se eval\u00fae a true. while(booleanExpression){ //Body } Como se muestra en el c\u00f3digo, un bucle while es similar a las sentencias if-then ya que est\u00e1 compuesta por una expresi\u00f3n booleana e instrucciones o bloque de instrucciones. Durante la ejecuci\u00f3n, la expresi\u00f3n booleana es evaluada antes de cada iteraci\u00f3n del bucle y termina si la evaluaci\u00f3n devuelve un false. Es importante darse cuenta que el bucle while puede terminar despu\u00e9s de su primera evaluaci\u00f3n de la expresi\u00f3n booleana. De esta forma el bloque de instrucciones puede no ejecutarse nunca. Si se vuelve al ejemplo de rat\u00f3n del cap\u00edtulo 3 y se muestra un bucle que puede ser utilizado para modelar un rat\u00f3n comiendo una comida: int roomInBelly = 5; public void eatCheese(int bitesOfCheese) { while(bitesOfCheese > 0 && roomInBelly > 0) { bitesOfCheese--; roomInBelly--; } System.out.println(bitesOfCheese+\" pieces of cheese left\"); } Este m\u00e9todo coge una cantidad de comida, en este caso de queso, y continua hasta que el rat\u00f3n no tenga m\u00e1s espacio en su est\u00f3mago o no quede comida para comer. Con cada iteraci\u00f3n del bucle, el rat\u00f3n come un trozo de comida y pierde una parte del espacio en su est\u00f3mago. Utilizando una sentencia booleana compuesta, nos aseguramos de que el bucle while pueda terminar por cualquiera de las condiciones. a. Bucles infinitos Considerar el siguiente c\u00f3digo: int x = 2; int y = 5; while(x < 10) y++; Se puede observar un evidente problema con esta declaraci\u00f3n: nunca acabar\u00e1. La expresi\u00f3n booleana que se eval\u00faa antes de cada iteraci\u00f3n del bucle nunca se modifica por lo que la expresi\u00f3n (x < 10) siempre ser\u00e1 evaluada a true. El resultado es que el bucle nunca acabar\u00e1 creando lo que se conoce como bucle infinito. Los bucles infinitos son algo que se debe tener en cuenta al crear bucles. Se tiene que estar seguro de que el bucle termina bajo alguna condici\u00f3n. Primero comprobar que la variable del bucle se modifica. Luego, asegurarse que la condici\u00f3n de terminaci\u00f3n se alcanza bajo cualquier circunstancia. Como se ver\u00e1 en \u201cEntendiendo los flujos de control avanzados\u201d de un bucle se puede salir tambi\u00e9n con otras condiciones como con la sentencia break. ### 4.5.6. do-while Java tambi\u00e9n permite crear bucles do-while, que como al bucle while, es una estructura de control de repetici\u00f3n con una condici\u00f3n de terminaci\u00f3n e instrucciones o bloques de instrucciones, como se muestra en el siguiente c\u00f3digo. Al contrario que el bucle while, el bucle do-while garantiza que la instrucci\u00f3n o el bloque de instrucciones se ejecutar\u00e1 m\u00ednimo una vez. do{ //Body }while(booleanExpression); La principal diferencia entre la estructura del do-while y del while es que ordena intencionadamente las instrucciones o los bloques de instrucciones antes de la expresi\u00f3n condicional, para recalcar que la instrucci\u00f3n ser\u00e1 ejecutada antes de evaluar la expresi\u00f3n. Por ejemplo, mirar la salida del siguiente c\u00f3digo: int x = 0; do { x++; }while(false); System.out.println(x); // Outputs 1 Java ejecutar\u00e1 primero el bloque de instrucciones, y luego comprobar\u00e1 la condici\u00f3n del bucle. A pesar de que el bucle termina inmediatamente, el bloque de instrucciones se ejecuta una vez y el programa devuelve 1. a. Cuando usar bucles while o do-while En la pr\u00e1ctica, puede ser dif\u00edcil determinar cu\u00e1ndo se debe utilizar un bucle while y un bucle do-while. No importa cual se utilice ya que cualquier bucle while se puede convertir en un bucle do-while y viceversa. Comparar estos dos bucles: while(x > 10) { x--; } if(x > 10) { do { x--; }while(x > 10); } Aunque uno de los bucles es m\u00e1s f\u00e1cil de leer, son funcionalmente iguales. Java recomienda utilizar los bucles while cuando no sea necesario ejecutar sus instrucciones, y utilizar los bucles do-while cuando sea imprescindible que se ejecute como m\u00ednimo una vez, pero, en la pr\u00e1ctica, elegir entre uno u otro es algo personal. Por ejemplo, pese a que la primera declaraci\u00f3n es m\u00e1s corta, la segunda tiene una ventaja que permite hacer uso de la sentencia if-then y realizar otras operaciones en la rama del else, como se muestra en el ejemplo: if(x > 10) { do { x-- ; }while(x > 10); } else { x++; } ### 4.5.7. La sentencia for Ahora se extender\u00e1 el conocimiento con otra estructura de control repetici\u00f3n llamada \u201cfor\u201d. Existen dos tipos de sentencia for, la primera se refiere al bucle simple for, la segunda se llama for-each que es una mejora de la sentencia for. a. La sentencia for simple Un bucle for simple tiene la misma condici\u00f3n booleana o bloque de instrucciones que los otros bucles que hemos visto, e incluye dos nuevas secciones: la inicializaci\u00f3n y la actualizaci\u00f3n. El siguiente c\u00f3digo muestra como estos componentes est\u00e1n organizados: for(initialization; booleanExpression; updateStatement) { // Body } El c\u00f3digo puede parecer algo confusa y arbitraria al principio, la organizaci\u00f3n de los componentes y el flujo permite crear poderosas sentencias en poco espacio al contrario de otros bucles que necesitar\u00edan m\u00faltiples l\u00edneas. Fijarse que cada secci\u00f3n est\u00e1 separada por punto y coma (;) y la inicializaci\u00f3n y la actualizaci\u00f3n pueden contener varias sentencias separadas por comas. Las variables creadas en el bloque de inicializaci\u00f3n tienen un \u00e1mbito limitado y solo ser\u00e1n accesibles dentro del bucle for. Alternativamente, las variables declaradas antes del for y modificadas en el bloque de inicializaci\u00f3n pueden ser utilizadas fuera del bucle for ya que su \u00e1mbito es anterior a la creaci\u00f3n del bucle for. A continuaci\u00f3n, este ejemplo imprime en pantalla los n\u00fameros del 0 al 9: for(int i = 0; i < 10; i++) { System.out.print(i + \" \"); } La variable local i se inicializa a 0. Esta variable tiene un \u00e1mbito dentro del bucle y no es accesible desde fuera del bucle una vez el bucle haya terminado. Como en los bucles while, la expresi\u00f3n booleana es evaluada en cada iteraci\u00f3n del bucle antes de que se ejecuten las instrucciones del este. Si devuelve un true, el bucle se ejecuta e imprime el 0 seguido de un espacio en blanco. Luego el bucle ejecuta el bloque de actualizaci\u00f3n, que en este caso incrementa el valor de i a 1. Entonces el bucle eval\u00faa otra vez la expresi\u00f3n booleana y el proceso se repite varias veces, imprimiendo lo siguiente: 0 1 2 3 4 5 6 7 8 9 En la d\u00e9cima iteraci\u00f3n del bucle, el valor de i alcanza el 9 y se incrementa a 10. En la und\u00e9cima iteraci\u00f3n del bucle la expresi\u00f3n booleana ser\u00e1 evaluada a falso ya que 10 no es menor que 10, el bucle terminar\u00e1 sin ejecutar el bloque de instrucciones. Ejemplos con los que familiarizarse: - Creaci\u00f3n de un bucle infinito for( ; ; ) { System.out.println(\"Hello World\"); } Puede parecer que este bucle for dar\u00e1 problemas de compilaci\u00f3n, pero compilar\u00e1 y funcionar\u00e1 sin problemas. Es un bucle infinito que imprimir\u00e1 el mismo mensaje repetidas veces. Este ejemplo refuerza la idea de que los componentes del bucle for son opcionales, y recuerda que el punto y coma que separa las secciones son necesarios, for() no compilar\u00e1. - Adici\u00f3n de varios t\u00e9rminos a la sentencia for int x = 0; for(long y = 0, z = 4; x < 5 && y < 10; x++, y++) { System.out.print(y + \" \"); } System.out.print(x); Este c\u00f3digo demuestra tres variaciones del bucle for que puede que a\u00fan no se hayan visto. Primero, se puede declarar una variable, como x en el ejemplo, antes de que el bucle empiece y usarla despu\u00e9s de que termine. Segundo, el bloque de inicializaci\u00f3n, la expresi\u00f3n booleana, y el bloque de actualizaci\u00f3n, pueden incluir variables extra que pueden no referenciarse entre ellas. Por ejemplo, z est\u00e1 definida en el bloque de inicializaci\u00f3n y nunca se usa. Finalmente, el bloque de actualizaci\u00f3n puede modificar m\u00faltiples variables. El c\u00f3digo imprimir\u00e1: 0 1 2 3 4 - Re-declarando una variable en el bloque de inicializaci\u00f3n int x = 0; for(long y = 0, x = 4; x < 5 && y < 10; x++, y++) { // DOES NOT COMPILE System.out.print(x + \" \"); } Este ejemplo parece similar al anterior, pero no compila debido al bloque de inicializaci\u00f3n. La diferencia es que x se repite en el bloque de inicializaci\u00f3n despu\u00e9s de haber sido declarado ya antes del loop, dando lugar a que el compilador se detenga debido a una declaraci\u00f3n de variable duplicada. Se puede fijar este bucle cambiando la declaraci\u00f3n de x y y como sigue: int x = 0; long y = 10; for(y = 0, x = 4; x < 5 && y < 10; x++, y++) { System.out.print(x + \" \"); } Tener en cuenta que esta variaci\u00f3n si compilar\u00e1 porque el bloque de inicializaci\u00f3n simplemente asigna un valor a x y no lo declara. - Utilizando tipos de datos incompatibles en el bloque de inicializaci\u00f3n for(long y = 0, int x = 4; x < 5 && y<10; x++, y++) { // DOES NOT COMPILE System.out.print(x + \" \"); } Este ejemplo tambi\u00e9n se parece mucho al segundo ejemplo, pero como en el tercer ejemplo no compilar\u00e1, aunque esta vez por una raz\u00f3n diferente. Las variables del bloque de inicializaci\u00f3n deben ser del mismo tipo. En el primer ejemplo, y y z eran ambos long, as\u00ed que el c\u00f3digo compilar\u00e1 sin problema, pero en este ejemplo tienen tipos diferentes, por lo que el c\u00f3digo no se compilar\u00e1. - Usando variables del bucle fuera de este for(long y = 0, x = 4; x < 5 && y < 10; x++, y++) { System.out.print(y + \" \"); } System.out.print(x); // DOES NOT COMPILE La variaci\u00f3n final del segundo ejemplo no compilar\u00e1 por una raz\u00f3n diferente a la de los ejemplos anteriores. Fijarse que x se define en el bloque de inicializaci\u00f3n del bucle, y luego se usa despu\u00e9s de que el bucle termine. Puesto que x s\u00f3lo tiene \u00e1mbito para el bucle, usarlo fuera del bucle lanzar\u00e1 un error de compilaci\u00f3n. ### 4.5.8. La sentencia for-each A partir de Java 5.0, los desarrolladores han tenido una mejora para el bucle for a su disposici\u00f3n, uno espec\u00edficamente dise\u00f1ado para iterar sobre arrays y colecci\u00f3n de objetos. Esto mejora el bucle for, que para mayor claridad se har\u00e1 referencia a \u00e9l como un bucle for-each, como se muestra en el siguiente c\u00f3digo: for(datatype instance : collection){ //Body } La declaraci\u00f3n del bucle for-each est\u00e1 compuesta por una secci\u00f3n de inicializaci\u00f3n y un objeto para utilizarlo repetidas veces. El lado derecho de la sentencia for-each debe ser un array o un objeto que implemente la clase Java.lang.Iterable, que incluye la mayor parte de los frameworks de Java Collections. El lado izquierdo del bucle for-each debe incluir una declaraci\u00f3n para una instancia de una variable, cuyo tipo coincida con el tipo de un miembro del array o de la colecci\u00f3n en el lado derecho de la sentencia. Ejemplos: final String[] names = new String[3]; names[0] = \"Lisa\"; names[1] = \"Kevin\"; names[2] = \"Roger\"; for(String name : names) { System.out.print(name + \", \"); } Este c\u00f3digo compilar\u00e1 e imprimir\u00e1: Lisa, Kevin, Roger, java.util.List<String> values = new java.util.ArrayList<String>(); values.add(\"Lisa\"); values.add(\"Kevin\"); values.add(\"Roger\"); for(String value : values) { System.out.print(value + \", \"); } Este c\u00f3digo compilar\u00e1 e imprimir\u00e1: Lisa, Kevin, Roger, String names = \"Lisa\"; for(String name : names) { // DOES NOT COMPILE System.out.print(name + \" \"); } En este ejemplo, el String names no es un array y no implementa la clase java.lang.iterable, as\u00ed que el compilador lanzar\u00e1 una excepci\u00f3n ya que no sabe como iterar un String. String[] names = new String[3]; for(int name : names) { // DOES NOT COMPILE System.out.print(name + \" \"); } Este c\u00f3digo no compilar\u00e1 porque en el lado izquierdo del bucle no se define una instancia de String. N\u00f3tese que, en este \u00faltimo ejemplo, el array se inicializa con tres valores de puntero cero. En s\u00ed mismo, eso no causar\u00e1 un fallo de compilaci\u00f3n, s\u00f3lo imprimir\u00e1 tres veces cero. a. Comparaci\u00f3n del bucle for y el bucle for-each Dado que for y for-each usan la misma palabra clave, es posible preguntarse c\u00f3mo est\u00e1n relacionados. Tomar un momento para explorar c\u00f3mo el compilador convierte cada for-each en bucles for. Cuando se introdujo el bucle for-each en Java 5, se agreg\u00f3 como una mejora de compilaci\u00f3n. Esto significa que Java realmente convierte el bucle for-each en un bucle for est\u00e1ndar durante compilaci\u00f3n. Por ejemplo, asumiendo que names es un array de String[] como se vio en la primera parte. Ejemplo, los dos bucles siguientes son equivalentes: for(String name : names) { System.out.print(name + \", \"); } for(int i=0; i < names.length; i++) { String name = names[i]; System.out.print(name + \", \"); } Para los objetos que heredan de Java.lang.iterable, hay una conversi\u00f3n diferente, pero similar. Por ejemplo, asumiendo que los valores son una instancia de List , como vimos en el segundo caso ejemplo, los dos bucles siguientes son equivalentes: for(int value : values) { System.out.print(value + \", \"); } for(java.util.Iterator<Integer> i = values.iterator(); i.hasNext(); ) { int value = i.next(); System.out.print(value + \", \"); } Observar que, en la segunda versi\u00f3n, no hay declaraci\u00f3n de actualizaci\u00f3n ya que no se requiere cuando se usa la clase java.util.Iterator. Es posible que se haya notado que, en los ejemplos anteriores, hab\u00eda una coma extra impresa al final de la lista: Lisa, Kevin, Roger, Mientras que la declaraci\u00f3n for-each es conveniente para trabajar con listas en muchos casos, oculta el acceso a la variable iterator del bucle. Si se quisiera imprimir s\u00f3lo la coma entre nombres, se podr\u00eda convertir el ejemplo en un bucle for est\u00e1ndar, como en el ejemplo siguiente: java.util.List names = new java.util.ArrayList (); names.add(\"Lisa\"); names.add(\"Kevin\"); names.add(\"Roger\"); for(int i=0; i 0) { System.out.print(\", \"); } System.out.print(name); } Este c\u00f3digo de muestra producir\u00eda lo siguiente: Lisa, Kevin, Roger Tambi\u00e9n es com\u00fan utilizar un bucle for sobre un bucle for-each si se comparan m\u00faltiples elementos en un bucle dentro de una sola iteraci\u00f3n, como en el ejemplo siguiente. Observar que se salta la ejecuci\u00f3n del primer bucle, ya que el valor[-1] no est\u00e1 definido y arrojar\u00eda un IndexOutOfBoundsException error. int[] values = new int[3]; values[0] = 10; values[1] = new Integer(5); values[2] = 15; for(int i=1; i<values.length; i++) { System.out.print(values[i]-values[i- 1]); } Este c\u00f3digo devolver\u00e1 lo siguiente: - 5, 10, A pesar de estos ejemplos, los bucles mejorados for-each son bastante \u00fatiles en Java en una gran variedad de circunstancias. Como desarrollador, sin embargo, siempre se puede volver a un for est\u00e1ndar si se necesita un control m\u00e1s fino. ## 4.6. Comprendiendo el control de flujo avanzado Hasta ahora, se ha tratado con bucles simples que s\u00f3lo terminaban cuando su expresi\u00f3n booleana es evaluada como falsa. Ahora se mostrar\u00e1 otras formas en la que los bucles podr\u00edan terminar, o ramificar, y se ver\u00e1 que el camino tomado durante el tiempo de ejecuci\u00f3n puede no ser tan sencillo como en los ejemplos anteriores. ### 4.6.1. Bucles anidados En primer lugar, los bucles pueden contener otros bucles. Por ejemplo, considerar el siguiente c\u00f3digo que itera sobre una matriz bidimensional, una matriz que contiene otras matrices como sus miembros. Se cubrir\u00e1 los arreglos multidimensionales en detalle en el Cap\u00edtulo 3, pero por ahora se supondr\u00e1 que la siguiente es la forma de declarar un arreglo bidimensional. int[][] myComplexArray = {{5,2,1,3},{3,9,8,9},{5,7,12,7}}; for(int[] mySimpleArray : myComplexArray) { for(int i=0; i<mySimpleArray.length; i++) { System.out.print(mySimpleArray[i]+\"\\t\"); } System.out.println(); } N\u00f3tese que en este ejemplo se mezcla intencionalmente un bucle for y uno for-each. Los bucles externos se ejecutar\u00e1n un total de tres veces. Cada vez que se ejecuta el bucle exterior, el bucle interior se ejecutar\u00e1 cuatro veces. Cuando se ejecuta este c\u00f3digo, se ve la siguiente salida: 5 2 1 3 3 9 8 9 5 7 12 7 Los bucles anidados pueden incluir bucles while y do-while, como se muestra en este ejemplo. Ver si se puede determinar lo que este c\u00f3digo saldr\u00e1. int x = 20; while(x>0) { do { x -= 2 }while (x>5); x--; System.out.print(x+\"\\t\"); } La primera vez que este bucle se ejecuta, el bucle interno se repite hasta que el valor de x es 4. El valor ser\u00e1 entonces decrementado a 3 y ser\u00e1 la salida, al final de la primera iteraci\u00f3n del bucle exterior. En la segunda iteraci\u00f3n del bucle exterior, el do-while interno se ejecutar\u00e1 una vez, aunque x no sea mayor que 5. Recordar que las sentencias do-while siempre se ejecutan al menos una vez. Esto reducir\u00e1 el valor a 1, que ser\u00e1 decrementado a\u00fan m\u00e1s por el operador de decremento en el bucle exterior a 0. Una vez que el valor alcance 0, el bucle externo se termina. El resultado es que el c\u00f3digo emitir\u00e1 lo siguiente: 3 0 ### 4.6.2. A\u00f1adiendo etiquetas opcionales Una cosa que se omite cuando se presentan las sentencias if-then, las sentencias switch y bucles es que todos ellos pueden tener etiquetas opcionales. Una etiqueta es un puntero opcional a la cabeza de una instrucci\u00f3n que permite a la aplicaci\u00f3n saltar a ella o acabar. Es una sola palabra que procede de dos puntos (:). Por ejemplo, se puede a\u00f1adir etiquetas opcionales a uno de los ejemplos anteriores: int[][] myComplexArray = {{5,2,1,3},{3,9,8,9},{5,7,12,7}}; OUTER_LOOP: for(int[] mySimpleArray : myComplexArray) { INNER_LOOP: for(int i=0; i<mySimpleArray.length; i++) { System.out.print(mySimpleArray[i]+\"\\t\"); } System.out.println(); } Cuando se trata de un solo bucle, no a\u00f1aden ning\u00fan valor, pero como se ver\u00e1 en la siguiente secci\u00f3n, son extremadamente \u00fatiles en entornos anidados. Las etiquetas opcionales a menudo s\u00f3lo se utilizan en estructuras de bucle. Dicho esto, rara vez se considera una buena pr\u00e1ctica de codificaci\u00f3n hacerlo. Las etiquetas siguen las mismas reglas para los identificadores. En cuanto a la legibilidad, se expresan com\u00fanmente en may\u00fasculas, con barra baja entre palabras, para distinguirlas de las variables regulares. ### 4.6.3. La declaraci\u00f3n break Como se vio al trabajar con las sentencia switch, una declaraci\u00f3n break transfiere el flujo de control a la declaraci\u00f3n adjunta. Lo mismo es v\u00e1lido para las sentencias break que aparecen dentro de bucles while, do-while, y bucles for, ya que terminaran el bucle temprano, como se muestra en el siguiente c\u00f3digo: optionalLabel: while(booleanExpression) { // Body // Somewhere in loop break optionalLabel; } Observar en el c\u00f3digo que la sentencia break puede tomar un par\u00e1metro opcional de etiqueta. Sin un par\u00e1metro de etiqueta, la sentencia break terminar\u00e1 el bucle interno m\u00e1s cercano que est\u00e9 ejecutando actualmente. El par\u00e1metro de etiqueta opcional permite salir de un bucle exterior de nivel superior. En el siguiente ejemplo, se busca la primera posici\u00f3n del \u00edndice de matriz (x, y) de un n\u00famero dentro de una matriz bidimensional no clasificada: public class SearchSample { public static void main(String[] args) { int[][] list = {{1,13,5},{1,2,5},{2,7,2}}; int searchValue = 2; int positionX = -1; int positionY = -1; PARENT_LOOP: for(int i=0; i<list.length; i++) { for(int j=0; j<list[i].length; j++) { if(list[i][j]==searchValue){ positionX = i; positionY = j; break PARENT_LOOP; } } } if(positionX==-1 || positionY==-1) { System.out.println(\"Value \"+searchValue+\" not found\"); } else { System.out.println(\"Value \"+searchValue+\" found at: \" + \"(\"+positionX+\",\"+positionY+ \")\"); } } } Cuando se ejecute, este c\u00f3digo saldr\u00e1: Value 2 found at: (1,1) En particular, \u00e9chese un vistazo a la sentencia break PARENT_LOOP. Esta declaraci\u00f3n romper\u00e1 de toda la estructura del bucle tan pronto como se encuentre el primer valor que se ajuste. Ahora, imaginar lo que pasar\u00eda si se reemplazara el cuerpo del bucle interno por el siguiente: if(list[i][j]==searchValue) { positionX = i; positionY = j; break; } \u00bfC\u00f3mo cambiar\u00eda esto la salida? En lugar de salir cuando se encuentra el primer valor que coincida, el programa s\u00f3lo saldr\u00e1 del bucle interno cuando se cumpla la condici\u00f3n. En otras palabras, la estructura ahora encontrar\u00e1 el primer valor que se ajuste del \u00faltimo bucle interno que contenga el valor, resultando en la siguiente salida: Value 2 found at: (2,0) Finalmente, \u00bfqu\u00e9 tal si se elimina el break por completo? if(list[i][j]==searchValue) { positionX = i; positionY = j; } En este caso, el c\u00f3digo buscar\u00e1 el \u00faltimo valor de toda la estructura que tenga el valor equivalente. La salida se ver\u00e1 as\u00ed: Value 2 found at: (2,2) Se puede ver en este ejemplo que el uso de una etiqueta en una sentencia break en un bucle anidado, o el no uso de la sentencia break en absoluto, puede hacer que el bucle se comporte de forma muy diferente. ### 4.6.4. La sentencia continue Se completar\u00e1 ahora la discusi\u00f3n sobre el control avanzado del bucle con la sentencia continue, una declaraci\u00f3n que causa que el flujo de datos finalice la ejecuci\u00f3n del bucle actual, como se muestra en el siguiente c\u00f3digo: Se puede notar que la sintaxis de la declaraci\u00f3n continue refleja la declaraci\u00f3n break. De hecho, las sentencias son similares en cuanto a su uso, pero con resultados diferentes. Mientras que la sentencia break transfiere el control a la sentencia adjunta, la sentencia continue transfiere el control a la expresi\u00f3n booleana que determina si el bucle debe continuar. En otras palabras, termina la iteraci\u00f3n actual del bucle. Tambi\u00e9n, al igual que la declaraci\u00f3n break, la declaraci\u00f3n continue se aplica al bucle interno m\u00e1s cercano en ejecuci\u00f3n usando instrucciones de etiqueta opcionales para anular este comportamiento. Ejemplo: public class SwitchSample { public static void main(String[] args) { FIRST_CHAR_LOOP: for (int a = 1; a <= 4; a++) { for (char x = 'a'; x <= 'c'; x++) { if (a == 2 || x == 'b') continue FIRST_CHAR_LOOP; System.out.print(\" \" + a + x); } } } } Con la estructura definida, el bucle devolver\u00e1 el control al bucle padre cada vez que el primer valor sea 2 o el segundo valor sea b. Esto resulta en una ejecuci\u00f3n del bucle interno para cada una de las tres llamadas del bucle exterior. La salida se ve as\u00ed: 1a 3a 4a Ahora, imaginar que se elimina la etiqueta FIRST_CHAR_LOOP en la declaraci\u00f3n continue para que el control sea devuelto al bucle interno en vez del externo. Mirar c\u00f3mo cambiar\u00e1 la salida: 1a 1c 3a 3c 4a 4c optionalLabel: while(booleanExpression) { // Body // Somewhere in loop continue optionalLabel; } Por \u00faltimo, si se elimina la sentencia continue y la sentencia if-then asociada a \u00e9sta, se llega a una estructura que produce todos los valores, tales como: 1a 1b 1c 2a 2b 2c 3a 3b 3c 4a 4b 4c La siguiente tabla ayudar\u00e1 a recordar cuando se permiten etiquetas, break, y sentencias continue en Java. Aunque para fines ilustrativos los ejemplos han incluido el uso de estas sentencias en bucles anidados, tambi\u00e9n se pueden usar dentro de bucles simples. (^) Permite etiquetas opcionales Permite sentencias break Permite sentencias continue if Si No No while Si Si Si do while Si Si Si for Si Si Si switch Si Si No ### 4.6.1. Resumen En este cap\u00edtulo, se ha visto que: Entender los operadores de Java - C\u00f3mo utilizar todos los operadores Java requeridos que se describen. - Saber c\u00f3mo influye la precedencia del operador en la forma en que se interpreta una expresi\u00f3n determinada. Usando operadores binarios - Los operadores de asignaci\u00f3n son operadores binarios que modifican la variable con el valor del lado derecho de la ecuaci\u00f3n. - El \u201ccasting\u201d es necesario siempre que se pase de un dato num\u00e9rico m\u00e1s grande a un tipo de datos num\u00e9ricos m\u00e1s peque\u00f1os, o la conversi\u00f3n de un n\u00famero float a un valor int. - Los operadores complejos son operadores de asignaci\u00f3n con una operaci\u00f3n aritm\u00e9tica o l\u00f3gica incorporada que se aplican de izquierda a derecha de la expresi\u00f3n y almacena el valor resultante en la variable de la parte izquierda de la pantalla. - Los operadores relacionales son aquellos que comparan dos expresiones y devuelven un valor booleano. - Los operadores l\u00f3gicos, (&), (|) y (^), se pueden aplicar a datos de tipo num\u00e9ricos y booleanos. - Los operadores de igualdad comparan dos operandos y devuelven un valor booleano si las expresiones o valores son iguales, o no iguales, respectivamente. Comprender las sentencias de Java - Las estructuras de control: las estructuras de control de la toma de decisiones, incluidas las de tipo ifthen, if-then-else y switch, as\u00ed como las estructuras de control de la repetici\u00f3n, incluidas for, for-each, while y do-while. - La mayor\u00eda de estas estructuras requieren la evaluaci\u00f3n de una expresi\u00f3n booleana en particular, ya sea para las decisiones de ramificaci\u00f3n o una vez por repetici\u00f3n. - La sentencia switch es la \u00fanica que soporta una variedad de tipos de datos, incluyendo variables String a partir de Java 7. - Con un for-each no es necesario escribir expl\u00edcitamente una expresi\u00f3n booleana, ya que el compilador las construye impl\u00edcitamente. Para mayor claridad, se refiere a un bucle for mejorado como un bucle foreach, pero sint\u00e1cticamente est\u00e1n escritos como una declaraci\u00f3n for. Comprendiendo el control de flujo avanzado ``` - Los bucles pueden contener otros bucles, incluidos bucles while y do-while. - Una etiqueta es un puntero opcional a la cabeza de una instrucci\u00f3n que permite a la aplicaci\u00f3n saltar a ella o acabar. - C\u00f3mo se puede mejorar el flujo a trav\u00e9s de los bucles anidados, de sentencias break y de sentencias continue.","title":"4.5.3. Operador Ternario"}]}